<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial06 - Multithreading</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('da/d94/DiligentSamples_Tutorials_Tutorial06_Multithreading_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial06 - Multithreading</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial shows how to record command lists in parallel from multiple threads.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial06_Multithreading/Animation_Large.gif" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial06_Multithreading/Tutorial06_Multithreading.html">â–¶ Run in the browser</a></p>
<p>This tutorial generates the same output as Tutorial05, but renders every cube using individual draw call. It shows how recording commands can be split between multiple threads. Note that this tutorial illustrates the API usage and for this specific rendering problem, instancing is a more efficient solution. However, multithreading in a real application can be implemented in the same way as shown in this tutorial.</p>
<h2><a class="anchor" id="autotoc_md307"></a>
Shaders</h2>
<p>This tutorial uses shaders from Tutorial03. While pixel shader is exactly the same, the vertex shader applies rotation and instance-specific transformation before the global view-projection transform. The instance transform matrix resides in its own constant buffer that is updated every time a new instance is rendered.</p>
<div class="fragment"><div class="line">cbuffer Constants</div>
<div class="line">{</div>
<div class="line">    float4x4 g_ViewProj;</div>
<div class="line">    float4x4 g_Rotation;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">cbuffer InstanceData</div>
<div class="line">{</div>
<div class="line">    float4x4 g_InstanceMatr;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct VSInput</div>
<div class="line">{</div>
<div class="line">    float3 Pos : ATTRIB0; </div>
<div class="line">    float2 UV  : ATTRIB1,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct PSInput </div>
<div class="line">{ </div>
<div class="line">    float4 Pos : SV_POSITION; </div>
<div class="line">    float2 uv : TEX_COORD; </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void main(in  VSInput VSIn,</div>
<div class="line">          out PSInput PSIn) </div>
<div class="line">{</div>
<div class="line">    // Apply rotation</div>
<div class="line">    float4 TransformedPos = mul( float4(VSIn.Pos,1.0),g_Rotation);</div>
<div class="line">    // Apply instance-specific transformation</div>
<div class="line">    TransformedPos = mul(TransformedPos, g_InstanceMatr);</div>
<div class="line">    // Apply view-projection matrix</div>
<div class="line">    PSIn.Pos = mul( TransformedPos, g_ViewProj);</div>
<div class="line">    PSIn.UV  = VSIn.UV;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md308"></a>
Resource initialization</h2>
<p>Pipeline state, shaders, vertex and index buffers are initialized in the same way as in previous tutorials. What is different is that this time we load every texture individually, and then bind the texture to its own shader resource binding object:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> tex=0; tex &lt; NumTextures; ++tex)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create one Shader Resource Binding for every texture</span></div>
<div class="line">    m_pPSO-&gt;CreateShaderResourceBinding(&amp;m_SRB[tex]);</div>
<div class="line">    m_SRB[tex]-&gt;GetVariableByName(SHADER_TYPE_PIXEL, <span class="stringliteral">&quot;g_Texture&quot;</span>)-&gt;Set(m_TextureSRV[tex]);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example illustrates the expected usage of mutable shader resources: the app creates several SRB objects encompassing different resource bindings.</p>
<h2><a class="anchor" id="autotoc_md309"></a>
Explicit state transitoins</h2>
<p>This tutorial explicitly transitions all resources to required states using <code>IDeviceContext::TransitionResourceStates()</code> method. The method takes an array of <code>StateTransitionDesc</code> structures. The structure defines resource to transition, as well old state and new states. Old state can be set to <code>RESOURCE_STATE_UNKNOWN</code> in which case the engine will use the internal resource state. For a texture, the structure also defines the range of array slices and mip levels to transition. For example, transitioning vertex and index buffers to required states can be performed as follows:</p>
<div class="fragment"><div class="line">StateTransitionDesc Barriers[2];</div>
<div class="line">Barriers[0].pBuffer  = m_CubeVertexBuffer;</div>
<div class="line">Barriers[0].<a class="code hl_variable" href="../../dc/da9/structDiligent_1_1StateTransitionDesc.html#a0a99fceb3fffbe1f1deb8b1cd6f3b96d">OldState</a> = RESOURCE_STATE_UNKNOWN; <span class="comment">// Use the internal buffer state</span></div>
<div class="line">Barriers[0].NewState = RESOURCE_STATE_VERTEX_BUFFER;</div>
<div class="line">Barriers[0].UpdateResourceState = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">Barriers[1].pBuffer  = m_CubeIndexBuffer;</div>
<div class="line">Barriers[1].OldState = RESOURCE_STATE_UNKNOWN; <span class="comment">// Use the internal buffer state</span></div>
<div class="line">Barriers[1].NewState = RESOURCE_STATE_INDEX_BUFFER;</div>
<div class="line">Barriers[1].UpdateResourceState = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;TransitionResourceStates(2, Barriers);</div>
<div class="ttc" id="astructDiligent_1_1StateTransitionDesc_html_a0a99fceb3fffbe1f1deb8b1cd6f3b96d"><div class="ttname"><a href="../../dc/da9/structDiligent_1_1StateTransitionDesc.html#a0a99fceb3fffbe1f1deb8b1cd6f3b96d">Diligent::StateTransitionDesc::OldState</a></div><div class="ttdeci">RESOURCE_STATE OldState</div><div class="ttdoc">Resource state before transition.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:2252</div></div>
</div><!-- fragment --><p>When resources are explicitly transitioned to correct states, the engine does not need to check the states at every draw command which greatly reduces the overhead.</p>
<h2><a class="anchor" id="autotoc_md310"></a>
Multithreaded Rendering</h2>
<p>All rendering commands in <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine are issued through device contexts. Similar to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff476880(v=vs.85).aspx">Direct3D11</a>, there are two types of contexts: immediate and deferred. An immediate context records rendering commands and implicitly submits them for execution. Deferred contexts can only record commands to a command list that can later be executed through the immediate context. Deferred contexts should be created for every worker thread that records rendering commands.</p>
<h3><a class="anchor" id="autotoc_md311"></a>
Main Thread</h3>
<p>Main thread coordinates the execution of worker threads and handles recorded command lists. It starts by signaling all worker threads to start:</p>
<div class="fragment"><div class="line">m_NumThreadsCompleted.store(0);</div>
<div class="line">m_RenderSubsetSignal.Trigger(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p>and renders its own subset:</p>
<div class="fragment"><div class="line">RenderSubset(m_pImmediateContext, 0);</div>
</div><!-- fragment --><p>It then waits until worker threads signal that all command lists are ready and executes them:</p>
<div class="fragment"><div class="line">m_ExecuteCommandListsSignal.Wait(<span class="keyword">true</span>, 1);</div>
<div class="line"> </div>
<div class="line">m_CmdListPtrs.resize(m_CmdLists.size());</div>
<div class="line"><span class="keywordflow">for</span> (Uint32 i = 0; i &lt; m_CmdLists.size(); ++i)</div>
<div class="line">    m_CmdListPtrs[i] = m_CmdLists[i];</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;ExecuteCommandLists(<span class="keyword">static_cast&lt;</span>Uint32<span class="keyword">&gt;</span>(m_CmdListPtrs.size()), m_CmdListPtrs.data());</div>
</div><!-- fragment --><p>Finally, it tells the worker threads to proceed to the next frame:</p>
<div class="fragment"><div class="line">m_NumThreadsReady.store(0);</div>
<div class="line">m_GotoNextFrameSignal.Trigger(<span class="keyword">true</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md312"></a>
Worker Threads</h3>
<p>Every worker thread starts by waiting for the signal from the main thread (a negative value is an exit signal):</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> SignaledValue = pThis-&gt;m_RenderSubsetSignal.Wait(<span class="keyword">true</span>, pThis-&gt;m_NumWorkerThreads);</div>
<div class="line"><span class="keywordflow">if</span> (SignaledValue &lt; 0)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
</div><!-- fragment --><p>The thread then renders the allotted subset using its own deferred context:</p>
<div class="fragment"><div class="line">IDeviceContext* pDeferredCtx = pThis-&gt;m_pDeferredContexts[ThreadNum];</div>
<div class="line">pThis-&gt;RenderSubset(pDeferredCtx, 1+ThreadNum);</div>
</div><!-- fragment --><p>When all commands are recorded, a command list is requested from the deferred context that is later executed by the main thread:</p>
<div class="fragment"><div class="line">RefCntAutoPtr&lt;ICommandList&gt; pCmdList;</div>
<div class="line">pDeferredCtx-&gt;FinishCommandList(&amp;pCmdList);</div>
<div class="line">pThis-&gt;m_CmdLists[ThreadNum] = pCmdList;</div>
</div><!-- fragment --><p>When all threads are done recording the commands, the last thread signals the main thread that it can start executing the command lists. The threads then wait for the signal from the main thread to proceed to the next frame. After the signal is received, every thread calls FinishFrame() to release all dynamic resources allocated by its deferred context. This must be done after the command lists have been submitted for execution.</p>
<div class="fragment"><div class="line">pThis-&gt;m_GotoNextFrameSignal.Wait(<span class="keyword">true</span>, pThis-&gt;m_NumWorkerThreads);</div>
<div class="line"> </div>
<div class="line">pDeferredCtx-&gt;FinishFrame();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md313"></a>
Rendering Subsets</h3>
<p>Subset rendering procedure is generally the same as in previous tutorials. Few details are worth mentioning.</p><ol type="1">
<li>Deferred contexts start in default state (no render target, viewports, pipeline state etc. are bound), so every context should set the default render target:</li>
</ol>
<div class="fragment"><div class="line">ITextureView* pRTV = m_pSwapChain-&gt;GetCurrentBackBufferRTV();</div>
<div class="line">ITextureView* pDSV = m_pSwapChain-&gt;GetDepthBufferDSV();</div>
<div class="line">pCtx-&gt;SetRenderTargets(1, &amp;pRTV, pDSV, RESOURCE_STATE_TRANSITION_MODE_VERIFY);</div>
</div><!-- fragment --><p>Note that render targets are set and transitioned to correct states by the main thread, so we use <code>RESOURCE_STATE_TRANSITION_MODE_VERIFY</code> flag to double-check the states are correct.</p>
<ol type="1">
<li>The rendering procedure iterates through all the instances in the allotted subset, and for every instance does the following:</li>
</ol>
<ul>
<li>Commits SRB object corresponding to the texture index, no RESOURCE_STATE_TRANSITION_MODE_TRANSITION is specified since we already transitioned all resources to correct states.</li>
<li>Updates the constant buffer with the transformation matrix for this instance</li>
<li>Issues the draw call</li>
</ul>
<div class="fragment"><div class="line">DrawIndexedAttribs DrawAttrs;</div>
<div class="line">DrawAttrs.<a class="code hl_variable" href="../../d2/dce/structDiligent_1_1DrawIndexedAttribs.html#ac726f684a259d8f04d5136a7499843ba">IndexType</a>  = VT_UINT32;</div>
<div class="line">DrawAttrs.NumIndices = 36;</div>
<div class="line">DrawAttrs.Flags      = DRAW_FLAG_VERIFY_ALL;</div>
<div class="line"> </div>
<div class="line">pCtx-&gt;SetPipelineState(m_pPSO);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> inst = StartInst; inst &lt; EndInst; ++inst)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> InstanceData&amp; CurrInstData = m_Instances[inst];</div>
<div class="line">    <span class="comment">// Shader resources have been explicitly transitioned to correct states, so</span></div>
<div class="line">    <span class="comment">// RESOURCE_STATE_TRANSITION_MODE_TRANSITION mode is not needed.</span></div>
<div class="line">    <span class="comment">// Instead, we use RESOURCE_STATE_TRANSITION_MODE_VERIFY mode to</span></div>
<div class="line">    <span class="comment">// verify that all resources are in correct states. This mode only has effect</span></div>
<div class="line">    <span class="comment">// in debug and development builds</span></div>
<div class="line">    pCtx-&gt;CommitShaderResources(m_SRB[CurrInstData.TextureInd], RESOURCE_STATE_TRANSITION_MODE_VERIFY);</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        MapHelper&lt;float4x4&gt; InstData(pCtx, m_InstanceConstants, MAP_WRITE, MAP_FLAG_DISCARD);</div>
<div class="line">        *InstData = transposeMatrix(CurrInstData.Matrix);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    pCtx-&gt;DrawIndexed(DrawAttrs);</div>
<div class="line">}</div>
<div class="ttc" id="astructDiligent_1_1DrawIndexedAttribs_html_ac726f684a259d8f04d5136a7499843ba"><div class="ttname"><a href="../../d2/dce/structDiligent_1_1DrawIndexedAttribs.html#ac726f684a259d8f04d5136a7499843ba">Diligent::DrawIndexedAttribs::IndexType</a></div><div class="ttdeci">VALUE_TYPE IndexType</div><div class="ttdoc">The type of elements in the index buffer.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:323</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
