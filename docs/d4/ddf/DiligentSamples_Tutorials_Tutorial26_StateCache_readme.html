<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial26 - Render State Cache</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/ddf/DiligentSamples_Tutorials_Tutorial26_StateCache_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial26 - Render State Cache</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial expands the path tracing technique implemented in previous tutorial and demonstrates how to use the render state cache to save pipeline states created at run time and load them when the application starts.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial26_StateCache/Screenshot.jpg" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial26_StateCache/Tutorial26_StateCache.html">â–¶ Run in the browser</a></p>
<p><a href="https://github.com/DiligentGraphics/DiligentSamples/tree/master/Tutorials/Tutorial25_StatePackager">Tutorial 25</a> shows how to package pipeline states off-line during the build process. This tutorial demonstrates an alternative approach, where pipeline states are created at run time, but when the application exits, they are saved to a file and loaded when the application starts next time. It also demonstrates a very useful feature of the render state cache: hot shader reload.</p>
<h2><a class="anchor" id="autotoc_md451"></a>
Render State Cache</h2>
<p>Render state cache object (<code>IRenderStateCache</code>) provides methods to create shaders and pipeline states that are identical to the methods of the render device. However, for each call the cache attempts to find the object data (e.g. compiled shader bytecode, pipeline state data etc.) to avoid expensive operation (such as shader compilation). If the data is not found, the object is created and its data is added to the cache. The cache data can be requested from the cache, stored in a file and loaded next time.</p>
<p>Another major feature that the state cache implements is hot shader reloading. The cache stores all data required to create shader objects, and when <code>Reload</code> method is called, the cache automatically detects which shaders need to be recompiled and which pipeline states need to be updated. The pipelines are updated transparently for the application.</p>
<p>To create a render state cache object, prepare an instance of the <code>RenderStateCacheCreateInfo</code> struct:</p>
<div class="fragment"><div class="line">RenderStateCacheCreateInfo CacheCI;</div>
<div class="line">CacheCI.<a class="code hl_variable" href="../../d6/d78/structDiligent_1_1RenderStateCacheCreateInfo.html#a6917d35b8934456f683c794a80d431e2">pDevice</a> = m_pDevice;</div>
<div class="line"><span class="comment">// Enable hot state reload</span></div>
<div class="line">CacheCI.EnableHotReload = <span class="keyword">true</span>;</div>
<div class="line">CreateRenderStateCache(CacheCI, &amp;m_pStateCache);</div>
<div class="ttc" id="astructDiligent_1_1RenderStateCacheCreateInfo_html_a6917d35b8934456f683c794a80d431e2"><div class="ttname"><a href="../../d6/d78/structDiligent_1_1RenderStateCacheCreateInfo.html#a6917d35b8934456f683c794a80d431e2">Diligent::RenderStateCacheCreateInfo::pDevice</a></div><div class="ttdeci">IRenderDevice * pDevice</div><div class="ttdoc">A pointer to the render device, must not be null.</div><div class="ttdef"><b>Definition</b> RenderStateCache.h:57</div></div>
</div><!-- fragment --><p>In this tutorial, we want to enable hot shader reloading, so we set the <code>EnableHotReload</code> member to <code>true</code>. Hot reloading intoduces some overhead and applications should generally disable this feature in production builds.</p>
<p>Render state cache also allows using separate shader source stream factory specifically for reloading, which can be specified through the <code>pReloadSource</code> member. In this example, we don't use this though.</p>
<p>At the next step, we check if the cache data from the previous application run exists and load it. We start by constructing the cache file path name. We use the <code>FileSystem::GetLocalAppDataDirectory</code> function that returns the platform-specific application data directory. If the directory does not exist, we create it:</p>
<div class="fragment"><div class="line">m_StateCachePath = FileSystem::GetLocalAppDataDirectory(<span class="stringliteral">&quot;DiligentEngine-Tutorial26&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!FileSystem::PathExists(m_StateCachePath.c_str()))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create the directory if it does not exist</span></div>
<div class="line">    FileSystem::CreateDirectory(m_StateCachePath.c_str());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we append the file name to the path. We use different file names for each device type and configuration type. This is not required as a single cache file can hold all data, but splitting it into multiple files is more convenient.</p>
<div class="fragment"><div class="line">m_StateCachePath.push_back(FileSystem::SlashSymbol);</div>
<div class="line">m_StateCachePath += <span class="stringliteral">&quot;state_cache_&quot;</span>;</div>
<div class="line">m_StateCachePath += GetRenderDeviceTypeShortString(m_pDevice-&gt;GetDeviceInfo().Type);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef DILIGENT_DEBUG</span></div>
<div class="line">m_StateCachePath += <span class="stringliteral">&quot;_d&quot;</span>;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">m_StateCachePath += <span class="stringliteral">&quot;_r&quot;</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">m_StateCachePath += <span class="stringliteral">&quot;.bin&quot;</span>;</div>
</div><!-- fragment --><p>Finally, we load the data into the cache, if it exists:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (FileSystem::FileExists(m_StateCachePath.c_str()))</div>
<div class="line">{</div>
<div class="line">    FileWrapper                 CacheDataFile{m_StateCachePath.c_str()};</div>
<div class="line">    RefCntAutoPtr&lt;DataBlobImpl&gt; pCacheData = DataBlobImpl::Create();</div>
<div class="line">    <span class="keywordflow">if</span> (CacheDataFile-&gt;Read(pCacheData))</div>
<div class="line">    {</div>
<div class="line">        m_pStateCache-&gt;Load(pCacheData);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Before the application exits, we request the data from the cache and store it to the file:</p>
<div class="fragment"><div class="line">RefCntAutoPtr&lt;IDataBlob&gt; pCacheData;</div>
<div class="line">m_pStateCache-&gt;WriteToBlob(&amp;pCacheData);</div>
<div class="line">FileWrapper CacheDataFile{m_StateCachePath.c_str(), EFileAccessMode::Overwrite};</div>
<div class="line">CacheDataFile-&gt;Write(pCacheData-&gt;GetConstDataPtr(), pCacheData-&gt;GetSize());</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md452"></a>
Render State Notation Parser</h2>
<p>Second object that we need in this example is the render state notation parser, which loads the <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Render State Notation files:</p>
<div class="fragment"><div class="line">RenderStateNotationParserCreateInfo ParserCI;</div>
<div class="line"><span class="comment">// Enable state reloading in the parser</span></div>
<div class="line">ParserCI.<a class="code hl_variable" href="../../d8/d5c/structDiligent_1_1RenderStateNotationParserCreateInfo.html#af4ae8445c8a22064a7e084de752ecfaa">EnableReload</a> = <span class="keyword">true</span>;</div>
<div class="line">CreateRenderStateNotationParser(ParserCI, &amp;m_pRSNParser);</div>
<div class="ttc" id="astructDiligent_1_1RenderStateNotationParserCreateInfo_html_af4ae8445c8a22064a7e084de752ecfaa"><div class="ttname"><a href="../../d8/d5c/structDiligent_1_1RenderStateNotationParserCreateInfo.html#af4ae8445c8a22064a7e084de752ecfaa">Diligent::RenderStateNotationParserCreateInfo::EnableReload</a></div><div class="ttdeci">bool EnableReload</div><div class="ttdoc">Whether to enable state reloading with IRenderStateNotationParser::Reload() method.</div><div class="ttdef"><b>Definition</b> RenderStateNotationParser.h:377</div></div>
</div><!-- fragment --><p>Note that we also need to enable hot shader reloading in the parser. Next, we load the DRSN file that describes pipeline states used in this tutorial:</p>
<div class="fragment"><div class="line">m_pRSNParser-&gt;ParseFile(<span class="stringliteral">&quot;RenderStates.json&quot;</span>, pShaderSourceFactory);</div>
</div><!-- fragment --><p>Notice that in the previous tutorial we used the same file, but passed it over to the off-line packager tool. This time we load it at run time.</p>
<h2><a class="anchor" id="autotoc_md453"></a>
Render State Notation Loader</h2>
<p>The state notation parser only loads the DRSN files, but does not create the actual objects. This task is performed by the render state notation loader that combines the render state cache and the state notation parser:</p>
<div class="fragment"><div class="line">RenderStateNotationLoaderCreateInfo LoaderCI;</div>
<div class="line">LoaderCI.<a class="code hl_variable" href="../../d5/d66/structDiligent_1_1RenderStateNotationLoaderCreateInfo.html#a40ae55deb4b83e8cd0728771466eebb5">pDevice</a>        = m_pDevice;</div>
<div class="line">LoaderCI.pParser        = m_pRSNParser;</div>
<div class="line">LoaderCI.pStateCache    = m_pStateCache;</div>
<div class="line">LoaderCI.pStreamFactory = pShaderSourceFactory;</div>
<div class="line">CreateRenderStateNotationLoader(LoaderCI, &amp;m_pRSNLoader);</div>
<div class="ttc" id="astructDiligent_1_1RenderStateNotationLoaderCreateInfo_html_a40ae55deb4b83e8cd0728771466eebb5"><div class="ttname"><a href="../../d5/d66/structDiligent_1_1RenderStateNotationLoaderCreateInfo.html#a40ae55deb4b83e8cd0728771466eebb5">Diligent::RenderStateNotationLoaderCreateInfo::pDevice</a></div><div class="ttdeci">IRenderDevice * pDevice</div><div class="ttdoc">A pointer to the render device that will be used to create objects.</div><div class="ttdef"><b>Definition</b> RenderStateNotationLoader.h:45</div></div>
</div><!-- fragment --><p>Creating pipeline states is very similar to how it is done in the previous tutorial except that now we use the loader instead of the dearchiver. The loader uses a very similar API, e.g.:</p>
<div class="fragment"><div class="line">LoadPipelineStateInfo LoadInfo;</div>
<div class="line">LoadInfo.<a class="code hl_variable" href="../../de/da4/structDiligent_1_1LoadPipelineStateInfo.html#ac55db7f3573fe6b720b15e5c9309e944">PipelineType</a> = PIPELINE_TYPE_GRAPHICS;</div>
<div class="line">LoadInfo.Name         = <span class="stringliteral">&quot;Resolve PSO&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define the callback to set the render target and depth stencil formats.</span></div>
<div class="line"><span class="comment">// These formats are only known at run time, so we can&#39;t define them in the</span></div>
<div class="line"><span class="comment">// render state notation file.</span></div>
<div class="line"><span class="keyword">auto</span> ModifyResolvePSODesc = MakeCallback(</div>
<div class="line">    [<span class="keyword">this</span>](PipelineStateCreateInfo&amp; PSODesc) {</div>
<div class="line">        <span class="comment">// Similar to Tutorial 25</span></div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">LoadInfo.ModifyPipeline      = ModifyResolvePSODesc;</div>
<div class="line">LoadInfo.pModifyPipelineData = ModifyResolvePSODesc;</div>
<div class="line">m_pRSNLoader-&gt;LoadPipelineState(LoadInfo, &amp;m_pResolvePSO);</div>
<div class="ttc" id="astructDiligent_1_1LoadPipelineStateInfo_html_ac55db7f3573fe6b720b15e5c9309e944"><div class="ttname"><a href="../../de/da4/structDiligent_1_1LoadPipelineStateInfo.html#ac55db7f3573fe6b720b15e5c9309e944">Diligent::LoadPipelineStateInfo::PipelineType</a></div><div class="ttdeci">PIPELINE_TYPE PipelineType</div><div class="ttdoc">The type of the pipeline state to load, see Diligent::PIPELINE_TYPE.</div><div class="ttdef"><b>Definition</b> RenderStateNotationLoader.h:161</div></div>
</div><!-- fragment --><p>The loader transparently for the application uses the cache to create the state objects.</p>
<p>Shader create information can also be modified, e.g.:</p>
<div class="fragment"><div class="line">ShaderMacroHelper Macros;</div>
<div class="line">Macros.AddShaderMacro(<span class="stringliteral">&quot;BRDF_SAMPLING_MODE_COS_WEIGHTED&quot;</span>, BRDF_SAMPLING_MODE_COS_WEIGHTED);</div>
<div class="line">Macros.AddShaderMacro(<span class="stringliteral">&quot;BRDF_SAMPLING_MODE_IMPORTANCE_SAMPLING&quot;</span>, BRDF_SAMPLING_MODE_IMPORTANCE_SAMPLING);</div>
<div class="line">Macros.AddShaderMacro(<span class="stringliteral">&quot;BRDF_SAMPLING_MODE&quot;</span>, m_BRDFSamplingMode);</div>
<div class="line"><span class="comment">// Add more macros</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> ModifyShaderCI = MakeCallback(</div>
<div class="line">    [&amp;](ShaderCreateInfo&amp; ShaderCI, SHADER_TYPE Type, <span class="keywordtype">bool</span>&amp; AddToLoaderCache) {</div>
<div class="line">        <span class="keywordflow">if</span> (Type == SHADER_TYPE_PIXEL)</div>
<div class="line">        {</div>
<div class="line">            ShaderCI.Macros = Macros;</div>
<div class="line">            <span class="comment">// Do not add the shader to the loader&#39;s cache as</span></div>
<div class="line">            <span class="comment">// we may be recreating the shader at run-time.</span></div>
<div class="line">            AddToLoaderCache = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">LoadPipelineStateInfo LoadInfo;</div>
<div class="line">LoadInfo.<a class="code hl_variable" href="../../de/da4/structDiligent_1_1LoadPipelineStateInfo.html#acb7a36e5ce5327808683e1963e5f7981">ModifyShader</a>      = ModifyShaderCI;</div>
<div class="line">LoadInfo.pModifyShaderData = ModifyShaderCI;</div>
<div class="line">LoadInfo.PipelineType      = PIPELINE_TYPE_GRAPHICS;</div>
<div class="line">LoadInfo.Name              = <span class="stringliteral">&quot;Path Trace PSO&quot;</span>;</div>
<div class="line"><span class="comment">// Do not use the loader&#39;s cache as we may be recreating the pipeline.</span></div>
<div class="line">LoadInfo.AddToCache    = <span class="keyword">false</span>;</div>
<div class="line">LoadInfo.LookupInCache = <span class="keyword">false</span>;</div>
<div class="line">m_pPathTracePSO.Release();</div>
<div class="line">m_pRSNLoader-&gt;LoadPipelineState(LoadInfo, &amp;m_pPathTracePSO);</div>
<div class="ttc" id="astructDiligent_1_1LoadPipelineStateInfo_html_acb7a36e5ce5327808683e1963e5f7981"><div class="ttname"><a href="../../de/da4/structDiligent_1_1LoadPipelineStateInfo.html#acb7a36e5ce5327808683e1963e5f7981">Diligent::LoadPipelineStateInfo::ModifyShader</a></div><div class="ttdeci">void(* ModifyShader)(ShaderCreateInfo &amp;, SHADER_TYPE, bool &amp;, void *)</div><div class="ttdef"><b>Definition</b> RenderStateNotationLoader.h:225</div></div>
</div><!-- fragment --><p>The loader has its own cache that holds objects previously created by the application and uses the object name as the key. In this example we recompile the path tracing pipeline at run time when some of the settings change. Since the pipelines use the same name, we don't want to use the cache, so we set <code>LoadInfo.AddToCache = false</code> and <code>LoadInfo.LookupInCache = false</code>. Note that the pipeline is always added to the render state cache, but unlike the loader, the cache can keep different pipeline states with the same name as it uses the full pipeline state description as the key.</p>
<p>Hot reloading as easy as calling</p>
<div class="fragment"><div class="line">m_pStateCache-&gt;Reload();</div>
</div><!-- fragment --><p>Try modifying shaders and pressing the Reload button in the UI - the effect will be immediate. All new shader variation will be added to the cache. An application may need to delete the cache if it contains a lot of intermediate states.</p>
<p>Note that there are some limitations to reloading functionality:</p>
<ul>
<li>Shader resources should not be modified as this will result in changing the shader resource layout, which will make existing shader resource binding objects incompatible with pipelines.</li>
<li>Pipeline resource layout and shader resource signatures can't be modified.</li>
<li>While shaders can be changed, a shader can't be replaced with another one in pipeline state description in a DRSN file</li>
</ul>
<p>After pipeline states are loaded, they are used the same way as in the previous Tutorial.</p>
<h2><a class="anchor" id="autotoc_md454"></a>
Path Tracing Improvements</h2>
<p>Path tracing technique in this tutorial extends the method from Tutorial 25 and implements a number of major improvements:</p>
<ul>
<li>Smith-GGX BRDF with metallic-roughness parameterization</li>
<li>Reflective (mirror) and refractive (glass) materials</li>
<li>Importance sampling of the BRDF using the GGX distribution of visible normals</li>
<li>Multiple importance sampling with balance heuristics</li>
</ul>
<p>Please refer to the <a href="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial26_StateCache/assets/path_trace.psh">shader source code</a> for more details.</p>
<h2><a class="anchor" id="autotoc_md455"></a>
Controlling the Application</h2>
<ul>
<li><em>Move camera</em>: left mouse button + WSADQE</li>
<li><em>Move light</em>: right mouse button</li>
</ul>
<p>UI controls:</p>
<ul>
<li><em>Num bounces</em> - the number of bounces in each path</li>
<li><em>Show only last bounce</em> - render only the last bounce in the path</li>
<li><em>Next Event Estimation</em> - whether to perform the next event estimation at each bounce</li>
<li><em>BRDF Sampling mode</em>:<ul>
<li><em>Cosine-weighted</em>: use basic cosine-weighted hemispherical distribution</li>
<li><em>Importance sampling</em>: use Smith-GGX importance sampling</li>
</ul>
</li>
<li><em>NEE mode</em>:<ul>
<li><em>Sample Light</em>: use light source sampling</li>
<li><em>Sample BRDF</em>: use BRDF sampling</li>
<li><em>MIS</em>: use multiple importance sampling</li>
<li><em>MIS - Light part</em>: use light sampling component of the multiple importance sampling</li>
<li><em>MIS - BRDF part</em>: use BRDF sampling component of the multiple importance sampling</li>
</ul>
</li>
<li><em>Balance Heuristics Power</em>: the exponent used in the MIS balance heuristics</li>
<li><em>Full BRDF Reflectance term</em>: use full equation (<code>BRDF * (n, w) / p(w)</code>) for the reflectance term. This option is intended for debugging purposes.</li>
<li><em>Samples per frame</em> - the number of light paths to take each frame for each pixel</li>
<li><em>Limit Sample Count</em>: whether to limit the total number of samples by the specific value</li>
<li><em>Reload States</em>: hot-reload modified shaders</li>
<li><em>Delete Cache File</em>: delete saved cached file</li>
</ul>
<h2><a class="anchor" id="autotoc_md456"></a>
Resources</h2>
<ol type="1">
<li><a href="https://cseweb.ucsd.edu/~viscomp/classes/cse168/sp21/readings/veach.pdf">Optimally Combining Sampling Techniques for Monte Carlo Rendering</a> (1995) by Eric Veach and Leonidas J. Guibas</li>
<li><a href="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">Microfacet Models for Refraction through Rough Surfaces</a> (2007) by Bruce Walter et. al.</li>
<li><a href="https://jcgt.org/published/0003/02/03/">Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs</a> (2014) by Eric Heitz</li>
<li><a href="https://ubm-twvideo01.s3.amazonaws.com/o1/vault/gdc2017/Presentations/Hammon_Earl_PBR_Diffuse_Lighting.pdf">PBR Diffuse Lighting for GGX+Smith Microsurfaces</a> (2017) by Earl Hammon, Jr.</li>
<li><a href="https://hal.archives-ouvertes.fr/hal-01509746/document">A Simpler and Exact Sampling Routine for the GGX Distribution of Visible Normals</a> (2017) by Eric Heitz</li>
<li><a href="https://jcgt.org/published/0007/04/01/">Sampling the GGX Distribution of Visible Normals</a> (2018) by Eric Heitz</li>
<li><a href="https://schuttejoe.github.io/post/ggximportancesamplingpart2/">Importance Sampling techniques for GGX with Smith Masking-Shadowing</a> (2018) by Joe Schutte </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
