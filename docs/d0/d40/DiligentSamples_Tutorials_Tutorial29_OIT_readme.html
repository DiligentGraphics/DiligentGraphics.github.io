<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial29 - Order-Independent Transparency</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/d40/DiligentSamples_Tutorials_Tutorial29_OIT_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial29 - Order-Independent Transparency</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates how to implement order-independent transparency (OIT) methods to render transparent objects without sorting.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial29_OIT/Screenshot.jpg" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial29_OIT/Tutorial29_OIT.html">â–¶ Run in the browser</a></p>
<h1><a class="anchor" id="autotoc_md471"></a>
Introduction</h1>
<p>Transparent objects have long posed a challenge in computer graphics because the order in which they are rendered affects the final image. This is due to the non-commutative nature of the blending operation - i.e., the order in which transparent surfaces are composited over each other matters. Sorting objects by their depth is only a partial solution because in many cases there is no single correct order that works for all pixels (for example, when transparent objects intersect, for self-overlapping transparent objects with complex geometry, or for nested objects). This is where order-independent transparency (OIT) comes in. OIT methods allow transparent objects to be rendered in any order without producing visual artifacts. This tutorial shows how to implement OIT in <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine.</p>
<h1><a class="anchor" id="autotoc_md472"></a>
Algorithms</h1>
<p>This tutorial demonstrates three different approaches to rendering transparent objects:</p>
<ol type="1">
<li>Unsorted alpha-blending</li>
<li>Weighted-blended OIT</li>
<li>Layered OIT</li>
</ol>
<h2><a class="anchor" id="autotoc_md473"></a>
Unsorted alpha-blending</h2>
<p>This is the simplest approach. It is used here to illustrate the kind of visual artifacts that appear when rendering transparent objects without sorting.</p>
<h2><a class="anchor" id="autotoc_md474"></a>
Weighted-blended OIT</h2>
<p><a href="https://casual-effects.blogspot.com/2015/03/implemented-weighted-blended-order.html">Weighted-blended OIT</a> assigns weights to each transparent surface based on its depth and transparency, giving higher weights to surfaces closer to the camera and more opaque. This method is easy to implement and very efficient, but because it is an approximation, it has limitations:</p>
<ol type="1">
<li>The weighting functions often need tweaking on a per-scene basis to achieve the best results.</li>
<li>The method does not work well for surfaces with high opacity.</li>
</ol>
<h2><a class="anchor" id="autotoc_md475"></a>
Layered OIT</h2>
<p>This approach is based on the method of <a href="https://dl.acm.org/doi/10.1145/1730804.1730817">Fang Liu et al.</a>. However, instead of storing the individual fragments, the algorithm builds a transmittance function that allows the transparent objects to be rendered in any order with additive blending.</p>
<p>Consider three surfaces A, B, and C that are composited on top of each other in that order. The final color is given by:</p>
<div class="fragment"><div class="line">RGB = (RGB_A * T_B  + RGB_B) * T_C + RGB_C = RGB_A * T_B * T_C + RGB_B * T_C + RGB_C</div>
</div><!-- fragment --><p>where <code>RGB_A</code>, <code>RGB_B</code>, and <code>RGB_C</code> are the (alpha-premultiplied) colors of the surfaces, and <code>T_B</code> and <code>T_C</code> are the transmittance functions of the surfaces. The transmittance function is the fraction of light that passes through a given surface.</p>
<p>We can rewrite this more generally as:</p>
<div class="fragment"><div class="line">RGB = RGB_A * Tc(A)  + RGB_B * Tc(B) + RGB_C * Tc(C)</div>
</div><!-- fragment --><p>where <code>Tc(X)</code> is the <em>cumulative</em> transmittance function from the camera to the surface <code>X</code>. This cumulative transmittance is the product of the transmittances of all surfaces between the camera and <code>X</code>. If we know the transmittance function for each pixel, we can render the transparent objects in any order using additive blending.</p>
<h3><a class="anchor" id="autotoc_md476"></a>
The transmittance function</h3>
<p>In our implementation, the transmittance function is represented by up to <code>K</code> closest layers, each storing that layer's transmittance and depth. Any additional layers are merged into a tail, which contains the total number of merged layers and the total transmittance. Each layer is packed into a 32-bit integer where the top 24 bits store the depth and the bottom 8 bits store the transmittance. This design allows us to sort layers by depth using atomic operations. The following function packs the layer data into a 32-bit integer:</p>
<div class="fragment"><div class="line">uint PackOITLayer(float Depth, float Transmittance)</div>
<div class="line">{</div>
<div class="line">    uint D = uint(clamp(Depth, 0.0, 1.0) * 16777215.0);</div>
<div class="line">    uint T = uint(clamp(Transmittance, 0.0, 1.0) * 255.0);</div>
<div class="line">    return (D &lt;&lt; 8u) | T;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Layer data is stored in a structured buffer, and the tail is stored in an RGBA8 texture.</p>
<h3><a class="anchor" id="autotoc_md477"></a>
Implementation</h3>
<p>After rendering all opaque objects, the algorithm proceeds with the following steps (described in detail below):</p>
<ul>
<li>Clear the OIT layers buffer</li>
<li>Render transparent objects to build the transmittance function</li>
<li>Attenuate the background</li>
<li>Render transparent objects and composite them using the transmittance function</li>
</ul>
<h4><a class="anchor" id="autotoc_md478"></a>
Clearing the OIT layers buffer</h4>
<p>The layers buffer is cleared by a compute shader that sets the value of each element to <code>0xFFFFFFFF</code>, which indicates an empty layer.</p>
<h4><a class="anchor" id="autotoc_md479"></a>
Building the transmittance function</h4>
<p>The main challenge is designing an algorithm that merges layers in parallel, given that multiple surfaces covering the same pixel might be processed simultaneously in arbitrary order. We build upon the algorithm by Fang Liu et al. and use atomic operations. Recall that we pack the layer depth and transmittance into a 32-bit integer, making atomic min suitable for inserting a new layer into the buffer while keeping the buffer sorted by depth. To insert a new layer, the shader performs atomic min operation with all stored layers in order. If the operation succeeds, the new layer is inserted into the buffer, and atomic operation returns the previous value, which in turn needs to be inserted into the buffer or merged into the tail.</p>
<p>Below is the key part of the pixel shader:</p>
<div class="fragment"><div class="line">RWStructuredBuffer&lt;uint&gt; g_rwOITLayers;</div>
<div class="line"> </div>
<div class="line">// By default, early depth stencil will be disabled for this shader because it writes to a UAV.</div>
<div class="line">// Force it to be enabled.</div>
<div class="line">[earlydepthstencil]</div>
<div class="line">float4 main(in PSInput PSIn) : SV_Target</div>
<div class="line">{</div>
<div class="line">    float D = PSIn.Pos.z;</div>
<div class="line">    float A = lerp(g_Constants.MinOpacity, g_Constants.MaxOpacity, PSIn.Color.a);</div>
<div class="line">    uint Layer = 0xFFFFFFFFu;</div>
<div class="line">    if (A &gt; OPACITY_THRESHOLD)</div>
<div class="line">    {</div>
<div class="line">        float T = 1.0 - A;</div>
<div class="line">        Layer = PackOITLayer(D, T);</div>
<div class="line">        uint Offset = GetOITLayerDataOffset(uint2(PSIn.Pos.xy), g_Constants.ScreenSize);</div>
<div class="line">        for (uint i = 0; i &lt; uint(NUM_OIT_LAYERS); ++i)</div>
<div class="line">        {</div>
<div class="line">            uint OrigLayer;</div>
<div class="line">            InterlockedMin(g_rwOITLayers[Offset + i], Layer, OrigLayer);</div>
<div class="line">            if (OrigLayer == 0xFFFFFFFFu || // Empty space</div>
<div class="line">                OrigLayer == Layer)         // Layer matches another one exactly</div>
<div class="line">            {</div>
<div class="line">                // Do not update tail transmittance</div>
<div class="line">                Layer = 0xFFFFFFFFu;</div>
<div class="line">                break;</div>
<div class="line">            }</div>
<div class="line">            // Layer &gt; OrigLayer: we did not insert the layer</div>
<div class="line">            // Layer &lt; OrigLayer: we inserted the layer, so now we need to </div>
<div class="line">            //                    insert the original layer</div>
<div class="line">            Layer = max(Layer, OrigLayer);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    // RGB Blend: Src * 1 + Dst * 1</div>
<div class="line">    // A   Blend: Src * 0 + Dst * SrcA</div>
<div class="line">    if (Layer == 0xFFFFFFFFu)</div>
<div class="line">    {</div>
<div class="line">        return float4(0.0, 0.0, 0.0, 1.0);</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">        float TailT = GetOITLayerTransmittance(Layer);</div>
<div class="line">        return float4(1.0 / 255.0, 0.0, 0.0, TailT);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The algorithm starts by obtaining the pixel depth value and the alpha value of the transparent object. Notice that alpha represents the object opacity, while we need the transmittance value which is <code>1 - A</code>. The opacity value is then compared with the opacity threshold that is set to <code>1.0/255.0</code>. Since we use 8 bits to store transmittance, any opacity below that corresponds to the fully transparent object and is discarded.</p>
<div class="fragment"><div class="line">float D = PSIn.Pos.z;</div>
<div class="line">float A = lerp(g_Constants.MinOpacity, g_Constants.MaxOpacity, PSIn.Color.a);</div>
<div class="line">uint Layer = 0xFFFFFFFFu;</div>
<div class="line">if (A &gt; OPACITY_THRESHOLD)</div>
<div class="line">{</div>
<div class="line">    float T = 1.0 - A;</div>
</div><!-- fragment --><p>The algorithm then packs the layer data and starts inserting it into the buffer:</p>
<div class="fragment"><div class="line">Layer = PackOITLayer(D, T);</div>
<div class="line">uint Offset = GetOITLayerDataOffset(uint2(PSIn.Pos.xy), g_Constants.ScreenSize);</div>
<div class="line">for (uint i = 0; i &lt; uint(NUM_OIT_LAYERS); ++i)</div>
<div class="line">{</div>
</div><!-- fragment --><p>For each layer, it performs atomic min operation in an attempt to insert the new layer. The operation returns the previous value stored in the buffer. Few outcomes are possible:</p>
<ul>
<li>Original value is <code>0xFFFFFFFF</code> - the layer is inserted into the empty space in the buffer. In this case, nothing else needs to be done.</li>
<li>Original value is equal to the new layer - this is a rare case where two layers at the same depth have the same transmittance. In this case, the new layer is discarded.</li>
<li>The two remaining cases is either the layer was successfully inserted and <code>OrigLayer</code> contains another value larger than the new layer, or the layer was not inserted and <code>OrigLayer</code> contains a value smaller that the new layer. In both cases, the algorithm needs to insert the maximum of the two values into the next position in the buffer.</li>
</ul>
<div class="fragment"><div class="line">for (uint i = 0; i &lt; uint(NUM_OIT_LAYERS); ++i)</div>
<div class="line">{</div>
<div class="line">    uint OrigLayer;</div>
<div class="line">    InterlockedMin(g_rwOITLayers[Offset + i], Layer, OrigLayer);</div>
<div class="line">    if (OrigLayer == 0xFFFFFFFFu || OrigLayer == Layer)</div>
<div class="line">    {</div>
<div class="line">        Layer = 0xFFFFFFFFu;</div>
<div class="line">        break;</div>
<div class="line">    }</div>
<div class="line">    Layer = max(Layer, OrigLayer);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Let's take a look at the following example. Suppose we have the following values in the buffer: <code>10</code>, <code>20</code>, <code>30</code>, and we want to insert the value <code>15</code>. The algorithm will perform the following steps:</p>
<ol type="1">
<li>Attempt to insert <code>15</code> into the first position. Since <code>10 &lt; 15</code>, the buffer is not updated. <code>OrigLayer = 10</code>, <code>Layer = max(15, 10) = 15</code></li>
<li>Attempt to insert <code>15</code> into the second position. Since <code>15 &lt; 20</code>, the buffer is updated. <code>OrigLayer = 20</code>, <code>Layer = max(15, 20) = 20</code>. Buffer now contains <code>10</code>, <code>15</code>, <code>30</code></li>
<li>Attempt to insert <code>20</code> into the third position. Since <code>20 &lt; 30</code>, the buffer is updated. <code>OrigLayer = 30</code>, <code>Layer = max(20, 30) = 30</code>. Buffer now contains <code>10</code>, <code>15</code>, <code>20</code>, and we left with the value <code>30</code> that needs to be inserted into the tail.</li>
</ol>
<p>Note that multiple shader invocations can attempt to insert different layers into the same place in the buffer. In general, the buffer contents may change between each loop iteration. However, the following considerations ensure that the insertion algorithm works correctly:</p>
<ol type="1">
<li>Values in the buffer may only decrease. If an algorithm is attempting to insert a value at position <code>i</code>, it may only be inserted at position <code>i</code> or later, no matter what other invocations are doing.</li>
<li>Each invocation guarantees that value at position <code>i</code> is larger than the value at position <code>i-1</code>. This ensures that the buffer is always sorted.</li>
</ol>
<p>After the loop finishes, there are two possible outcomes: either the layer was inserted into empty space in the buffer, in which case <code>Layer == 0xFFFFFFFFu</code>, or we are left with the value that needs to be inserted into the tail. The tail is updated using the alpha blending. We accumulate the total number of tail layers in the color channel, and the total transmittance in the alpha channel:</p>
<div class="fragment"><div class="line">// RGB Blend: Src * 1 + Dst * 1</div>
<div class="line">// A   Blend: Src * 0 + Dst * SrcA</div>
<div class="line">if (Layer == 0xFFFFFFFFu)</div>
<div class="line">{</div>
<div class="line">    return float4(0.0, 0.0, 0.0, 1.0);</div>
<div class="line">}</div>
<div class="line">else</div>
<div class="line">{</div>
<div class="line">    float TailT = GetOITLayerTransmittance(Layer);</div>
<div class="line">    return float4(1.0 / 255.0, 0.0, 0.0, TailT);</div>
<div class="line">}</div>
</div><!-- fragment --><p>An important property of this algorithm is that it is stable. The order in which transparent objects are rendered does not affect the final result. The <code>K</code> closest layers are stored in the buffer, and all other layers are merged into the tail. The tail blending operations are commutative, so the order in which they are composited does not matter.</p>
<p><b>Note</b>: The <code>earlydepthstencil</code> attribute is crucial because writing to a UAV normally disables early depth-stencil tests. We re-enable them to ensure opaque objects correctly occlude transparent ones behind them.</p>
<h4><a class="anchor" id="autotoc_md480"></a>
Attenuating the background</h4>
<p>Before rendering the transparent objects, we first attenuate the background based on the computed transmittance function. We draw a full-screen quad that multiplies the background color by the product of all transmittances:</p>
<div class="fragment"><div class="line">StructuredBuffer&lt;uint&gt; g_OITLayers;</div>
<div class="line">Texture2D&lt;float4&gt;      g_OITTail;</div>
<div class="line"> </div>
<div class="line">void main(in float4 Pos : SV_Position,</div>
<div class="line">          out PSOutput PSOut)</div>
<div class="line">{</div>
<div class="line">    uint Offset = GetOITLayerDataOffset(uint2(Pos.xy), g_Constants.ScreenSize);</div>
<div class="line">    float T = 1.0;</div>
<div class="line">    uint layer = 0u;</div>
<div class="line">    while (layer &lt; uint(NUM_OIT_LAYERS))</div>
<div class="line">    {</div>
<div class="line">        uint LayerDT = g_OITLayers[Offset + layer];</div>
<div class="line">        if (LayerDT == 0xFFFFFFFFu)</div>
<div class="line">            break;</div>
<div class="line">        T *= GetOITLayerTransmittance(LayerDT);</div>
<div class="line">        ++layer;</div>
<div class="line">    }</div>
<div class="line">    if (layer == uint(NUM_OIT_LAYERS))</div>
<div class="line">    {</div>
<div class="line">        float4 Tail = g_OITTail.Load(int3(Pos.xy, 0));</div>
<div class="line">        T *= Tail.a;</div>
<div class="line">    }</div>
<div class="line">    if (T == 1.0)</div>
<div class="line">        discard;</div>
<div class="line"> </div>
<div class="line">    // RGB blend: Src * 0 + Dst * SrcA</div>
<div class="line">    PSOut.Color = float4(0.0, 0.0, 0.0, T);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This shader iterates over all layers in the buffer to accumulate the total transmittance value. If the maximum number of layers has been reached, the tail's transmittance is taken from the alpha channel of the tail texture. If <code>T</code> is 1.0 (meaning the background is unchanged), we simply discard the pixel. Otherwise, alpha-blending scales the background color by <code>T</code>.</p>
<h4><a class="anchor" id="autotoc_md481"></a>
Compositing the transparent objects</h4>
<p>Finally, we render the transparent objects again, this time using the transmittance data to composite them correctly. The pixel shader computes how much light was transmitted from the current fragment by accumulating the transmittances of all layers closer to the camera:</p>
<div class="fragment"><div class="line">float Depth = PSIn.Pos.z;</div>
<div class="line">uint D = uint(Depth * 16777215.0);</div>
<div class="line">float T = 1.0;</div>
<div class="line">    </div>
<div class="line">uint Offset = GetOITLayerDataOffset(uint2(PSIn.Pos.xy), g_Constants.ScreenSize);</div>
<div class="line"> </div>
<div class="line">uint layer = 0u;</div>
<div class="line">while (layer &lt; uint(NUM_OIT_LAYERS))</div>
<div class="line">{</div>
<div class="line">    uint LayerDT = g_OITLayers[Offset + layer];</div>
<div class="line">    uint LayerD = GetOITLayerDepth(LayerDT);</div>
<div class="line">    // +1u helps to avoid precision issues.</div>
<div class="line">    if (D &lt;= LayerD + 1u)</div>
<div class="line">    {</div>
<div class="line">        break;</div>
<div class="line">    }</div>
<div class="line">    float LayerT = GetOITLayerTransmittance(LayerDT);</div>
<div class="line">    T *= LayerT;</div>
<div class="line">    ++layer;</div>
<div class="line">}</div>
<div class="line">if (layer == uint(NUM_OIT_LAYERS))</div>
<div class="line">{</div>
<div class="line">    float4 Tail = g_OITTail.Load(int3(PSIn.Pos.xy, 0));</div>
<div class="line">    // Average contribution of all tail layers.</div>
<div class="line">    T /= max(255.0 * Tail.x, 1.0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Color.rgb *= T;</div>
</div><!-- fragment --><p>Here, <code>T</code> accumulates the transmittances of all layers in front of the current fragment. If there are more than <code>K</code> layers, we take the average contribution from the tail. This ensures correct blending, even if many layers overlap.</p>
<h3><a class="anchor" id="autotoc_md482"></a>
API-specific notes</h3>
<ul>
<li><b>WebGPU</b>: Since WebGPU does not support the <code>earlydepthstencil</code> attribute, the depth test must be done manually in the pixel shader.</li>
<li><b>OpenGL</b>: OpenGL does not allow using the default framebuffer's depth buffer with any other render target, so we must perform additional copies.</li>
</ul>
<h1><a class="anchor" id="autotoc_md483"></a>
Discussion</h1>
<p>The layered OIT algorithm is both efficient and stable. It produces correct results when the number of overlapping transparent objects does not exceed the number of layers <code>K</code>. It also handles high-opacity objects (even fully opaque ones) correctly. For <code>K</code> layers, the algorithm requires <code>K * 4 + 4</code> bytes per pixel. For four layers, that amounts to 20 bytes. By adjusting <code>K</code>, you can balance memory usage and performance against image quality.</p>
<p>However, the algorithm is less efficient for large numbers of overlapping, highly transparent objects (e.g., smoke). In such cases, the weighted-blended OIT or <a href="https://momentsingraphics.de/I3D2018.html">moment-based OIT</a> may be more suitable.</p>
<h1><a class="anchor" id="autotoc_md484"></a>
References</h1>
<ul>
<li><a href="https://jcgt.org/published/0002/02/09/">Weighted Blended Order-Independent Transparency by Morgan McGuire and Louis Bavoil</a></li>
<li><a href="https://casual-effects.blogspot.com/2015/03/implemented-weighted-blended-order.html">Implementing Weighted, Blended Order-Independent Transparency by Morgan McGuire</a></li>
<li><a href="https://github.com/nvpro-samples/vk_order_independent_transparency">Order-Independent Transparency Vulkan Sample by NVidia</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/1730804.1730817">FreePipe: a programmable parallel rendering architecture for efficient multi-fragment effects by Fang Liu et al.</a></li>
<li><a href="https://momentsingraphics.de/I3D2018.html">Moment-Based Order-Independent Transparency by Cedrick Munstermann</a></li>
<li><a href="https://arxiv.org/abs/2201.00094">Wavelet Transparency by Maksim Aizenshtein</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
