<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: DiligentCore/Common/interface/ParsingTools.hpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d6a/ParsingTools_8hpp.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ParsingTools.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &quot;<a class="el" href="../../db/def/BasicTypes_8h.html">../../Primitives/interface/BasicTypes.h</a>&quot;</code><br />
<code>#include &quot;../../Primitives/interface/FlagEnum.h&quot;</code><br />
<code>#include &quot;../../Platforms/Basic/interface/DebugUtilities.hpp&quot;</code><br />
<code>#include &quot;StringTools.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dca/namespaceDiligent.html">Diligent</a></td></tr>
<tr class="memdesc:d7/dca/namespaceDiligent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graphics engine namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5852870f9be1ca3be27c3cd81775b103" id="r_a5852870f9be1ca3be27c3cd81775b103"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5852870f9be1ca3be27c3cd81775b103">Diligent::Parsing::SKIP_COMMENT_FLAGS</a> : Uint32 { <a class="el" href="#a5852870f9be1ca3be27c3cd81775b103ae590071458e55fce93b68d546aa29549">Diligent::Parsing::SKIP_COMMENT_FLAG_NONE</a> = 0u
, <a class="el" href="#a5852870f9be1ca3be27c3cd81775b103a932cd3bb9185e1c4f04194dfd2a7372c">Diligent::Parsing::SKIP_COMMENT_FLAG_SINGLE_LINE</a> = 1u &lt;&lt; 0u
, <a class="el" href="#a5852870f9be1ca3be27c3cd81775b103ae7ac9d7849e8fc934648f0e11d6271af">Diligent::Parsing::SKIP_COMMENT_FLAG_MULTILINE</a> = 1u &lt;&lt; 1u
, <a class="el" href="#a5852870f9be1ca3be27c3cd81775b103a72d5705eddb4728df616dfa5eb1ea8f0">Diligent::Parsing::SKIP_COMMENT_FLAG_ALL</a> = SKIP_COMMENT_FLAG_SINGLE_LINE | SKIP_COMMENT_FLAG_MULTILINE
 }</td></tr>
<tr class="memdesc:a5852870f9be1ca3be27c3cd81775b103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags controlling what kind of comments the SkipComment function should skip.  <a href="#a5852870f9be1ca3be27c3cd81775b103">More...</a><br /></td></tr>
<tr class="separator:a5852870f9be1ca3be27c3cd81775b103"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8758415038edcdb90d797010b5fc8722" id="r_a8758415038edcdb90d797010b5fc8722"><td class="memItemLeft" align="right" valign="top"><a id="a8758415038edcdb90d797010b5fc8722" name="a8758415038edcdb90d797010b5fc8722"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Diligent::Parsing::IsWhitespace</b> (Char Symbol) noexcept</td></tr>
<tr class="memdesc:a8758415038edcdb90d797010b5fc8722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the character is a white space or tab. <br /></td></tr>
<tr class="separator:a8758415038edcdb90d797010b5fc8722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925674fed67931b527189e76a168a162" id="r_a925674fed67931b527189e76a168a162"><td class="memItemLeft" align="right" valign="top"><a id="a925674fed67931b527189e76a168a162" name="a925674fed67931b527189e76a168a162"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Diligent::Parsing::IsNewLine</b> (Char Symbol) noexcept</td></tr>
<tr class="memdesc:a925674fed67931b527189e76a168a162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the character is a new line character. <br /></td></tr>
<tr class="separator:a925674fed67931b527189e76a168a162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8665edb3be31410218ad6c6353f90e72" id="r_a8665edb3be31410218ad6c6353f90e72"><td class="memItemLeft" align="right" valign="top"><a id="a8665edb3be31410218ad6c6353f90e72" name="a8665edb3be31410218ad6c6353f90e72"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Diligent::Parsing::IsDelimiter</b> (Char Symbol) noexcept</td></tr>
<tr class="memdesc:a8665edb3be31410218ad6c6353f90e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the character is a delimiter symbol (white space or new line) <br /></td></tr>
<tr class="separator:a8665edb3be31410218ad6c6353f90e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eb4f58b0628a5b98600628f125b014" id="r_a01eb4f58b0628a5b98600628f125b014"><td class="memItemLeft" align="right" valign="top"><a id="a01eb4f58b0628a5b98600628f125b014" name="a01eb4f58b0628a5b98600628f125b014"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Diligent::Parsing::IsStatementSeparator</b> (Char Symbol) noexcept</td></tr>
<tr class="memdesc:a01eb4f58b0628a5b98600628f125b014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the character is a statement separator symbol. <br /></td></tr>
<tr class="separator:a01eb4f58b0628a5b98600628f125b014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79515201b78f881055e85535b177146f" id="r_a79515201b78f881055e85535b177146f"><td class="memItemLeft" align="right" valign="top"><a id="a79515201b78f881055e85535b177146f" name="a79515201b78f881055e85535b177146f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Diligent::Parsing::IsDigit</b> (Char Symbol) noexcept</td></tr>
<tr class="memdesc:a79515201b78f881055e85535b177146f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the character is a digit between 0 and 9. <br /></td></tr>
<tr class="separator:a79515201b78f881055e85535b177146f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8238ec72e661b795b9e1a09d96267ecb" id="r_a8238ec72e661b795b9e1a09d96267ecb"><td class="memTemplParams" colspan="2">template&lt;typename InteratorType&gt; </td></tr>
<tr class="memitem:a8238ec72e661b795b9e1a09d96267ecb"><td class="memTemplItemLeft" align="right" valign="top">InteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8238ec72e661b795b9e1a09d96267ecb">Diligent::Parsing::SkipLine</a> (const InteratorType &amp;Start, const InteratorType &amp;End, bool GoToNextLine=false) noexcept</td></tr>
<tr class="memdesc:a8238ec72e661b795b9e1a09d96267ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips all characters until the end of the line.  <br /></td></tr>
<tr class="separator:a8238ec72e661b795b9e1a09d96267ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5e0a755b7c3fe7059afca1cd62c9b7" id="r_ada5e0a755b7c3fe7059afca1cd62c9b7"><td class="memTemplParams" colspan="2">template&lt;typename InteratorType&gt; </td></tr>
<tr class="memitem:ada5e0a755b7c3fe7059afca1cd62c9b7"><td class="memTemplItemLeft" align="right" valign="top">InteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada5e0a755b7c3fe7059afca1cd62c9b7">Diligent::Parsing::SkipComment</a> (const InteratorType &amp;Start, const InteratorType &amp;End, <a class="el" href="#a5852870f9be1ca3be27c3cd81775b103">SKIP_COMMENT_FLAGS</a> Flags=<a class="el" href="#a5852870f9be1ca3be27c3cd81775b103a72d5705eddb4728df616dfa5eb1ea8f0">SKIP_COMMENT_FLAG_ALL</a>) noexcept(false)</td></tr>
<tr class="memdesc:ada5e0a755b7c3fe7059afca1cd62c9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips single-line and multi-line comments starting from the given position.  <br /></td></tr>
<tr class="separator:ada5e0a755b7c3fe7059afca1cd62c9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef494eb616b4b27367eb645adc56ad2" id="r_abef494eb616b4b27367eb645adc56ad2"><td class="memTemplParams" colspan="2">template&lt;typename InteratorType&gt; </td></tr>
<tr class="memitem:abef494eb616b4b27367eb645adc56ad2"><td class="memTemplItemLeft" align="right" valign="top">InteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abef494eb616b4b27367eb645adc56ad2">Diligent::Parsing::SkipDelimiters</a> (const InteratorType &amp;Start, const InteratorType &amp;End, const char *Delimiters=nullptr) noexcept</td></tr>
<tr class="memdesc:abef494eb616b4b27367eb645adc56ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips all delimiters starting from the given position.  <br /></td></tr>
<tr class="separator:abef494eb616b4b27367eb645adc56ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e1ce3b683844a4a25dcb6234751ef4" id="r_ab7e1ce3b683844a4a25dcb6234751ef4"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType&gt; </td></tr>
<tr class="memitem:ab7e1ce3b683844a4a25dcb6234751ef4"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7e1ce3b683844a4a25dcb6234751ef4">Diligent::Parsing::SkipDelimitersAndComments</a> (const IteratorType &amp;Start, const IteratorType &amp;End, const char *Delimiters=nullptr, <a class="el" href="#a5852870f9be1ca3be27c3cd81775b103">SKIP_COMMENT_FLAGS</a> CommentFlags=<a class="el" href="#a5852870f9be1ca3be27c3cd81775b103a72d5705eddb4728df616dfa5eb1ea8f0">SKIP_COMMENT_FLAG_ALL</a>) noexcept(false)</td></tr>
<tr class="memdesc:ab7e1ce3b683844a4a25dcb6234751ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips all comments and all delimiters starting from the given position.  <br /></td></tr>
<tr class="separator:ab7e1ce3b683844a4a25dcb6234751ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed3c923a49cdf53f25369faad459d3e" id="r_a8ed3c923a49cdf53f25369faad459d3e"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType&gt; </td></tr>
<tr class="memitem:a8ed3c923a49cdf53f25369faad459d3e"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ed3c923a49cdf53f25369faad459d3e">Diligent::Parsing::SkipIdentifier</a> (const IteratorType &amp;Start, const IteratorType &amp;End) noexcept</td></tr>
<tr class="memdesc:a8ed3c923a49cdf53f25369faad459d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips one identifier starting from the given position.  <br /></td></tr>
<tr class="separator:a8ed3c923a49cdf53f25369faad459d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df6a4fb6c59548ebeda4b7a754a3c06" id="r_a2df6a4fb6c59548ebeda4b7a754a3c06"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType&gt; </td></tr>
<tr class="memitem:a2df6a4fb6c59548ebeda4b7a754a3c06"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2df6a4fb6c59548ebeda4b7a754a3c06">Diligent::Parsing::SkipFloatNumber</a> (const IteratorType &amp;Start, const IteratorType &amp;End) noexcept</td></tr>
<tr class="memdesc:a2df6a4fb6c59548ebeda4b7a754a3c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips a floating point number starting from the given position.  <br /></td></tr>
<tr class="separator:a2df6a4fb6c59548ebeda4b7a754a3c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822176c300715a5a7393a66274a797ac" id="r_a822176c300715a5a7393a66274a797ac"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType&gt; </td></tr>
<tr class="memitem:a822176c300715a5a7393a66274a797ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a822176c300715a5a7393a66274a797ac">Diligent::Parsing::SkipString</a> (const IteratorType &amp;Start, const IteratorType &amp;End, const char *Str, IteratorType &amp;StringEnd) noexcept</td></tr>
<tr class="separator:a822176c300715a5a7393a66274a797ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413a4ddaa5aa0096f23332c4d6d19fad" id="r_a413a4ddaa5aa0096f23332c4d6d19fad"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType, typename ValueType&gt; </td></tr>
<tr class="memitem:a413a4ddaa5aa0096f23332c4d6d19fad"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a413a4ddaa5aa0096f23332c4d6d19fad">Diligent::Parsing::ParseInteger</a> (const IteratorType &amp;Start, const IteratorType &amp;End, ValueType &amp;Value) noexcept</td></tr>
<tr class="separator:a413a4ddaa5aa0096f23332c4d6d19fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07615953a147ffc26f1d50d769b987e0" id="r_a07615953a147ffc26f1d50d769b987e0"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType, typename HandlerType&gt; </td></tr>
<tr class="memitem:a07615953a147ffc26f1d50d769b987e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07615953a147ffc26f1d50d769b987e0">Diligent::Parsing::SplitString</a> (const IteratorType &amp;Start, const IteratorType &amp;End, HandlerType &amp;&amp;Handler) noexcept(false)</td></tr>
<tr class="separator:a07615953a147ffc26f1d50d769b987e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0d9f6f4f25c2a81ed0b29205c42695" id="r_a8c0d9f6f4f25c2a81ed0b29205c42695"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType&gt; </td></tr>
<tr class="memitem:a8c0d9f6f4f25c2a81ed0b29205c42695"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c0d9f6f4f25c2a81ed0b29205c42695">Diligent::Parsing::GetContext</a> (const IteratorType &amp;Start, const IteratorType &amp;End, IteratorType Pos, size_t NumLines) noexcept</td></tr>
<tr class="memdesc:a8c0d9f6f4f25c2a81ed0b29205c42695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a parsing context around the given position in the string.  <br /></td></tr>
<tr class="separator:a8c0d9f6f4f25c2a81ed0b29205c42695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aa27f659e73b292de93ddd0e9b6720" id="r_ae6aa27f659e73b292de93ddd0e9b6720"><td class="memTemplParams" colspan="2">template&lt;typename TokenClass, typename ContainerType, typename IteratorType, typename CreateTokenFuncType, typename GetTokenTypeFunctType&gt; </td></tr>
<tr class="memitem:ae6aa27f659e73b292de93ddd0e9b6720"><td class="memTemplItemLeft" align="right" valign="top">ContainerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6aa27f659e73b292de93ddd0e9b6720">Diligent::Parsing::Tokenize</a> (const IteratorType &amp;SourceStart, const IteratorType &amp;SourceEnd, CreateTokenFuncType CreateToken, GetTokenTypeFunctType GetTokenType) noexcept(false)</td></tr>
<tr class="memdesc:ae6aa27f659e73b292de93ddd0e9b6720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenizes the given string using the C-language syntax.  <br /></td></tr>
<tr class="separator:ae6aa27f659e73b292de93ddd0e9b6720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2953fe218b6e386baa5cf346e121e93a" id="r_a2953fe218b6e386baa5cf346e121e93a"><td class="memTemplParams" colspan="2"><a id="a2953fe218b6e386baa5cf346e121e93a" name="a2953fe218b6e386baa5cf346e121e93a"></a>
template&lt;typename ContainerType&gt; </td></tr>
<tr class="memitem:a2953fe218b6e386baa5cf346e121e93a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Diligent::Parsing::BuildSource</b> (const ContainerType &amp;Tokens) noexcept</td></tr>
<tr class="memdesc:a2953fe218b6e386baa5cf346e121e93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds source string from tokens. <br /></td></tr>
<tr class="separator:a2953fe218b6e386baa5cf346e121e93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dea46562b11f66432f1144a4856a132" id="r_a1dea46562b11f66432f1144a4856a132"><td class="memTemplParams" colspan="2"><a id="a1dea46562b11f66432f1144a4856a132" name="a1dea46562b11f66432f1144a4856a132"></a>
template&lt;typename TokenIterType&gt; </td></tr>
<tr class="memitem:a1dea46562b11f66432f1144a4856a132"><td class="memTemplItemLeft" align="right" valign="top">TokenIterType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Diligent::Parsing::FindFunction</b> (const TokenIterType &amp;Start, const TokenIterType &amp;End, const char *Name) noexcept</td></tr>
<tr class="memdesc:a1dea46562b11f66432f1144a4856a132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a function with the given name in the token scope. <br /></td></tr>
<tr class="separator:a1dea46562b11f66432f1144a4856a132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266880e37dca10e37ec7a79ed7155a62" id="r_a266880e37dca10e37ec7a79ed7155a62"><td class="memTemplParams" colspan="2">template&lt;typename TokenIterType&gt; </td></tr>
<tr class="memitem:a266880e37dca10e37ec7a79ed7155a62"><td class="memTemplItemLeft" align="right" valign="top">TokenIterType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a266880e37dca10e37ec7a79ed7155a62">Diligent::Parsing::FindMatchingBracket</a> (const TokenIterType &amp;Start, const TokenIterType &amp;End, TokenIterType Pos)</td></tr>
<tr class="separator:a266880e37dca10e37ec7a79ed7155a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b366b5502bcdc1ba59e029bd766961" id="r_a33b366b5502bcdc1ba59e029bd766961"><td class="memTemplParams" colspan="2">template&lt;typename TokenIterType&gt; </td></tr>
<tr class="memitem:a33b366b5502bcdc1ba59e029bd766961"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33b366b5502bcdc1ba59e029bd766961">Diligent::Parsing::GetTokenContext</a> (const TokenIterType &amp;Start, const TokenIterType &amp;End, TokenIterType Pos, size_t NumAdjacentLines)</td></tr>
<tr class="memdesc:a33b366b5502bcdc1ba59e029bd766961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a parsing context around the given token.  <br /></td></tr>
<tr class="separator:a33b366b5502bcdc1ba59e029bd766961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d1f0f090482d5729a26ff3be105648" id="r_ad8d1f0f090482d5729a26ff3be105648"><td class="memTemplParams" colspan="2"><a id="ad8d1f0f090482d5729a26ff3be105648" name="ad8d1f0f090482d5729a26ff3be105648"></a>
template&lt;typename InteratorType&gt; </td></tr>
<tr class="memitem:ad8d1f0f090482d5729a26ff3be105648"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Diligent::Parsing::RefinePreprocessorDirective</b> (const InteratorType &amp;Start, const InteratorType &amp;End) noexcept</td></tr>
<tr class="memdesc:ad8d1f0f090482d5729a26ff3be105648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the preprocessor directive from the given range. <br /></td></tr>
<tr class="separator:ad8d1f0f090482d5729a26ff3be105648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5dbf9af1d97dd99fd90fff22c87f46" id="r_a0f5dbf9af1d97dd99fd90fff22c87f46"><td class="memTemplParams" colspan="2">template&lt;typename InteratorType&gt; </td></tr>
<tr class="memitem:a0f5dbf9af1d97dd99fd90fff22c87f46"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f5dbf9af1d97dd99fd90fff22c87f46">Diligent::Parsing::GetArrayIndex</a> (const InteratorType &amp;Start, const InteratorType &amp;End, InteratorType &amp;NameEnd)</td></tr>
<tr class="separator:a0f5dbf9af1d97dd99fd90fff22c87f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602cd6c08a972bd8c18e9a64d455915c" id="r_a602cd6c08a972bd8c18e9a64d455915c"><td class="memTemplParams" colspan="2">template&lt;typename InteratorType&gt; </td></tr>
<tr class="memitem:a602cd6c08a972bd8c18e9a64d455915c"><td class="memTemplItemLeft" align="right" valign="top">InteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a602cd6c08a972bd8c18e9a64d455915c">Diligent::Parsing::FindNextPreprocessorDirective</a> (const InteratorType &amp;Start, const InteratorType &amp;End, InteratorType &amp;NameStart, InteratorType &amp;NameEnd)</td></tr>
<tr class="separator:a602cd6c08a972bd8c18e9a64d455915c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b424ced7925967055e1c5444e7de807" id="r_a3b424ced7925967055e1c5444e7de807"><td class="memItemLeft" align="right" valign="top"><a id="a3b424ced7925967055e1c5444e7de807" name="a3b424ced7925967055e1c5444e7de807"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Diligent::Parsing::StripPreprocessorDirectives</b> (std::string &amp;Source, const std::vector&lt; std::string &gt; &amp;Directives)</td></tr>
<tr class="memdesc:a3b424ced7925967055e1c5444e7de807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips all preprocessor directives from the source string. <br /></td></tr>
<tr class="separator:a3b424ced7925967055e1c5444e7de807"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parsing tools </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5852870f9be1ca3be27c3cd81775b103" name="a5852870f9be1ca3be27c3cd81775b103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5852870f9be1ca3be27c3cd81775b103">&#9670;&#160;</a></span>SKIP_COMMENT_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a5852870f9be1ca3be27c3cd81775b103">Diligent::Parsing::SKIP_COMMENT_FLAGS</a> : Uint32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags controlling what kind of comments the SkipComment function should skip. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5852870f9be1ca3be27c3cd81775b103ae590071458e55fce93b68d546aa29549" name="a5852870f9be1ca3be27c3cd81775b103ae590071458e55fce93b68d546aa29549"></a>SKIP_COMMENT_FLAG_NONE&#160;</td><td class="fielddoc"><p>Skip no comments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5852870f9be1ca3be27c3cd81775b103a932cd3bb9185e1c4f04194dfd2a7372c" name="a5852870f9be1ca3be27c3cd81775b103a932cd3bb9185e1c4f04194dfd2a7372c"></a>SKIP_COMMENT_FLAG_SINGLE_LINE&#160;</td><td class="fielddoc"><p>Skip single-line comment. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5852870f9be1ca3be27c3cd81775b103ae7ac9d7849e8fc934648f0e11d6271af" name="a5852870f9be1ca3be27c3cd81775b103ae7ac9d7849e8fc934648f0e11d6271af"></a>SKIP_COMMENT_FLAG_MULTILINE&#160;</td><td class="fielddoc"><p>Skip multi-line comment. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5852870f9be1ca3be27c3cd81775b103a72d5705eddb4728df616dfa5eb1ea8f0" name="a5852870f9be1ca3be27c3cd81775b103a72d5705eddb4728df616dfa5eb1ea8f0"></a>SKIP_COMMENT_FLAG_ALL&#160;</td><td class="fielddoc"><p>Skip all kinds of comments. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a266880e37dca10e37ec7a79ed7155a62" name="a266880e37dca10e37ec7a79ed7155a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266880e37dca10e37ec7a79ed7155a62">&#9670;&#160;</a></span>FindMatchingBracket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TokenIterType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TokenIterType Diligent::Parsing::FindMatchingBracket </td>
          <td>(</td>
          <td class="paramtype">const TokenIterType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TokenIterType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TokenIterType</td>          <td class="paramname"><span class="paramname"><em>Pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the matching bracket. For open brackets, searches in the forward direction. For closing brackets, searches backwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- start of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>- search starting position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the matching bracket, or End if none is found. </dd></dl>

</div>
</div>
<a id="a602cd6c08a972bd8c18e9a64d455915c" name="a602cd6c08a972bd8c18e9a64d455915c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602cd6c08a972bd8c18e9a64d455915c">&#9670;&#160;</a></span>FindNextPreprocessorDirective()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InteratorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InteratorType Diligent::Parsing::FindNextPreprocessorDirective </td>
          <td>(</td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>NameStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>NameEnd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the next preprocessor directive in the given range. </p><pre class="fragment"># define MACRO
^ ^     ^
| |    NameEnd
| NameStart
Return value 
</pre> 
</div>
</div>
<a id="a0f5dbf9af1d97dd99fd90fff22c87f46" name="a0f5dbf9af1d97dd99fd90fff22c87f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5dbf9af1d97dd99fd90fff22c87f46">&#9670;&#160;</a></span>GetArrayIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InteratorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Diligent::Parsing::GetArrayIndex </td>
          <td>(</td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>NameEnd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the array index if the given variable name is an indexed array element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the input string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NameEnd</td><td>- ending position of the variable name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Array index if the given variable name is an array element.<ul>
<li>-1 if the given variable name is a valid identifier and is not an array element.</li>
<li>INT_MIN if the array index is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8c0d9f6f4f25c2a81ed0b29205c42695" name="a8c0d9f6f4f25c2a81ed0b29205c42695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0d9f6f4f25c2a81ed0b29205c42695">&#9670;&#160;</a></span>GetContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Diligent::Parsing::GetContext </td>
          <td>(</td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType</td>          <td class="paramname"><span class="paramname"><em>Pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>NumLines</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a parsing context around the given position in the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- start of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>- position around which to print the context and which will be highlighted by ^. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NumLines</td><td>- the number of lines above and below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representing the context around the given position.</dd></dl>
<p>The context looks like shown below: </p><pre class="fragment">Lorem ipsum dolor sit amet, consectetur
adipiscing elit, sed do eiusmod tempor
incididunt ut labore et dolore magna aliqua.
                     ^
Ut enim ad minim veniam, quis nostrud
exercitation ullamco lab
</pre> 
</div>
</div>
<a id="a33b366b5502bcdc1ba59e029bd766961" name="a33b366b5502bcdc1ba59e029bd766961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b366b5502bcdc1ba59e029bd766961">&#9670;&#160;</a></span>GetTokenContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TokenIterType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Diligent::Parsing::GetTokenContext </td>
          <td>(</td>
          <td class="paramtype">const TokenIterType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TokenIterType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TokenIterType</td>          <td class="paramname"><span class="paramname"><em>Pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>NumAdjacentLines</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a parsing context around the given token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- start of the token range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the token range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>- position around which to print the context and which will be highlighted by ^. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NumAdjacentLines</td><td>- the number of adjacent lines above and below to print.</td></tr>
  </table>
  </dd>
</dl>
<p>The context looks like shown below: </p><pre class="fragment">Lorem ipsum dolor sit amet, consectetur
adipiscing elit, sed do eiusmod tempor
incididunt ut labore et dolore magna aliqua.
                     ^
Ut enim ad minim veniam, quis nostrud
exercitation ullamco lab
</pre> 
</div>
</div>
<a id="a413a4ddaa5aa0096f23332c4d6d19fad" name="a413a4ddaa5aa0096f23332c4d6d19fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413a4ddaa5aa0096f23332c4d6d19fad">&#9670;&#160;</a></span>ParseInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorType, typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType Diligent::Parsing::ParseInteger </td>
          <td>(</td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses an integer starting from the given position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the input string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Value</td><td>- parsed integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position immediately following the last character of the number. </dd></dl>

</div>
</div>
<a id="ada5e0a755b7c3fe7059afca1cd62c9b7" name="ada5e0a755b7c3fe7059afca1cd62c9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5e0a755b7c3fe7059afca1cd62c9b7">&#9670;&#160;</a></span>SkipComment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InteratorType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InteratorType Diligent::Parsing::SkipComment </td>
          <td>(</td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5852870f9be1ca3be27c3cd81775b103">SKIP_COMMENT_FLAGS</a></td>          <td class="paramname"><span class="paramname"><em>Flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5852870f9be1ca3be27c3cd81775b103a72d5705eddb4728df616dfa5eb1ea8f0">SKIP_COMMENT_FLAG_ALL</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skips single-line and multi-line comments starting from the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flags</td><td>- flags controlling what kind of comments to skip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the comment is found, the position immediately following the end of the comment; starting position otherwise.</dd></dl>
<p>In case of an error while parsing the comment (e.g. <code>/*</code> is not closed), the function throws an exception of type <code>std::pair&lt;InteratorType, const char*&gt;</code>, where first is the position of the error, and second is the error description. </p>

</div>
</div>
<a id="abef494eb616b4b27367eb645adc56ad2" name="abef494eb616b4b27367eb645adc56ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef494eb616b4b27367eb645adc56ad2">&#9670;&#160;</a></span>SkipDelimiters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InteratorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InteratorType Diligent::Parsing::SkipDelimiters </td>
          <td>(</td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>Delimiters</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips all delimiters starting from the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Delimiters</td><td>- optional string containing custom delimiters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the first non-delimiter character. </dd></dl>

</div>
</div>
<a id="ab7e1ce3b683844a4a25dcb6234751ef4" name="ab7e1ce3b683844a4a25dcb6234751ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e1ce3b683844a4a25dcb6234751ef4">&#9670;&#160;</a></span>SkipDelimitersAndComments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IteratorType Diligent::Parsing::SkipDelimitersAndComments </td>
          <td>(</td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>Delimiters</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5852870f9be1ca3be27c3cd81775b103">SKIP_COMMENT_FLAGS</a></td>          <td class="paramname"><span class="paramname"><em>CommentFlags</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5852870f9be1ca3be27c3cd81775b103a72d5705eddb4728df616dfa5eb1ea8f0">SKIP_COMMENT_FLAG_ALL</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skips all comments and all delimiters starting from the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Delimiters</td><td>- optional string containing custom delimiters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CommentFlags</td><td>- optional flags controlling what kind of comments to skip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true position of the first non-comment non-delimiter character.</dd></dl>
<p>In case of a parsing error (which means there is an open multi-line comment <code>/*...</code>), the function throws an exception of type <code>std::pair&lt;InteratorType, const char*&gt;</code>, where first is the position of the error, and second is the error description. </p>

</div>
</div>
<a id="a2df6a4fb6c59548ebeda4b7a754a3c06" name="a2df6a4fb6c59548ebeda4b7a754a3c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df6a4fb6c59548ebeda4b7a754a3c06">&#9670;&#160;</a></span>SkipFloatNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType Diligent::Parsing::SkipFloatNumber </td>
          <td>(</td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips a floating point number starting from the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the input string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position immediately following the last character of the number. </dd></dl>

</div>
</div>
<a id="a8ed3c923a49cdf53f25369faad459d3e" name="a8ed3c923a49cdf53f25369faad459d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed3c923a49cdf53f25369faad459d3e">&#9670;&#160;</a></span>SkipIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType Diligent::Parsing::SkipIdentifier </td>
          <td>(</td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips one identifier starting from the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the input string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position immediately following the last character of identifier. </dd></dl>

</div>
</div>
<a id="a8238ec72e661b795b9e1a09d96267ecb" name="a8238ec72e661b795b9e1a09d96267ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8238ec72e661b795b9e1a09d96267ecb">&#9670;&#160;</a></span>SkipLine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InteratorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InteratorType Diligent::Parsing::SkipLine </td>
          <td>(</td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>GoToNextLine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips all characters until the end of the line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GoToNextLine</td><td>- whether to go to the next line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>GoToNextLine</code> is <code>true</code>, the position following the new line character at the end of the string. If <code>GoToNextLine</code> is <code>false</code>, the position of the new line character at the end of the string.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>CRLF ending (<code>\r\n</code>) is treated as a single new line separator. </dd></dl>

</div>
</div>
<a id="a822176c300715a5a7393a66274a797ac" name="a822176c300715a5a7393a66274a797ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822176c300715a5a7393a66274a797ac">&#9670;&#160;</a></span>SkipString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Diligent::Parsing::SkipString </td>
          <td>(</td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>Str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>StringEnd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Skips a specified string starting from the given position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- starting position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Str</td><td>- string to skip. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">StringEnd</td><td>- position immediately following the last character of the string, if found, or Start otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string has been found, false otherwise. </dd></dl>

</div>
</div>
<a id="a07615953a147ffc26f1d50d769b987e0" name="a07615953a147ffc26f1d50d769b987e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07615953a147ffc26f1d50d769b987e0">&#9670;&#160;</a></span>SplitString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorType, typename HandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Diligent::Parsing::SplitString </td>
          <td>(</td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>Start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>End</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandlerType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Handler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits string into chunks separated by comments and delimiters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Start</td><td>- start of the string to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">End</td><td>- end of the string to split. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Handler</td><td>- user-provided handler to call for each chunk.</td></tr>
  </table>
  </dd>
</dl>
<p>The function starts from the beginning of the strings and splits it into chunks separated by comments and delimiters. For each chunk, it calls the user-provided handler and passes the start of the preceding comments/delimiters part. The handler must then process the text at the current position and move the pointer. It should return true to continue processing, and false to stop it.</p>
<p>In case of a parsing error, the function throws an exception of type <code>std::pair&lt;InteratorType, const char*&gt;</code>, where first is the position of the error, and second is the error description. </p>

</div>
</div>
<a id="ae6aa27f659e73b292de93ddd0e9b6720" name="ae6aa27f659e73b292de93ddd0e9b6720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6aa27f659e73b292de93ddd0e9b6720">&#9670;&#160;</a></span>Tokenize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TokenClass, typename ContainerType, typename IteratorType, typename CreateTokenFuncType, typename GetTokenTypeFunctType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ContainerType Diligent::Parsing::Tokenize </td>
          <td>(</td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>SourceStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;</td>          <td class="paramname"><span class="paramname"><em>SourceEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CreateTokenFuncType</td>          <td class="paramname"><span class="paramname"><em>CreateToken</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetTokenTypeFunctType</td>          <td class="paramname"><span class="paramname"><em>GetTokenType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokenizes the given string using the C-language syntax. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SourceStart</td><td>- start of the source string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SourceEnd</td><td>- end of the source string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CreateToken</td><td>- a handler called every time a new token should be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GetTokenType</td><td>- a function that should return the token type for the given literal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tokenized representation of the source string</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In case of a parsing error, the function throws std::runtime_error. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_0f3dc4349d8f74e06543298a24c16f87.html">DiligentCore</a></li><li class="navelem"><a class="el" href="../../dir_65c7295f30ed36fb99a020dd8560a2f0.html">Common</a></li><li class="navelem"><a class="el" href="../../dir_9e65195be5362a6b8b8e3ad4d029e930.html">interface</a></li><li class="navelem"><a class="el" href="../../d8/d6a/ParsingTools_8hpp.html">ParsingTools.hpp</a></li>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
