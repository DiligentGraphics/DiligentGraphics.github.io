<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: HLSL2GLSL Converter Lib</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d68/DiligentCore_Graphics_HLSL2GLSLConverterLib_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">HLSL2GLSL Converter Lib</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Implementation of HLSL to GLSL source converter</p>
<p>DirectX and OpenGL use different shading languages, which share a lot in common, but sometimes differ substantially. For cross-platform applications, maintaining two versions of each shader is time-consuming and error-prone. <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine uses HLSL2GLSL Converter that allows shader authored in HLSL to be converted into GLSL source.</p>
<h2><a class="anchor" id="autotoc_md79"></a>
Details</h2>
<h3><a class="anchor" id="autotoc_md80"></a>
Requirements</h3>
<p>The converter supports HLSL5.0, all shader types (vertex, geometry, pixel, domain, hull, and compute) as well as most of the language constructs. There are however few special requirements that must be met in order for the HLSL source to be successfully converted to GLSL:</p>
<ul>
<li>Inputs to a vertex shader is recommended to have <code>ATTRIBn</code> semantic, where n defines the location of the corresponding GLSL input variable (<code>layout(location = n)</code>). For any other input semantic, the converter automatically assigns input location.</li>
<li><p class="startli">Inputs of a subsequent shader stage must be declared in exact same order as outputs of the previous shader stage. Return value of a function counts as its first output.</p>
<p class="startli">The converter parses all input and output arguments (including structure members) in the order of declaration and automatically assigns locations to every argument. To make sure that input and output locations match, the arguments must be declared in exact same order. For the same reason, if an argument is not used by the shader, it still needs to be declared to preserve original ordering.</p>
</li>
</ul>
<p>The code snippet below gives examples of supported shader declarations:</p>
<div class="fragment"><div class="line">struct VSInput</div>
<div class="line">{</div>
<div class="line">    // It is recommended (though not required) to assign </div>
<div class="line">    // ATTRIBn semantics to inputs from input assembler</div>
<div class="line">    in float3 f3PosWS : ATTRIB0;</div>
<div class="line">    in float2 f2UV  : ATTRIB1;</div>
<div class="line">    uint VertexID : SV_VertexID;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct VSOutput</div>
<div class="line">{</div>
<div class="line">    float2 UV : TEX_COORDINATES;</div>
<div class="line">    float3 Normal : NORMAL;</div>
<div class="line">    float4 f4PosPS : SV_Position;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">VSOutput VertexShader ( in VSInput VSIn,</div>
<div class="line">                        in float3 f3UV  : ATTRIB2,</div>
<div class="line">                        uint InstID : SV_InstanceID,</div>
<div class="line">                        out float3 f3Tangent : TANGENT )</div>
<div class="line">{</div>
<div class="line">    VSOutput VSOut;</div>
<div class="line">    // Body elided</div>
<div class="line">    f3Tangent = ...</div>
<div class="line">    return VSOut;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">float4 PixelShader ( // Pixel shader inputs must be declared in exact same order </div>
<div class="line">                     // as outputs of the vertex shader</div>
<div class="line">                     VSOutput PSIn,</div>
<div class="line">                     in float3 f3Tangent : TaNgEnT // Semantics are case-insensitive</div>
<div class="line">                     out float3 Color2 : SV_Target2 ) :  SV_Target</div>
<div class="line">{</div>
<div class="line">    // Body elided</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>When tessellation is enabled in OpenGL, partitioning as well as output patch topology are defined by the tessellation evaluation shader (domain shader) rather than by the tessellation control shader (hull shader). As a result, the converter cannot generate GLSL code without using special hints. To indicate missing attributes, the following specially formatted comment should be added right on top of the domain shader entry function:</li>
</ul>
<div class="fragment"><div class="line">/* partitioning = {integer|fractional_even|fractional_odd}, outputtopology = {triangle_cw|triangle_ccw} */</div>
</div><!-- fragment --><p>For example, the following is a valid domain shader declaration:</p>
<div class="fragment"><div class="line">[domain(&quot;quad&quot;)]</div>
<div class="line">/* partitioning = fractional_even, outputtopology = triangle_cw */</div>
<div class="line">DSOutput main( HS_CONSTANT_DATA_OUTPUT input, </div>
<div class="line">               float2 QuadUV : SV_DomainLocation, </div>
<div class="line">               OutputPatch&lt;HSOutput, 2&gt; QuadPatch)</div>
<div class="line">{</div>
<div class="line">    // Body elided</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Geometry, Domain and Hull shaders must be defined in separate files</li>
<li>GLSL allows samplers to be declared as global variables or function arguments only. It does not allow local variables of sampler type.</li>
</ul>
<h3><a class="anchor" id="autotoc_md81"></a>
Textures and samplers</h3>
<p>The following rules are used to convert HLSL texture declaration into GLSL sampler:</p>
<p>HLSL texture dimension defines GLSL sampler dimension:</p>
<ul>
<li><code>Texture2D</code> -&gt; <code>sampler2D</code></li>
<li><code>TextureCube</code> -&gt; <code>samplerCube</code></li>
</ul>
<p>HLSL texture component type defines GLSL sampler type. If no type is specified, <code>float4</code> is assumed:</p>
<ul>
<li><code>Texture2D&lt;float&gt;</code> -&gt; <code>sampler2D</code></li>
<li><code>Texture3D&lt;uint4&gt;</code> -&gt; <code>usampler3D</code></li>
<li><code>Texture2DArray&lt;int2&gt;</code> -&gt; <code>isampler2DArray</code></li>
<li><code>Texture2D</code> -&gt; <code>sampler2D</code></li>
</ul>
<p>To distinguish if sampler should be shadow or not, the converter tries to find <code>&lt;Texture Name&gt;_sampler</code> among samplers (global variables and function arguments). If the sampler type is comparison, the texture is converted to shadow sampler. If sampler state is either not comparison or not found, regular sampler is used. For example</p>
<div class="fragment"><div class="line">Texture2D g_ShadowMap;</div>
<div class="line">SamplerComparisonState g_ShadowMap_sampler;</div>
<div class="line"> </div>
<div class="line">Texture2D g_Tex2D;</div>
<div class="line">SamplerState g_Tex2D_sampler;</div>
<div class="line"> </div>
<div class="line">Texture3D g_Tex3D;</div>
</div><!-- fragment --><p>is converted to</p>
<div class="fragment"><div class="line">sampler2DShadow g_ShadowMap;</div>
<div class="line">sampler2D g_Tex2D;</div>
<div class="line">sampler3D g_Tex3D;</div>
</div><!-- fragment --><p>GLSL requires format to be specified for all images (rw textures) allowing writes. HLSL converter allows GLSL image format specification inside the special comment block: </p><div class="fragment"><div class="line">RWTexture2D&lt;float /* format=r32f */ &gt; Tex2D;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md82"></a>
Important notes/known issues</h3>
<ul>
<li>GLSL compiler does not handle <code>float3</code> (<code>vec3</code>) structure members correctly. It is strongly suggested avoid using this type in structure definitions</li>
<li>At least NVidia GLSL compiler does not apply layout(row_major) to structure members. By default, all matrices in both HLSL and GLSL are column major</li>
<li>GLSL compiler does not properly handle structs passed as function arguments!!!!</li>
</ul>
<div class="fragment"><div class="line">struct MyStruct</div>
<div class="line">{</div>
<div class="line">    matrix Matr; </div>
<div class="line">} </div>
<div class="line">void Func(in MyStruct S)</div>
<div class="line">{ </div>
<div class="line">    ... </div>
<div class="line">    mul(f4PosWS, S.Matr); // This will not work!!! </div>
<div class="line">}</div>
</div><!-- fragment --><p>DO NOT pass structs to functions, use only built-in types!!!</p>
<ul>
<li>GLSL does not support most of the implicit type conversions. The following are some examples of the required modifications to HLSL code:<ul>
<li><code>float4 vec = 0;</code> -&gt; <code>float4 vec = float4(0.0, 0.0, 0.0, 0.0);</code></li>
<li><code>float x = 0;</code> -&gt; <code>float x = 0.0;</code></li>
<li><code>uint x = 0;</code> -&gt; <code>uint x = 0u;</code></li>
</ul>
</li>
<li>GLES is immensely strict about type conversions. For instance, this code will produce compiler error: <code>float4(0, 0, 0, 0)</code>. It must be written as <code>float4(0.0, 0.0, 0.0, 0.0)</code></li>
<li>GLSL does not support relational and boolean operations on vector types:</li>
</ul>
<div class="fragment"><div class="line">float2 p = float2(1.0, 2.0), q = float2(3.0, 4.0);</div>
<div class="line">bool2 b = p &lt; q; // Error</div>
<div class="line">all(p &lt; q); // Error</div>
</div><!-- fragment --><ul>
<li>To facilitate relational and Boolean operations on vector types, the following functions are predefined:<ul>
<li><code>Less</code></li>
<li><code>LessEqual</code></li>
<li><code>Greater</code></li>
<li><code>GreaterEqual</code></li>
<li><code>Equal</code></li>
<li><code>NotEqual</code></li>
<li><code>Not</code></li>
<li><code>And</code></li>
<li><code>Or</code></li>
<li><code>BoolToFloat</code></li>
</ul>
</li>
<li>Examples:<ul>
<li><code>bool2 b = x &lt; y;</code> -&gt; <code>b = Less(x, y);</code></li>
<li><code>all(p&gt;=q)</code> -&gt; <code>all( GreaterEqual(p,q) )</code></li>
</ul>
</li>
<li>When accessing elements of an HLSL matrix, the first index is always a row: <code>mat[row][column]</code> In GLSL, the first index is always a column: <code>mat[column][row]</code> <code>MATRIX_ELEMENT(mat, row, col)</code> macros is provided to facilitate matrix element retrieval</li>
<li>The following functions do not have counterparts in GLSL and should be avoided:<ul>
<li><code>Texture2DArray.SampleCmpLevelZero()</code></li>
<li><code>TextureCube.SampleCmpLevelZero()</code></li>
<li><code>TextureCubeArray.SampleCmpLevelZero()</code></li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md83"></a>
Limitations</h3>
<p>Converter does not perform macros expansion, so usage of preprocessor directives is limited to text block that do not need to be converted. The following are some examples that are not supported.</p>
<p>Using macros in declarations of shader entry points:</p>
<div class="fragment"><div class="line">VSOut TestVS  (</div>
<div class="line">#ifdef SOME_MACRO</div>
<div class="line">               in VSInput0 VSInput</div>
<div class="line">#else</div>
<div class="line">               in VSInput1 VSInput</div>
<div class="line">#endif</div>
<div class="line">               )</div>
</div><!-- fragment --><p>The following is not allowed as well:</p>
<div class="fragment"><div class="line">#ifdef SOME_MACRO</div>
<div class="line">VSOut TestVS  (in VSInput0 VSInput)</div>
<div class="line">#else</div>
<div class="line">VSOut TestVS  (in VSInput1 VSInput)</div>
<div class="line">#endif</div>
</div><!-- fragment --><p>In cases like that it is necessary to create two separate shader entry points and give them distinctive names. Likewise, macros cannot be used in definitions of structures that are used to pass data between shader stages:</p>
<div class="fragment"><div class="line">struct VSInput</div>
<div class="line">{</div>
<div class="line">    in float3 f3PosWS : ATTRIB0;</div>
<div class="line">#ifdef SOME_MACRO</div>
<div class="line">    in float2 f2UV  : ATTRIB1;</div>
<div class="line">#else</div>
<div class="line">    in float4 f4UV  : ATTRIB1;</div>
<div class="line">#endif</div>
<div class="line">    uint VertexID : SV_VertexID;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Similarly to shader entry points, in the scenario above, the two structures need to be defined with distinctive names. Shader macros are allowed in structures that are not used to pass data between shader stages.</p>
<p>Defining language keywords with macros is not allowed: </p><div class="fragment"><div class="line">#define TEXTURE2D Texture2D</div>
<div class="line">TEXTURE2D MacroTex2D;</div>
</div><!-- fragment --><p>Macros can be used within function bodies:</p>
<div class="fragment"><div class="line">VSOut VSTes(...)</div>
<div class="line">{</div>
<div class="line">#ifdef SOME_MACRO</div>
<div class="line">    // OK</div>
<div class="line">#else</div>
<div class="line">    // OK</div>
<div class="line">#endif</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md84"></a>
Features</h2>
<p>Please visit <a href="http://diligentgraphics.com/diligent-engine/shader-converter/supported-features/">this page</a> for the full list of supported language features.</p>
<h2><a class="anchor" id="autotoc_md85"></a>
References</h2>
<p><a href="http://diligentgraphics.com/diligent-engine/shader-converter/">HLSL to GLSL Source Converter</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
