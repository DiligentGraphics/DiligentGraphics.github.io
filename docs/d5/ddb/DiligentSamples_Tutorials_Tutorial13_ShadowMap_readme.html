<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial13 - Shadow Map</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/ddb/DiligentSamples_Tutorials_Tutorial13_ShadowMap_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial13 - Shadow Map</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates how to render basic shadows using a shadow map. It is assumed that you are familiar with all basics covered in Tutorial01 to Tutorial03 as well as in Tutorial12. Please note that this tutorial only demonstrates basic setup and does not cover shadow map filtering, artifacts removal and other topics. Refer to <a href="https://github.com/DiligentGraphics/DiligentSamples/tree/master/Samples/Shadows">Shadows sample</a> for a real-world shadow map implementation.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial13_ShadowMap/Animation_Large.gif" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial13_ShadowMap/Tutorial13_ShadowMap.html">â–¶ Run in the browser</a></p>
<p>Rendering shadows with a shadow map consists of two steps:</p>
<ul>
<li>The scene is rendered from the point of view of the light into a dedicated depth buffer called shadow map.</li>
<li>The scene is rendered from the main camera, and the shadow map is used to determine if the point is lit or not by comparing the point's depth in light space to the depth stored in the shadow map.</li>
</ul>
<p>This tutorial renders a cube into the shadow map and then uses it to cast a shadow onto a plane.</p>
<h2><a class="anchor" id="autotoc_md361"></a>
Creating a shadow map texture</h2>
<p>A shadow map is just a normal 2D texture that can be used as depth-stencil buffer and shader resource:</p>
<div class="fragment"><div class="line">TextureDesc SMDesc;</div>
<div class="line">SMDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>      = <span class="stringliteral">&quot;Shadow map&quot;</span>;</div>
<div class="line">SMDesc.Type      = RESOURCE_DIM_TEX_2D;</div>
<div class="line">SMDesc.Width     = m_ShadowMapSize;</div>
<div class="line">SMDesc.Height    = m_ShadowMapSize;</div>
<div class="line">SMDesc.Format    = m_ShadowMapFormat;</div>
<div class="line">SMDesc.BindFlags = BIND_SHADER_RESOURCE | BIND_DEPTH_STENCIL;</div>
<div class="line">RefCntAutoPtr&lt;ITexture&gt; ShadowMap;</div>
<div class="line">m_pDevice-&gt;CreateTexture(SMDesc, <span class="keyword">nullptr</span>, &amp;ShadowMap);</div>
<div class="line">m_ShadowMapSRV = ShadowMap-&gt;GetDefaultView(TEXTURE_VIEW_SHADER_RESOURCE);</div>
<div class="line">m_ShadowMapDSV = ShadowMap-&gt;GetDefaultView(TEXTURE_VIEW_DEPTH_STENCIL);</div>
<div class="ttc" id="astructDiligent_1_1DeviceObjectAttribs_html_a14a31dc6ad69e0b79514e5349e9b4fc0"><div class="ttname"><a href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Diligent::DeviceObjectAttribs::Name</a></div><div class="ttdeci">const Char * Name</div><div class="ttdoc">Object name.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1319</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md362"></a>
Shadow pass pipeline state</h2>
<p>There are few specifics of the shadow pass PSO initialization. First, there are no render targets:</p>
<div class="fragment"><div class="line">PSOCreateInfo.PSODesc.Name                      = <span class="stringliteral">&quot;Cube shadow PSO&quot;</span>;</div>
<div class="line"><span class="comment">// Shadow pass doesn&#39;t use any render target outputs</span></div>
<div class="line">PSOCreateInfo.GraphicsPipeline.NumRenderTargets = 0;</div>
<div class="line">PSOCreateInfo.GraphicsPipeline.RTVFormats[0]    = TEX_FORMAT_UNKNOWN;</div>
<div class="line"><span class="comment">// The DSV format is the shadow map format</span></div>
<div class="line">PSOCreateInfo.GraphicsPipeline.DSVFormat        = m_ShadowMapFormat;</div>
</div><!-- fragment --><p>Since we don't use render targets, we also don't need a pixel shader:</p>
<div class="fragment"><div class="line">PSOCreateInfo.GraphicsPipeline.pVS              = pShadowVS;</div>
<div class="line"><span class="comment">// We don&#39;t use pixel shader as we are only interested in populating the depth buffer</span></div>
<div class="line">PSOCreateInfo.GraphicsPipeline.pPS              = <span class="keyword">nullptr</span>;</div>
</div><!-- fragment --><p>Finally, we typically want to disable depth clipping. This is to make sure that objects that are closer than the near clipping plane are still rendered into the shadow map.</p>
<div class="fragment"><div class="line">PSOCreateInfo.GraphicsPipeline.RasterizerDesc.DepthClipEnable = False;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md363"></a>
Rendering the shadow map</h2>
<p>First, we need to bind the shadow map to the context (note that no render targets are provided) and clear it:</p>
<div class="fragment"><div class="line">m_pImmediateContext-&gt;SetRenderTargets(0, <span class="keyword">nullptr</span>, m_ShadowMapDSV,</div>
<div class="line">                                      RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line">m_pImmediateContext-&gt;ClearDepthStencil(m_ShadowMapDSV, CLEAR_DEPTH_FLAG, 1.f, 0,</div>
<div class="line">                                       RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line">RenderShadowMap();</div>
</div><!-- fragment --><p><code>RenderShadowMap</code> function first constructs shadow map matrices and then renders the cube into the shadow map using shadow-only mode.</p>
<p>The function starts by building a world-to-light-view-space transformation matrix. The Z axis of this matrix is the light direction. Two other axes are selected to avoid precision issues:</p>
<div class="fragment"><div class="line">float3 f3LightSpaceX, f3LightSpaceY, f3LightSpaceZ;</div>
<div class="line">f3LightSpaceZ = normalize(m_LightDirection);</div>
<div class="line">    </div>
<div class="line"><span class="keyword">auto</span> min_cmp = std::min(std::min(std::abs(m_LightDirection.x), std::abs(m_LightDirection.y)),</div>
<div class="line">                        std::abs(m_LightDirection.z));</div>
<div class="line"><span class="keywordflow">if</span> (min_cmp == std::abs(m_LightDirection.x))</div>
<div class="line">    f3LightSpaceX =  float3(1, 0, 0);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (min_cmp == std::abs(m_LightDirection.y))</div>
<div class="line">    f3LightSpaceX =  float3(0, 1, 0);</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    f3LightSpaceX =  float3(0, 0, 1);</div>
<div class="line">    </div>
<div class="line">f3LightSpaceY = cross(f3LightSpaceZ, f3LightSpaceX);</div>
<div class="line">f3LightSpaceX = cross(f3LightSpaceY, f3LightSpaceZ);</div>
<div class="line">f3LightSpaceX = normalize(f3LightSpaceX);</div>
<div class="line">f3LightSpaceY = normalize(f3LightSpaceY);</div>
<div class="line">    </div>
<div class="line">float4x4 WorldToLightViewSpaceMatr = float4x4::ViewFromBasis(f3LightSpaceX, f3LightSpaceY, f3LightSpaceZ);</div>
</div><!-- fragment --><p>Second, we need to define the scene boundaries. For this tutorial we know that the cube center is at (0,0,0). Real applications will want to compute tight bounds as this is crucial for getting high-quality shadows.</p>
<div class="fragment"><div class="line">float3 f3SceneCenter = float3(0, 0, 0);</div>
<div class="line"><span class="keywordtype">float</span> SceneRadius = std::sqrt(3.f);</div>
<div class="line">float3 f3MinXYZ = f3SceneCenter - float3(SceneRadius, SceneRadius, SceneRadius);</div>
<div class="line">float3 f3MaxXYZ = f3SceneCenter + float3(SceneRadius, SceneRadius, SceneRadius*5);</div>
<div class="line">float3 f3SceneExtent = f3MaxXYZ - f3MinXYZ;</div>
</div><!-- fragment --><p>Next, we need to compute the scaling and biasing matrices such that scene extent is transformed to a normalized device space. Note that while in Direct3D11, Direct3D12, and Vulkan this space is [-1,1]x[-1,1]x[0,1], in OpenGL it is [-1,1]x[-1,1]x[-1,1].</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> IsGL = m_pDevice-&gt;GetDeviceInfo().IsGLDevice();</div>
<div class="line">float4 f4LightSpaceScale;</div>
<div class="line">f4LightSpaceScale.x =  2.f / f3SceneExtent.x;</div>
<div class="line">f4LightSpaceScale.y =  2.f / f3SceneExtent.y;</div>
<div class="line">f4LightSpaceScale.z =  (IsGL ? 2.f : 1.f) / f3SceneExtent.z;</div>
<div class="line"><span class="comment">// Apply bias to shift the extent to [-1,1]x[-1,1]x[0,1] for DX or to [-1,1]x[-1,1]x[-1,1] for GL</span></div>
<div class="line"><span class="comment">// Find bias such that f3MinXYZ -&gt; (-1,-1,0) for DX or (-1,-1,-1) for GL</span></div>
<div class="line">float4 f4LightSpaceScaledBias;</div>
<div class="line">f4LightSpaceScaledBias.x = -f3MinXYZ.x * f4LightSpaceScale.x - 1.f;</div>
<div class="line">f4LightSpaceScaledBias.y = -f3MinXYZ.y * f4LightSpaceScale.y - 1.f;</div>
<div class="line">f4LightSpaceScaledBias.z = -f3MinXYZ.z * f4LightSpaceScale.z + (IsGL ? -1.f : 0.f);</div>
<div class="line"> </div>
<div class="line">float4x4 ScaleMatrix = float4x4::Scale(f4LightSpaceScale.x, f4LightSpaceScale.y, f4LightSpaceScale.z);</div>
<div class="line">float4x4 ScaledBiasMatrix = float4x4::Translation(f4LightSpaceScaledBias.x, f4LightSpaceScaledBias.y,</div>
<div class="line">                                                  f4LightSpaceScaledBias.z);</div>
</div><!-- fragment --><p>Now we can compute the light projection and the world-to-light-proj-space matrices:</p>
<div class="fragment"><div class="line">float4x4 ShadowProjMatr = ScaleMatrix * ScaledBiasMatrix;</div>
<div class="line">float4x4 WorldToLightProjSpaceMatr = WorldToLightViewSpaceMatr * ShadowProjMatr;</div>
</div><!-- fragment --><p>The last step is to compute the world-to-shadow-map matrix that will be used in the shader to sample the shadow map. Note again that OpenGL is unlike other APIs, so we use <code>NDCAttribs</code> struct to handle the differences.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> NDCAttribs&amp; NDC = DevCaps.GetNDCAttribs();</div>
<div class="line">float4x4 ProjToUVScale = float4x4::Scale(0.5f, NDC.YtoVScale, NDC.ZtoDepthScale);</div>
<div class="line">float4x4 ProjToUVBias  = float4x4::Translation(0.5f, 0.5f, NDC.GetZtoDepthBias());</div>
<div class="line">m_WorldToShadowMapUVDepthMatr = WorldToLightProjSpaceMatr * ProjToUVScale * ProjToUVBias;</div>
</div><!-- fragment --><p>Finally we can render the cube into the shadow map using <code>WorldToLightProjSpaceMatr</code>:</p>
<div class="fragment"><div class="line">RenderCube(WorldToLightProjSpaceMatr, <span class="keyword">true</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md364"></a>
Using the Shadow Map in the shader</h2>
<p>Shadow map is bound to the SRB object like any other texture:</p>
<div class="fragment"><div class="line">m_PlaneSRB-&gt;GetVariableByName(SHADER_TYPE_PIXEL, <span class="stringliteral">&quot;g_ShadowMap&quot;</span>)-&gt;Set(m_ShadowMapSRV);</div>
</div><!-- fragment --><p>The vertex shader is pretty standard except for computing the shadow map position with <code>g_WorldToShadowMapUVDepth</code> matrix:</p>
<div class="fragment"><div class="line">float4 ShadowMapPos = mul(Pos[VertId], g_WorldToShadowMapUVDepth);</div>
<div class="line">PSIn.ShadowMapPos = ShadowMapPos.xyz / ShadowMapPos.w;</div>
</div><!-- fragment --><p>The fragment shader uses the shadow map position to sample the shadow map. Note that it uses <code>SampleCmp</code> method that performs 2x2 comparison filering of the shadow map to get smoother edges:</p>
<div class="fragment"><div class="line">Texture2D              g_ShadowMap;</div>
<div class="line">SamplerComparisonState g_ShadowMap_sampler;</div>
<div class="line"> </div>
<div class="line">struct PlanePSOutput</div>
<div class="line">{</div>
<div class="line">    float4 Color : SV_TARGET;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void main(in  PlanePSInput  PSIn,</div>
<div class="line">          out PlanePSOutput PSOut)</div>
<div class="line">{</div>
<div class="line">    float LightAmount = g_ShadowMap.SampleCmp(g_ShadowMap_sampler, PSIn.ShadowMapPos.xy,</div>
<div class="line">                                              max(PSIn.ShadowMapPos.z, 1e-7));</div>
<div class="line">    PSOut.Color.rgb = float3(1.0, 1.0, 1.0) * (PSIn.NdotL * LightAmount * 0.8 + 0.2);</div>
<div class="line">    PSOut.Color.a   = 1.0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
