<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial24 - Variable rate shading</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/db3/DiligentSamples_Tutorials_Tutorial24_VRS_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial24 - Variable rate shading</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates how to use variable rate shading to reduce the pixel shading load.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial24_VRS/Animation_Large.gif" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md430"></a>
VRS on desktop GPUs</h2>
<p>Variable rate shading implementations on mobile and desktop GPUs and in different APIs supported by <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine vary significantly. On desktop GPUs, variable rate shading is used to change the number of pixel shader invocations per small tile, which allows reducing the pixel shader load for areas that don't require high quality (e.g. areas that will be smoothed out by motion blur or depth-of-field, covered by UI, etc.). Direct3D12 and Vulkan support three VRS types that may be combined together: <em>per-draw</em>, <em>per-primitive</em>, and <em>texture-based</em> rates. They are described below.</p>
<h3><a class="anchor" id="autotoc_md431"></a>
Per-draw Shading Rate</h3>
<p>If <code>SHADING_RATE_CAP_FLAG_PER_DRAW</code> capability is supported, a uniform shading rate that will be applied throughout the entire render target may be set using the <code>IDeviceContext::SetShadingRate()</code> method. The <code>BaseRate</code> parameter must be one of the shading rates supported by the device. All supported rates are listed in <code>ShadingRateProperties::ShadingRates</code> member of the <code>GraphicsAdapterInfo</code> struct. <code>PrimitiveCombiner</code> and <code>TextureCombiner</code> parameters must be <code>SHADING_RATE_COMBINER_PASSTHROUGH</code>.</p>
<h3><a class="anchor" id="autotoc_md432"></a>
Per-primitive Shading Rate</h3>
<p>If <code>SHADING_RATE_CAP_FLAG_PER_PRIMITIVE</code> capability is supported, shading rate may be specified for each primitive by using a special vertex or geometry shader output, e.g.:</p>
<div class="fragment"><div class="line">nointerpolation uint Rate : SV_ShadingRate;</div>
</div><!-- fragment --><p>Per-primitive rate is combined with the base per-draw rate as specified by the <code>PrimitiveCombiner</code> parameter of the <code>IDeviceContext::SetShadingRate()</code> method. The combiner value must be one of the supported combiners in the <code>ShadingRateProperties::Combiners</code> bit field. The two most commonly used combiners are</p><ul>
<li><code>SHADING_RATE_COMBINER_PASSTHROUGH</code> that defines that per-primitive rate is ignored and the base rate is used instead, and</li>
<li><code>SHADING_RATE_COMBINER_OVERRIDE</code> that defines that per-primitive rate overrides the base rate.</li>
</ul>
<p>Other values specify how to combine per-draw base rate with the per-primitive rate.</p>
<h3><a class="anchor" id="autotoc_md433"></a>
Texture-based Shading Rate</h3>
<p>If <code>SHADING_RATE_CAP_FLAG_TEXTURE_BASED</code> capability is supported, shading rate may be defined using a special texture that for every pixel on the screen defines the rate. The texture-based rate is combined with the primitive rate, and is applied last. The combiner for the texture rate is defined by the <code>TextureCombiner</code> parameter of the <code>IDeviceContext::SetShadingRate()</code> method. The combiner value must be one of the supported combiners in the <code>ShadingRateProperties::Combiners</code> bit field. If <code>PrimitiveCombiner</code> is <code>SHADING_RATE_COMBINER_PASSTHROUGH</code> and <code>TextureCombiner</code> is <code>SHADING_RATE_COMBINER_OVERRIDE</code>, then only the texture shading rate will be used.</p>
<p>It is possible to use other parameters that define how all three rates are combined.</p>
<p>On desktop GPUs, VRS texture must be created as <code>RESOURCE_DIM_TEX_2D</code>, and use <code>BIND_SHADING_RATE</code> bind flag. Its format must be <code>TEX_FORMAT_R8_UINT</code> and the size must be less than the render target size divided by <code>ShadingRateProperties::MinTileSize</code>. The way texel values are interpreted depens on the value of <code>ShadingRateProperties::Format</code> device property. On desktop GPUs, this value is typically <code>SHADING_RATE_FORMAT_PALETTE</code>, which indicates that texels contain <code>SHADING_RATE</code> enum values. The texture content can be updated from the CPU or generated in a compute shader. Note that Direct3D12 forbids creating VRS textures with the render target bind flag, but in Vulkan this may be allowed depending on the implementation.</p>
<h3><a class="anchor" id="autotoc_md434"></a>
Combiners</h3>
<p>Shading rate combination algorithm is as follows:</p>
<div class="fragment"><div class="line">SHADING_RATE ApplyCombiner(SHADING_RATE_COMBINER Combiner, SHADING_RATE OriginalRate, SHADING_RATE NewRate)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (Combiner)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> SHADING_RATE_COMBINER_PASSTHROUGH: <span class="keywordflow">return</span> OriginalRate;</div>
<div class="line">        <span class="keywordflow">case</span> SHADING_RATE_COMBINER_OVERRIDE:    <span class="keywordflow">return</span> NewRate;</div>
<div class="line">        <span class="keywordflow">case</span> SHADING_RATE_COMBINER_MIN:         <span class="keywordflow">return</span> Min(OriginalRate, NewRate);</div>
<div class="line">        <span class="keywordflow">case</span> SHADING_RATE_COMBINER_MAX:         <span class="keywordflow">return</span> Max(OriginalRate, NewRate);</div>
<div class="line">        <span class="keywordflow">case</span> SHADING_RATE_COMBINER_SUM:         <span class="keywordflow">return</span> OriginalRate + NewRate;</div>
<div class="line">        <span class="keywordflow">case</span> SHADING_RATE_COMBINER_MUL:         <span class="keywordflow">return</span> OriginalRate * NewRate;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>IDeviceContext::SetShadingRate()</code> sets the <code>BaseRate</code> value.<br  />
 <code>SV_ShadingRate</code> output of a vertex or a geometry shader defines the <code>PerPrimitiveRate</code> value and it is combined with the per-draw rate:</p>
<p><code>PrimitiveRate = ApplyCombiner(PrimitiveCombiner, BaseRate, PerPrimitiveRate)</code></p>
<p>Next, the texel from the VRS texture is read to <code>TextureRate</code> and is combined with the primitive rate from the previous step:</p>
<p><code>FinalRate = ApplyCombiner(TextureCombiner, PrimitiveRate, TextureRate)</code></p>
<p>After that the GPU executes pixel shaders using the <code>FinalRate</code> value.</p>
<p><code>SHADING_RATE_1X1</code> means that pixel shader will be executed for all pixels in the tile. <code>SHADING_RATE_4X4</code> means that just one pixel shader per 4x4 pixel block will be executed. Other values define intermediate rates.</p>
<h2><a class="anchor" id="autotoc_md435"></a>
VRS on mobile GPUs</h2>
<p>On mobile GPUs, only texture-based VRS is supported. <code>ShadingRateProperties::Format</code> device property is <code>SHADING_RATE_FORMAT_UNORM8</code>, which means that VRS texture must be created with <code>RG8_UNORM</code> format, where R channel defines the pixel shader invocation rate along the X-axis, and G channel is the Y-axis rate. The value of 1.0 means that pixel shader will be executed for all pixels (<code>AXIS_SHADING_RATE_1X</code> counterpart), the value of 0.5 specifies that pixel shaders will be executed for every other pixel along the axis (<code>AXIS_SHADING_RATE_2X</code> counterpart) and so on.</p>
<p>If <code>SHADING_RATE_CAP_FLAG_TEXTURE_DEVICE_ACCESS</code> capability is present, the VRS texture content will be accessed on the GPU side. If you update VRS texture in a compute shader, the engine can implicitly synchronize access to the VRS texture if automatic state transitions are used. If the capability is not present, VRS texture is accessed on the CPU side when <code>IDeviceContext::SetRenderTargetsExt()</code> or <code>IDeviceContext::BeginRenderPass()</code> are called, and if VRS texture is updated on the GPU side, you need to explicitly synchronize access to the texture using fences and add double/triple buffering to avoid stalls.</p>
<p>Some GPUs will smooth out transitions between different shading rates, capability SHADING_RATE_CAP_FLAG_ADDITIONAL_INVOCATIONS indicates that.</p>
<h2><a class="anchor" id="autotoc_md436"></a>
VRS in Metal API</h2>
<p>Implementation of variable rate shading in Metal is very different compared to Direct3D12 and Vulkan, and requires special handling from the application:</p>
<ul>
<li>Unlike Direct3D12 and Vulkan where only pixel shader is executed at a lower rate, but rasterization is performed at the full resolution (in particular, depth testing is performed at full resolution), in Metal everything is downscaled. A 2x2 shading rate means that the entire tile is rasterized at 1/2x1/2 resolution, not just the pixel shader.</li>
<li>Only texture-based shading rate is supported.</li>
<li>Rasterization rate is not specified by a 2D texture. Instead, a special rasterization map is used that defines rasterization rates for columns and rows. A rasterization rate for the specific tile is given by the row and column where it is located. Rows and columns use a single float value in the range 0..1. <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> defines a special shading rate format <code>SHADING_RATE_FORMAT_COL_ROW_FP32</code> to indicate this kind of shading rate map. A <code>IRasterizationRateMapMtl</code> interface is used to work with the rasterization rate map in Metal. <img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial24_VRS/mtl_vrs.png" alt="" class="inline"/></li>
<li>A rasterization rate map is an immutable object and can't be updated. A new object has to be created to use different rates.</li>
<li>Rendering with VRS enabled is performed to a reduced-resolution texture, but viewport coordinates must be defined in final resolution.</li>
<li>A special resolve pass is required to upscale this texture to the full resolution.</li>
</ul>
<p>The code snippet below shows how a resolve pass may be implemented in Metal:</p>
<div class="fragment"><div class="line">fragment</div>
<div class="line">float4 PSmain(         VSOut                        in          [[stage_in]],   <span class="comment">// vertex shader generates a fullscreen triangle</span></div>
<div class="line">              constant rasterization_rate_map_data&amp; g_RRMData   [[buffer(0)]],  <span class="comment">// data copied from the rasterization rate map</span></div>
<div class="line">                       texture2d&lt;float&gt;             g_Texture   [[texture(0)]]) <span class="comment">// intermediate render target</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Sampler with pixel coordinates to access the texture</span></div>
<div class="line">    <span class="keyword">constexpr</span> sampler readSampler(coord::pixel, address::clamp_to_zero, filter::nearest);</div>
<div class="line"> </div>
<div class="line">    rasterization_rate_map_decoder Decoder(g_RRMData);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use screen coordinates in pixels</span></div>
<div class="line">    float2 uv = in.Pos.xy;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Convert from linear to non-linear coordinates</span></div>
<div class="line">    float2 ScreenPos = Decoder.map_screen_to_physical_coordinates(uv);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Resolve intermediate texture into full size texture</span></div>
<div class="line">    <span class="keywordflow">return</span> float4(g_Texture.sample(readSampler, ScreenPos));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md437"></a>
VRS API in Diligent Engine</h2>
<p>Variable rate shading feature must be enabled during the engine initialization:</p>
<div class="fragment"><div class="line">Attribs.EngineCI.Features.VariableRateShading = DEVICE_FEATURE_STATE_ENABLED;</div>
</div><!-- fragment --><p>A graphics PSO that will be used with VRS must set the appropriate <code>ShadingRateFlags</code> field in its description.<br  />
 A PSO that uses per-draw or per-primitive rates must be created with the <code>PIPELINE_SHADING_RATE_FLAG_PER_PRIMITIVE</code> flag.<br  />
 A PSO that using texture-based VRS must be created with the <code>PIPELINE_SHADING_RATE_FLAG_TEXTURE_BASED</code> flag. Note that combination of <code>PIPELINE_SHADING_RATE_FLAG_PER_PRIMITIVE</code> and <code>PIPELINE_SHADING_RATE_FLAG_TEXTURE_BASED</code> is valid but has no additional effect.</p>
<p>To begin texture-based shading rate, call <code>IDeviceContext::SetRenderTargetsExt()</code> that uses a <code>SetRenderTargetsAttribs</code> structure with <code>pShadingRateMap</code> field:</p>
<div class="fragment"><div class="line">ITextureView*           pRTVs[] = {m_pRTV};</div>
<div class="line">SetRenderTargetsAttribs RTAttrs;</div>
<div class="line">RTAttrs.<a class="code hl_variable" href="../../df/d65/structDiligent_1_1SetRenderTargetsAttribs.html#a9db960b240df50c3e5a0f41cb73437e3">NumRenderTargets</a>    = 1;</div>
<div class="line">RTAttrs.ppRenderTargets     = pRTVs;</div>
<div class="line">RTAttrs.pDepthStencil       = m_pDSV;</div>
<div class="line">RTAttrs.pShadingRateMap     = m_pShadingRateMap;</div>
<div class="line">m_pImmediateContext-&gt;SetRenderTargetsExt(RTAttrs);</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;SetShadingRate(SHADING_RATE_1X1, SHADING_RATE_COMBINER_PASSTHROUGH, SHADING_RATE_COMBINER_OVERRIDE);</div>
<div class="ttc" id="astructDiligent_1_1SetRenderTargetsAttribs_html_a9db960b240df50c3e5a0f41cb73437e3"><div class="ttname"><a href="../../df/d65/structDiligent_1_1SetRenderTargetsAttribs.html#a9db960b240df50c3e5a0f41cb73437e3">Diligent::SetRenderTargetsAttribs::NumRenderTargets</a></div><div class="ttdeci">Uint32 NumRenderTargets</div><div class="ttdoc">Number of render targets to bind.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:1166</div></div>
</div><!-- fragment --><p><code>IDeviceContext::SetShadingRate()</code> is required on desktop GPUs to enable VRS. The default values are given by <code>SetShadingRate(SHADING_RATE_1X1, SHADING_RATE_COMBINER_PASSTHROUGH, SHADING_RATE_COMBINER_PASSTHROUGH)</code>. In other implementations, VRS is always enabled when VRS texture is bound, but <code>SetShadingRate(SHADING_RATE_1X1, SHADING_RATE_COMBINER_PASSTHROUGH, SHADING_RATE_COMBINER_OVERRIDE)</code> can be used for compatibility. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
