<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Screen Space Ambient Occlusion</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('df/d46/DiligentFX_PostProcess_ScreenSpaceAmbientOcclusion_README.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Screen Space Ambient Occlusion</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><img src="https://github.com/DiligentGraphics/DiligentFX/raw/master/PostProcess/ScreenSpaceAmbientOcclusion/media/ssao-kitchen.jpg" alt="" class="inline"/></p>
<p>Kitchen scene rendered by <a href="https://github.com/DiligentGraphics/DiligentFX/tree/master/Hydrogent">Hydrogent</a> with Screen Space Ambient Occlusion effect applied.</p>
<h2><a class="anchor" id="autotoc_md165"></a>
Table of contents</h2>
<ul>
<li>Introduction</li>
<li>Integration guidelines<ul>
<li>Input resources</li>
<li>Host API</li>
</ul>
</li>
<li>Implementation details</li>
<li><a class="el" href="../../de/d6b/README.html#references">References</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md166"></a>
Introduction</h2>
<p>We needed to add screen space ambient occlusion to our project with the following requirements:</p><ul>
<li>Compatibility with WebGL</li>
<li><p class="startli">Use cosine-weighted AO and have the ability to use a large radius</p>
<p class="startli">We used Intel's implementation of Screen Space Occlusion as the basis for our implementation <a href="https://github.com/GameTechDev/XeGTAO"><b>[Intel-XeGTAO]</b></a></p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md167"></a>
Integration guidelines</h2>
<h3><a class="anchor" id="autotoc_md168"></a>
Input resources</h3>
<p>The following table enumerates all external inputs required by SSAO.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Name</b>   </th><th class="markdownTableHeadNone"><b>Format</b>   </th><th class="markdownTableHeadNone"><b>Notes</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Depth buffer   </td><td class="markdownTableBodyNone"><code>APPLICATION SPECIFIED (1x FLOAT)</code>   </td><td class="markdownTableBodyNone">The depth buffer for the current frame provided by the application. The data should be provided as a single floating point value, the precision of which is under the application's control.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Normal buffer   </td><td class="markdownTableBodyNone"><code>APPLICATION SPECIFIED (3x FLOAT)</code>   </td><td class="markdownTableBodyNone">The normal buffer for the current frame provided by the application in the [-1.0, +1.0] range. Normals should be in world space.   </td></tr>
</table>
<p>The effect uses a number of parameters to control the quality and performance of the effect organized into the <code>HLSL::ScreenSpaceAmbientOcclusionAttribs</code> structure. The following table lists the parameters and their descriptions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Name</b>   </th><th class="markdownTableHeadNone"><b>Notes</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Effect radius   </td><td class="markdownTableBodyNone">World-space ambient occlusion radius.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Effect falloff range   </td><td class="markdownTableBodyNone">Gently reduces sample impact as it gets out of the 'Effect radius' bounds.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Radius multiplier   </td><td class="markdownTableBodyNone">Use different value as compared to the ground truth radius to counter inherent screen space biases.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Depth MIP sampling offset   </td><td class="markdownTableBodyNone">Controls the main trade-off between performance (memory bandwidth) and quality (temporal stability is the first affected, thin objects next).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Temporal stability factor   </td><td class="markdownTableBodyNone">The value is responsible for interpolating between the current and previous frame.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Spatial reconstruction radius   </td><td class="markdownTableBodyNone">Controls the kernel size in the spatial reconstruction step. Increasing the value increases the deviation from the ground truth but reduces the noise.   </td></tr>
</table>
<p>The effect can be configured using the <code>ScreenSpaceAmbientOcclusion::FEATURE_FLAGS</code> enumeration. The following table lists the flags and their descriptions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Name</b>   </th><th class="markdownTableHeadNone"><b>Notes</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>FEATURE_FLAG_HALF_PRECISION_DEPTH</code>   </td><td class="markdownTableBodyNone">Use half-precision fixed-point format for depth values in the SSAO computation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>FEATURE_FLAG_HALF_RESOLUTION</code>   </td><td class="markdownTableBodyNone">Compute SSAO at half resolution of the target render texture    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>FEATURE_FLAG_UNIFORM_WEIGHTING</code>   </td><td class="markdownTableBodyNone">By default, we compute AO using the GTAO algorithm. This flag enables the computation of AO using the HBAO algorithm   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md169"></a>
Host API</h3>
<p>To integrate SSAO into your project, include the following necessary header files: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;PostFXContext.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../dd/d47/ScreenSpaceAmbientOcclusion_8hpp.html">ScreenSpaceAmbientOcclusion.hpp</a>&quot;</span></div>
<div class="ttc" id="aScreenSpaceAmbientOcclusion_8hpp_html"><div class="ttname"><a href="../../dd/d47/ScreenSpaceAmbientOcclusion_8hpp.html">ScreenSpaceAmbientOcclusion.hpp</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">namespace </span>HLSL</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#include &quot;Shaders/Common/public/BasicStructures.fxh&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Shaders/PostProcess/ScreenSpaceAmbientOcclusion/public/ScreenSpaceAmbientOcclusionStructures.fxh&quot;</span></div>
<div class="line">} <span class="comment">// namespace HLSL</span></div>
</div><!-- fragment --><p>Now, create the necessary objects: </p><div class="fragment"><div class="line">m_PostFXContext = std::make_unique&lt;PostFXContext&gt;(m_pDevice);</div>
<div class="line">m_SSAO          = std::make_unique&lt;ScreenSpaceAmbientOcclusion&gt;(m_pDevice);</div>
</div><!-- fragment --><p>Next, call the methods to prepare resources for the <code>PostFXContext</code> and <code>ScreenSpaceAmbientOcclusion</code> objects. This needs to be done every frame before starting the rendering process. </p><div class="fragment"><div class="line">{</div>
<div class="line">    PostFXContext::FrameDesc FrameDesc;</div>
<div class="line">    FrameDesc.Index  = m_CurrentFrameNumber; <span class="comment">// Current frame number.</span></div>
<div class="line">    FrameDesc.Width  = SCDesc.Width;         <span class="comment">// Current screen width.</span></div>
<div class="line">    FrameDesc.Height = SCDesc.Height;        <span class="comment">// Current screen height.</span></div>
<div class="line">    m_PostFXContext-&gt;PrepareResources(m_pDevice, FrameDesc, PostFXContext::FEATURE_FLAG_NONE);</div>
<div class="line"> </div>
<div class="line">    ScreenSpaceAmbientOcclusion::FEATURE_FLAGS ActiveFeatures = ...;</div>
<div class="line">    m_ScreenSpaceAmbientOcclusion-&gt;PrepareResources(m_pDevice, m_pImmediateContext, m_PostFXContext.get(), ActiveFeatures);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we invoke the method <code>PostFXContext::Execute</code>. At this stage, some intermediate resources necessary for all post-processing objects dependent on <code>PostFXContext</code> are calculated. This method can take a constant buffer directly containing an array from the current and previous cameras (for this method, you can refer to this section of the code [<a href="https://github.com/DiligentGraphics/DiligentSamples/raw/380b0a05b6c72d80fd6d574d7343ead77d6dd7eb/Tutorials/Tutorial27_PostProcessing/src/Tutorial27_PostProcessing.cpp#L164">0</a>] and [<a href="https://github.com/DiligentGraphics/DiligentSamples/raw/380b0a05b6c72d80fd6d574d7343ead77d6dd7eb/Tutorials/Tutorial27_PostProcessing/src/Tutorial27_PostProcessing.cpp#L228">1</a>]). Alternatively, you can pass the corresponding pointers <code>const HLSL::CameraAttribs* pCurrCamera</code> and <code>const HLSL::CameraAttribs* pPrevCamera</code> for the current and previous cameras, respectively. You also need to pass the depth of the current and previous frames (the depth buffers should not contain transparent objects), and a buffer with motion vectors in NDC space, into the corresponding <code>ITextureView* pCurrDepthBufferSRV</code>, <code>ITextureView* pPrevDepthBufferSRV</code>, <code>ITextureView* pMotionVectorsSRV</code> pointers.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    PostFXContext::RenderAttributes PostFXAttibs;</div>
<div class="line">    PostFXAttibs.pDevice             = m_pDevice;</div>
<div class="line">    PostFXAttibs.pDeviceContext      = m_pImmediateContext;</div>
<div class="line">    PostFXAttibs.pCameraAttribsCB    = m_FrameAttribsCB;  <span class="comment">// m_Resources[RESOURCE_IDENTIFIER_CAMERA_CONSTANT_BUFFER].AsBuffer();</span></div>
<div class="line">    PostFXAttibs.pCurrDepthBufferSRV = m_CurrDepthBuffer; <span class="comment">// m_Resources[RESOURCE_IDENTIFIER_DEPTH0 + CurrFrameIdx].GetTextureSRV();</span></div>
<div class="line">    PostFXAttibs.pPrevDepthBufferSRV = m_PrevDepthBuffer; <span class="comment">// m_Resources[RESOURCE_IDENTIFIER_DEPTH0 + PrevFrameIdx].GetTextureSRV();</span></div>
<div class="line">    PostFXAttibs.pMotionVectorsSRV   = m_MotionBuffer;    <span class="comment">// m_GBuffer-&gt;GetBuffer(GBUFFER_RT_MOTION_VECTORS)-&gt;GetDefaultView(TEXTURE_VIEW_SHADER_RESOURCE);</span></div>
<div class="line">    m_PostFXContext-&gt;Execute(PostFXAttibs);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we need to directly invoke calculation of SSAO. To do this, we call the <code>ScreenSpaceAmbientOcclusion::Execute</code> method. Before this, we need to fill the passed structures <code>ScreenSpaceAmbientOcclusionAttribs</code> and <code>ScreenSpaceAmbientOcclusion::RenderAttributes</code> with the necessary data. Refer to the Input resources section for parameter description. </p><div class="fragment"><div class="line">{</div>
<div class="line">    HLSL::ScreenSpaceAmbientOcclusionAttribs SSAOSettings{};</div>
<div class="line"> </div>
<div class="line">    ScreenSpaceAmbientOcclusion::RenderAttributes SSAORenderAttribs{};</div>
<div class="line">    SSAORenderAttribs.pDevice          = m_pDevice;</div>
<div class="line">    SSAORenderAttribs.pDeviceContext   = m_pImmediateContext;</div>
<div class="line">    SSAORenderAttribs.pPostFXContext   = m_PostFXContext.get();</div>
<div class="line">    SSAORenderAttribs.pDepthBufferSRV  = m_CurrDepthBuffer; <span class="comment">// m_Resources[RESOURCE_IDENTIFIER_DEPTH0 + CurrFrameIdx].GetTextureSRV();</span></div>
<div class="line">    SSAORenderAttribs.pNormalBufferSRV = m_NormalBuffer;    <span class="comment">// m_GBuffer-&gt;GetBuffer(GBUFFER_RT_NORMAL)-&gt;GetDefaultView(TEXTURE_VIEW_SHADER_RESOURCE);</span></div>
<div class="line">    SSAORenderAttribs.pSSAOAttribs     = &amp;SSAOSettings;</div>
<div class="line">    m_SSAO-&gt;Execute(SSAORenderAttribs);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, you can directly obtain a <code>ITextureView</code> on the texture containing the SSAO result using the method <code>ScreenSpaceAmbientOcclusion::GetAmbientOcclusionSRV</code>. After this, you can apply SSAO in your rendering pipeline using the formula below.</p>
<div class="fragment"><div class="line">\large \text{DiffuseRadiance} = \sum_{i=1}^{n} (1 - F) \times \text{Diffuse} \times \text{SSAO} \times \text{IrradianceMap}_i</div>
</div><!-- fragment --><p>The parameter $F$ is the Fresnel Schlick coefficient. You can use the approximation <code>FresnelSchlickWithRoughness</code> from this article <a href="https://seblagarde.wordpress.com/2011/08/17/hello-world/"><b>[Sébastien Lagarde, Adopting a physically based shading model]</b></a></p>
<h2><a class="anchor" id="autotoc_md170"></a>
Implementation details</h2>
<p>As we mentioned earlier, we use the <a href="https://github.com/GameTechDev/XeGTAO"><b>[Intel-XeGTAO]</b></a> implementation as a starting point for our algorithm. For a deeper understanding of the context and nuances involved, it is recommended to review the documentation available in the implementation's repository.</p>
<p>Modifications made from the original algorithm version include:</p><ul>
<li>Unfortunately, we cannot use compute shaders for calculating prefiltered mip levels of the depth map, so we use pixel shaders for convolving the depth map, thus we loose a bit in performance.</li>
<li>Currently, the computation of bent-normals is not implemented. However, we are considering incorporating this feature in future updates.</li>
<li>We have added the capability to compute Ambient Occlusion at half resolution. This is achieved by downsampling the depth buffer using a checkerboard pattern, effectively reducing it by half. For additional details on this process, the <a href="https://eleni.mutantstargoat.com/hikiko/depth-aware-upsampling-2/"><b>[DAW-Upsampling]</b></a> technique provides comprehensive insights.</li>
<li>The denoiser from XeGTAO is ineffective with larger AO radii, necessitating the development of a more sophisticated denoiser based on the ReBLUR algorithm. To grasp a better understanding of the underlying principles and our approach, reviewing related presentations is advised <a href="https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9985-exploring-ray-traced-future-in-metro-exodus.pdf"><b>[RTAO, 2019]</b></a>, <a href="https://developer.download.nvidia.com/video/gputechconf/gtc/2020/presentations/s22699-fast-denoising-with-self-stabilizing-recurrent-blurs.pdf"><b>[ReBLUR, 2020]</b></a>, <a href="https://link.springer.com/chapter/10.1007/978-1-4842-7185-8_49#preview"><b>[ReBLUR, 2021]</b></a>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md171"></a>
References</h2>
<ul>
<li><b>[Intel-XeGTAO]</b>: An implementation of [Jimenez et al., 2016] Ground Truth Ambient Occlusion, MIT license - <a href="https://github.com/GameTechDev/XeGTAO">https://github.com/GameTechDev/XeGTAO</a></li>
<li><b>[Jimenez et al., 2016]</b>: GTAO, Practical Realtime Strategies for Accurate Indirect Occlusion, Jimenez et al., 2016 - <a href="https://blog.selfshadow.com/publications/s2016-shading-course/activision/s2016_pbs_activision_occlusion.pdf">https://blog.selfshadow.com/publications/s2016-shading-course/activision/s2016_pbs_activision_occlusion.pdf</a></li>
<li><b>[RTAO, 2019]</b>: Exploring the Ray Traced Future in 'Metro Exodus' - <a href="https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9985-exploring-ray-traced-future-in-metro-exodus.pdf">https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9985-exploring-ray-traced-future-in-metro-exodus.pdf</a></li>
<li><b>[ReBLUR, 2020]</b>: Fast Denoising with Self Stabilizing Recurrent Blurs - <a href="https://developer.download.nvidia.com/video/gputechconf/gtc/2020/presentations/s22699-fast-denoising-with-self-stabilizing-recurrent-blurs.pdf">https://developer.download.nvidia.com/video/gputechconf/gtc/2020/presentations/s22699-fast-denoising-with-self-stabilizing-recurrent-blurs.pdf</a></li>
<li><b>[ReBLUR, 2021]</b>: ReBLUR: A Hierarchical Recurrent Denoiser - <a href="https://link.springer.com/chapter/10.1007/978-1-4842-7185-8_49#preview">https://link.springer.com/chapter/10.1007/978-1-4842-7185-8_49#preview</a></li>
<li><b>[DAW-Upsampling]</b>: Depth-aware upsampling experiments, Eleni Maria Stea - <a href="https://eleni.mutantstargoat.com/hikiko/depth-aware-upsampling-2/">https://eleni.mutantstargoat.com/hikiko/depth-aware-upsampling-2/</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
