<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial20 - Mesh shader</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d7/d45/DiligentSamples_Tutorials_Tutorial20_MeshShader_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial20 - Mesh shader</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates how to use amplification and mesh shaders, the new programmable stages, to implement view frustum culling and object LOD calculation on the GPU.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial20_MeshShader/Animation_Large.gif" alt="" class="inline"/></p>
<p>Mesh shader pipeline is designed to replace the traditional primitive generation pipeline that consists of vertex attribute fetch stage, vertex shader, tessellation and geometry shader, with a new fully programmable pipeline that is much more efficient and flexibile. The new pipeline consists of two new programmable stages - the mesh shader itself, which in its simplest form implements the functionality of the vertex shader, but is much more powerful, and an optional amplification (or task) shader stage. The amplification shader adds an extra indirection level. It can generate up to 65k mesh shader invocations and can be used for culling, level-of-details (LOD) selection, etc.</p>
<p>Mesh shaders are supported in DirectX 12.2 and are an extension in Vulkan.</p>
<p>In this tutorial, we will use amplification shader stage to perform view-frustum culling and LOD selection. The mesh shader will be responsible for computing vertex positions and generating primitives. Note that for the sake of simplicity in this tutorial we do not change the geometry based on the LOD, but only output it as a color.</p>
<h2><a class="anchor" id="autotoc_md397"></a>
Amplification shader</h2>
<p>As we discussed above, amplification shader is the first new programmable stage and will be doing frustum culling and LOD selection. The shader looks like a compute shader and executes 32 threads per group:</p>
<div class="fragment"><div class="line">#define GROUP_SIZE 32</div>
<div class="line"> </div>
<div class="line">[numthreads(GROUP_SIZE,1,1)]</div>
<div class="line">void main(in uint I  : SV_GroupIndex,</div>
<div class="line">          in uint wg : SV_GroupID)</div>
<div class="line">{</div>
</div><!-- fragment --><p>Because mesh and amplification shaders don't have any built-in input attributes except for thread ID and group ID, we use structured buffer to pass draw commands down to them. A real application will likely use at least transformation, mesh ID and material ID for each object. In this tutorial for simplicity we will only provide the cube position in a 2D grid (<code>BasePos</code>), its scale (<code>Scale</code>), and time offset (<code>TimeOffset</code>) that is used by the shader for animation:</p>
<div class="fragment"><div class="line">struct DrawTask</div>
<div class="line">{</div>
<div class="line">    float2 BasePos;</div>
<div class="line">    float  Scale;</div>
<div class="line">    float  TimeOffset;</div>
<div class="line">};</div>
<div class="line">StructuredBuffer&lt;DrawTask&gt; DrawTasks;</div>
</div><!-- fragment --><p>The shader will need to use some global data: a view matrix and cotangent of the half FOV of the camera to calculate the cube detail level (LOD); six frustum planes for frustum culling; elapsed time to animate cube positions. This information is stored in a regular constant buffer:</p>
<div class="fragment"><div class="line">struct Constants</div>
<div class="line">{</div>
<div class="line">    float4x4 ViewMat;</div>
<div class="line">    float4x4 ViewProjMat;</div>
<div class="line">    float4   Frustum[6];</div>
<div class="line">    float    CoTanHalfFov;</div>
<div class="line">    float    ElapsedTime;</div>
<div class="line">    uint     FrustumCulling;</div>
<div class="line">    uint     Padding;</div>
<div class="line">};</div>
<div class="line">cbuffer cbConstants</div>
<div class="line">{</div>
<div class="line">    Constants g_Constants;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Another piece of information that the amplification shader will use is the cube geometry, which is provided through another constant buffer. The shader only needs the radius of the circumscribed sphere, which it will use for frustum culling:</p>
<div class="fragment"><div class="line">struct CubeData</div>
<div class="line">{</div>
<div class="line">    float4 SphereRadius;</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line">cbuffer cbCubeData</div>
<div class="line">{</div>
<div class="line">    CubeData g_CubeData;</div>
<div class="line">}</div>
</div><!-- fragment --><p>An RW-buffer <code>Statistics</code> is used to count the number of visible cubes after the frustum culling. The value is not used in the shaders, but is read back on the CPU to show the counter in the UI:</p>
<div class="fragment"><div class="line">RWByteAddressBuffer Statistics;</div>
</div><!-- fragment --><p>The data that the amplification shader invocations will be working on (vertex positions, scale, LOD) is stored in a shared memory. Each thread in the group will work on its own element:</p>
<div class="fragment"><div class="line">struct Payload</div>
<div class="line">{</div>
<div class="line">    float PosX[GROUP_SIZE];</div>
<div class="line">    float PosY[GROUP_SIZE];</div>
<div class="line">    float PosZ[GROUP_SIZE];</div>
<div class="line">    float Scale[GROUP_SIZE];</div>
<div class="line">    float LODs[GROUP_SIZE];</div>
<div class="line">};</div>
<div class="line">groupshared Payload s_Payload;</div>
</div><!-- fragment --><p>To get a unique index in each thread, we will use the <code>s_TaskCount</code> shared variable. At the start of the shader we reset the counter to zero. We only write the value from the first thread in the group to avoid data races and then issue a barrier to make the value visible to other threads and make sure that all threads are at the same step.</p>
<div class="fragment"><div class="line">groupshared uint s_TaskCount;</div>
<div class="line"> </div>
<div class="line">[numthreads(GROUP_SIZE,1,1)]</div>
<div class="line">void main(in uint I : SV_GroupIndex,</div>
<div class="line">          in uint wg : SV_GroupID)</div>
<div class="line">{</div>
<div class="line">    // Reset the counter from the first thread in the group</div>
<div class="line">    if (I == 0)</div>
<div class="line">    {</div>
<div class="line">        s_TaskCount = 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Flush the cache and synchronize</div>
<div class="line">    GroupMemoryBarrierWithGroupSync();</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>The shader reads the thread-specific values and computes the position of the object using its draw task arguments. The <code>gid</code> is the global index of the draw task data.</p>
<div class="fragment"><div class="line">const uint gid   = wg * GROUP_SIZE + I;</div>
<div class="line">DrawTask   task  = DrawTasks[gid];</div>
<div class="line">float3     pos   = float3(task.BasePos, 0.0).xzy;</div>
<div class="line">float      scale = task.Scale;</div>
<div class="line">float      timeOffset  = task.TimeOffset;</div>
<div class="line"> </div>
<div class="line">// Simple animation</div>
<div class="line">pos.y = sin(g_Constants.CurrTime + timeOffset);</div>
</div><!-- fragment --><p>It then performs frustum culling using the object position and if the object is visible, atomically increments the shared <code>s_TaskCount</code> value and computes the LOD. The <code>index</code> variable returned by <code>InterlockedAdd</code> stores the index to access the arrays in the payload. The index is guaranteed to be unique for all threads, so that they will all be working on different array elements:</p>
<div class="fragment"><div class="line">if (g_Constants.FrustumCulling == 0 || IsVisible(pos, g_CubeData.SphereRadius.x * scale))</div>
<div class="line">{</div>
<div class="line">    uint index = 0;</div>
<div class="line">    InterlockedAdd(s_TaskCount, 1, index);</div>
<div class="line">    </div>
<div class="line">    s_Payload.PosX[index]  = pos.x;</div>
<div class="line">    s_Payload.PosY[index]  = pos.y;</div>
<div class="line">    s_Payload.PosZ[index]  = pos.z;</div>
<div class="line">    s_Payload.Scale[index] = scale;</div>
<div class="line">    s_Payload.LODs[index]  = CalcDetailLevel(pos, g_CubeData.SphereRadius.x * scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>IsVisible()</code> function calculates the signed distance from each frustum plane to the sphere and computes its visibility by comparing the distances to the sphere radius.</p>
<p>The LOD calculation (<code>CalcDetailLevel</code> function) is based on computing the object bounding sphere radius in screen space. For detailed description of the algorithm, see the link in Further Reading.</p>
<p>After the payload has been written, we need to issue another barrier to wait until all threads reach the same point. After that we can safely read the <code>s_TaskCount</code> value. The first thread in the group atomically adds this value to the global <code>Statistics</code> counter. Note that this is much faster than incrementing the counter from each thread because it minimizes the access to global memory.</p>
<p>The final step of the amplification shader is calling the <code>DispatchMesh()</code> function with the number of groups and the payload that will spawn an s_TaskCount mesh shader invocations. For compatibility with Vulkan API you should only use the X group count. The <code>DispatchMesh()</code> function must be called exactly once per amplification shader. The <code>DispatchMesh()</code> call implies a <code>GroupMemoryBarrierWithGroupSync()</code>, and ends the amplification shader group's execution.</p>
<div class="fragment"><div class="line">GroupMemoryBarrierWithGroupSync();</div>
<div class="line"> </div>
<div class="line">if (I == 0)</div>
<div class="line">{</div>
<div class="line">    // Update statistics from the first thread</div>
<div class="line">    uint orig_value;</div>
<div class="line">    Statistics.InterlockedAdd(0, s_TaskCount, orig_value);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">DispatchMesh(s_TaskCount, 1, 1, s_Payload);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md398"></a>
Mesh shader</h2>
<p>Recall that the purpose of the mesh shader in this tutorial is to compute the vertex positions, very much like vertex shader in a traditional pipeline, and also to output primitives. Unlike vertex shader though, mesh shader invocations run in compute groups very much like compute shaders and can share the data between threads.</p>
<p>We will use 24 threads out of the 32 maximum threads available. We will produce 24 vertices and 12 primitives with 36 indices. <code>SV_GroupIndex</code> indicates the mesh shader invocation index (0 to 23 in our case). <code>SV_GroupID</code> indicates the amplification shader output (0 to <code>s_TaskCount-1</code>).</p>
<div class="fragment"><div class="line">[numthreads(24,1,1)]</div>
<div class="line">[outputtopology(&quot;triangle&quot;)]</div>
<div class="line">void main(in uint I   : SV_GroupIndex,</div>
<div class="line">          in uint gid : SV_GroupID,</div>
<div class="line">          in  payload  Payload  payload,</div>
<div class="line">          out indices  uint3    tris[12],</div>
<div class="line">          out vertices PSInput  verts[24])</div>
<div class="line">{</div>
<div class="line">    // Only the input values from the the first active thread are used.</div>
<div class="line">    SetMeshOutputCounts(24, 12);</div>
</div><!-- fragment --><p>We read the amplification shader output using the group id (<code>gid</code>):</p>
<div class="fragment"><div class="line">float3 pos;</div>
<div class="line">float  scale = payload.Scale[gid];</div>
<div class="line">float  LOD   = payload.LODs[gid];</div>
<div class="line">pos.x = payload.PosX[gid];</div>
<div class="line">pos.y = payload.PosY[gid];</div>
<div class="line">pos.z = payload.PosZ[gid];</div>
</div><!-- fragment --><p>The mesh shader uses the same cube constant buffer as the amplification shader, but it also uses the cube vertex attributes and indices. Each mesh shader thread works on only one output vertex identified by the group index <code>I</code>. Much like regular vertex shader, it transforms the vertex using the view-projection matrix:</p>
<div class="fragment"><div class="line">verts[I].Pos = mul(float4(pos + g_CubeData.Positions[I].xyz * scale, 1.0), g_CubeData.ViewProjMat);</div>
<div class="line">verts[I].UV  = g_CubeData.UVs[I].xy;</div>
</div><!-- fragment --><p>As we mentioned earlier, LOD doesn't affect the vertex count, and we simply display it as color:</p>
<div class="fragment"><div class="line">float4 Rainbow(float factor)</div>
<div class="line">{</div>
<div class="line">    float  h   = factor / 1.35;</div>
<div class="line">    float3 col = float3(abs(h * 6.0 - 3.0) - 1.0, 2.0 - abs(h * 6.0 - 2.0), 2.0 - abs(h * 6.0 - 4.0));</div>
<div class="line">    return float4(clamp(col, float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0)), 1.0);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">verts[I].Color = Rainbow(LOD);</div>
</div><!-- fragment --><p>Finally, we output primitives (the 6 cube faces consisting of 12 triangles total). Only the first 12 threads write the indices. Note that we must not access the array outside of its bounds.</p>
<div class="fragment"><div class="line">if (I &lt; 12)</div>
<div class="line">{</div>
<div class="line">    tris[I] = g_CubeData.Indices[I].xyz;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md399"></a>
Preparing the cube data</h2>
<p>In this tutorial the cube data is arranged differently compared to the previous ones - we don’t have separate vertex and index buffers, the mesh shader reads the data from the buffer directly. We keep all data in a constant buffer because we only have one small mesh. However, a real application should use a structured or an unordered access buffer. All elements in the array in the constant buffer must be 16-byte aligned.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CubeData</div>
<div class="line">{</div>
<div class="line">    float4 sphereRadius;</div>
<div class="line">    float4 pos[24];</div>
<div class="line">    float4 uv[24];</div>
<div class="line">    uint4  indices[36 / 3];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> float4 CubePos[] =</div>
<div class="line">{</div>
<div class="line">    float4(-1,-1,-1,0), float4(-1,+1,-1,0), float4(+1,+1,-1,0), float4(+1,-1,-1,0),</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> float4 CubeUV[] = </div>
<div class="line">{</div>
<div class="line">    float4(0,1,0,0), float4(0,0,0,0), float4(1,0,0,0), float4(1,1,0,0),</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> uint4 Indices[] =</div>
<div class="line">{</div>
<div class="line">    uint4{2,0,1,0},    uint4{2,3,0,0},</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">CubeData Data;</div>
<div class="line">Data.sphereRadius = float4{length(CubePos[0] - CubePos[1]) * std::sqrt(3.0f) * 0.5f, 0, 0, 0};</div>
<div class="line">std::memcpy(Data.pos, CubePos, <span class="keyword">sizeof</span>(CubePos));</div>
<div class="line">std::memcpy(Data.uv, CubeUV, <span class="keyword">sizeof</span>(CubeUV));</div>
<div class="line">std::memcpy(Data.indices, Indices, <span class="keyword">sizeof</span>(Indices));</div>
<div class="line"> </div>
<div class="line">BufferDesc BuffDesc;</div>
<div class="line">BuffDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>      = <span class="stringliteral">&quot;Cube vertex &amp; index buffer&quot;</span>;</div>
<div class="line">BuffDesc.Usage     = <a class="code hl_enumvalue" href="../../d7/dca/namespaceDiligent.html#adbe6103a040fe9a9d9c4e5166c3773caaa97b30d53fad8dcf78770eb3feeeb316">USAGE_IMMUTABLE</a>;</div>
<div class="line">BuffDesc.BindFlags = <a class="code hl_enumvalue" href="../../d7/dca/namespaceDiligent.html#af2f0c1dfb8f93a9ef6444b0cdd64203cac2120e5b46a9b5611f937fb446d099f9">BIND_UNIFORM_BUFFER</a>;</div>
<div class="line">BuffDesc.Size      = <span class="keyword">sizeof</span>(Data);</div>
<div class="line"> </div>
<div class="line">BufferData BufData;</div>
<div class="line">BufData.<a class="code hl_variable" href="../../d2/d3c/structDiligent_1_1BufferData.html#a26cc7ca53f891a63ed1846e27b8e50d8">pData</a>    = &amp;Data;</div>
<div class="line">BufData.DataSize = <span class="keyword">sizeof</span>(Data);</div>
<div class="line"> </div>
<div class="line">m_pDevice-&gt;CreateBuffer(BuffDesc, &amp;BufData, &amp;m_CubeBuffer);</div>
<div class="ttc" id="anamespaceDiligent_html_adbe6103a040fe9a9d9c4e5166c3773caaa97b30d53fad8dcf78770eb3feeeb316"><div class="ttname"><a href="../../d7/dca/namespaceDiligent.html#adbe6103a040fe9a9d9c4e5166c3773caaa97b30d53fad8dcf78770eb3feeeb316">Diligent::USAGE_IMMUTABLE</a></div><div class="ttdeci">@ USAGE_IMMUTABLE</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:190</div></div>
<div class="ttc" id="anamespaceDiligent_html_af2f0c1dfb8f93a9ef6444b0cdd64203cac2120e5b46a9b5611f937fb446d099f9"><div class="ttname"><a href="../../d7/dca/namespaceDiligent.html#af2f0c1dfb8f93a9ef6444b0cdd64203cac2120e5b46a9b5611f937fb446d099f9">Diligent::BIND_UNIFORM_BUFFER</a></div><div class="ttdeci">@ BIND_UNIFORM_BUFFER</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:142</div></div>
<div class="ttc" id="astructDiligent_1_1BufferData_html_a26cc7ca53f891a63ed1846e27b8e50d8"><div class="ttname"><a href="../../d2/d3c/structDiligent_1_1BufferData.html#a26cc7ca53f891a63ed1846e27b8e50d8">Diligent::BufferData::pData</a></div><div class="ttdeci">const void * pData</div><div class="ttdoc">Pointer to the data.</div><div class="ttdef"><b>Definition</b> Buffer.h:188</div></div>
<div class="ttc" id="astructDiligent_1_1DeviceObjectAttribs_html_a14a31dc6ad69e0b79514e5349e9b4fc0"><div class="ttname"><a href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Diligent::DeviceObjectAttribs::Name</a></div><div class="ttdeci">const Char * Name</div><div class="ttdoc">Object name.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1319</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md400"></a>
Initializing the Pipeline State</h2>
<p>The initialization of amplification and mesh shaders is largely identical to initialization of shaders of other types. The only difference is the new shader types (<code>SHADER_TYPE_AMPLIFICATION</code> and <code>SHADER_TYPE_MESH</code>). Similar is true for pipeline state initialization. Notice also the new <code>PIPELINE_TYPE_MESH</code> pipeline type. Some fields of the <code>GraphicsPipeline</code> struct like <code>LayoutElements</code> and <code>PrimitiveTopology</code> are irrelevant for mesh shaders and are ignored. The mesh shader pipeline state uses the same pixel shader stage as the traditional vertex pipeline.</p>
<div class="fragment"><div class="line">PSODesc.PipelineType = PIPELINE_TYPE_MESH;</div>
<div class="line"> </div>
<div class="line">RefCntAutoPtr&lt;IShader&gt; pAS;</div>
<div class="line">{</div>
<div class="line">    ShaderCI.Desc.ShaderType = SHADER_TYPE_AMPLIFICATION;</div>
<div class="line">    ShaderCI.EntryPoint      = <span class="stringliteral">&quot;main&quot;</span>;</div>
<div class="line">    ShaderCI.Desc.Name       = <span class="stringliteral">&quot;Mesh shader - AS&quot;</span>;</div>
<div class="line">    ShaderCI.FilePath        = <span class="stringliteral">&quot;cube.ash&quot;</span>;</div>
<div class="line">    m_pDevice-&gt;CreateShader(ShaderCI, &amp;pAS);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">RefCntAutoPtr&lt;IShader&gt; pMS;</div>
<div class="line">{</div>
<div class="line">    ShaderCI.Desc.ShaderType = SHADER_TYPE_MESH;</div>
<div class="line">    ShaderCI.EntryPoint      = <span class="stringliteral">&quot;main&quot;</span>;</div>
<div class="line">    ShaderCI.Desc.Name       = <span class="stringliteral">&quot;Mesh shader - MS&quot;</span>;</div>
<div class="line">    ShaderCI.FilePath        = <span class="stringliteral">&quot;cube.msh&quot;</span>;</div>
<div class="line">    m_pDevice-&gt;CreateShader(ShaderCI, &amp;pMS);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">RefCntAutoPtr&lt;IShader&gt; pPS;</div>
<div class="line">{</div>
<div class="line">    ShaderCI.Desc.ShaderType = SHADER_TYPE_PIXEL;</div>
<div class="line">    ShaderCI.EntryPoint      = <span class="stringliteral">&quot;main&quot;</span>;</div>
<div class="line">    ShaderCI.Desc.Name       = <span class="stringliteral">&quot;Mesh shader - PS&quot;</span>;</div>
<div class="line">    ShaderCI.FilePath        = <span class="stringliteral">&quot;cube.psh&quot;</span>;</div>
<div class="line">    m_pDevice-&gt;CreateShader(ShaderCI, &amp;pPS);</div>
<div class="line">}</div>
<div class="line">    </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">PSOCreateInfo.pAS = pAS;</div>
<div class="line">PSOCreateInfo.pMS = pMS;</div>
<div class="line">PSOCreateInfo.pPS = pPS;</div>
<div class="line">m_pDevice-&gt;CreateGraphicsPipelineState(PSOCreateInfo, &amp;m_pPSO);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md401"></a>
Draw task data initialization</h2>
<p>As we discussed earlier, amplification shaders read their arguments from the structured buffer. We initialize the draw tasks data by distributing the cubes on a 2D grid and generating random scales and animation time offsets:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DrawTask</div>
<div class="line">{</div>
<div class="line">    float2 BasePos;</div>
<div class="line">    <span class="keywordtype">float</span>  Scale;</div>
<div class="line">    <span class="keywordtype">float</span>  TimeOffset;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> int2          GridDim{128, 128};</div>
<div class="line">FastRandReal&lt;float&gt; Rnd{0, 0.f, 1.f};</div>
<div class="line"> </div>
<div class="line">std::vector&lt;DrawTask&gt; DrawTasks;</div>
<div class="line">DrawTasks.resize(GridDim.x * GridDim.y);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; GridDim.y; ++y)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; GridDim.x; ++x)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span>       idx = x + y * GridDim.x;</div>
<div class="line">        DrawTask&amp; dst = DrawTasks[idx];</div>
<div class="line"> </div>
<div class="line">        dst.BasePos.x  = (x - GridDim.x / 2) * 4.f + (Rnd() * 2.f - 1.f);</div>
<div class="line">        dst.BasePos.y  = (y - GridDim.y / 2) * 4.f + (Rnd() * 2.f - 1.f);</div>
<div class="line">        dst.Scale      = Rnd() * 0.5f + 0.5f; <span class="comment">// 0.5 .. 1</span></div>
<div class="line">        dst.TimeOffset = Rnd() * PI_F;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We use the structured buffer because the data size may be larger than supported by a constant buffer:</p>
<div class="fragment"><div class="line">BufferDesc BuffDesc;</div>
<div class="line">BuffDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>      = <span class="stringliteral">&quot;Draw tasks buffer&quot;</span>;</div>
<div class="line">BuffDesc.Usage     = USAGE_DEFAULT;</div>
<div class="line">BuffDesc.BindFlags = BIND_SHADER_RESOURCE;</div>
<div class="line">BuffDesc.Mode      = BUFFER_MODE_STRUCTURED;</div>
<div class="line">BuffDesc.Size      = <span class="keyword">sizeof</span>(DrawTasks[0]) * <span class="keyword">static_cast&lt;</span>Uint32<span class="keyword">&gt;</span>(DrawTasks.size());</div>
<div class="line"> </div>
<div class="line">BufferData BufData;</div>
<div class="line">BufData.<a class="code hl_variable" href="../../d2/d3c/structDiligent_1_1BufferData.html#a26cc7ca53f891a63ed1846e27b8e50d8">pData</a>    = DrawTasks.data();</div>
<div class="line">BufData.DataSize = BuffDesc.Size;</div>
<div class="line"> </div>
<div class="line">m_pDevice-&gt;CreateBuffer(BuffDesc, &amp;BufData, &amp;m_pDrawTasks);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md402"></a>
Rendering</h2>
<p>To issue the draw command, we first prepare the data that will be required by the mesh shader: we calculate the field of view (FOV) of the camera and cotangent of the half FOV, as these values are used to build the projection matrix and to calculate LODs in the shader.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> m_FOV            = PI_F / 4.0f;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> m_CoTanHalfFov   = 1.0f / std::tan(m_FOV * 0.5f);</div>
</div><!-- fragment --><p>and upload the values into the constant buffer:</p>
<div class="fragment"><div class="line">MapHelper&lt;Constants&gt; CBConstants(m_pImmediateContext, m_pConstants, MAP_WRITE, MAP_FLAG_DISCARD);</div>
<div class="line">CBConstants-&gt;ViewMat        = m_ViewMatrix.Transpose();</div>
<div class="line">CBConstants-&gt;ViewProjMat    = m_ViewProjMatrix.Transpose();</div>
<div class="line">CBConstants-&gt;CoTanHalfFov   = m_LodScale * m_CoTanHalfFov;</div>
<div class="line">CBConstants-&gt;FrustumCulling = m_FrustumCulling;</div>
<div class="line">CBConstants-&gt;ElapsedTime    = m_ElapsedTime;</div>
<div class="line">CBConstants-&gt;Animate        = m_Animate;</div>
</div><!-- fragment --><p>We also use <code>ExtractViewFrustumPlanesFromMatrix()</code> function to calculate the view frustum planes from the view-projection matrix. Notice that the planes are not normalized and we need to normalize them to use for sphere culling. The resulting plane attributes are written into the constant buffer as well:</p>
<div class="fragment"><div class="line">ViewFrustum Frustum;</div>
<div class="line">ExtractViewFrustumPlanesFromMatrix(m_ViewProjMatrix, Frustum, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (uint i = 0; i &lt; _countof(CBConstants-&gt;Frustum); ++i)</div>
<div class="line">{</div>
<div class="line">    Plane3D plane  = Frustum.GetPlane(ViewFrustum::PLANE_IDX(i));</div>
<div class="line">    <span class="keywordtype">float</span>   invlen = 1.0f / length(plane.Normal);</div>
<div class="line">    plane.Normal *= invlen;</div>
<div class="line">    plane.Distance *= invlen;</div>
<div class="line"> </div>
<div class="line">    CBConstants-&gt;Frustum[i] = plane;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We are now finally ready to launch the amplification shader, which is very similar to dispatching compute groups. The shader runs 32 threads per group, so we need to dispatch just <code>m_DrawTaskCount / ASGroupSize</code> groups (in this example the task count is always a multiple of 32):</p>
<div class="fragment"><div class="line">DrawMeshAttribs drawAttrs{m_DrawTaskCount / ASGroupSize, DRAW_FLAG_VERIFY_ALL};</div>
<div class="line">m_pImmediateContext-&gt;DrawMesh(drawAttrs);</div>
</div><!-- fragment --><p>And that's it!</p>
<h2><a class="anchor" id="autotoc_md403"></a>
Further Reading</h2>
<p><a href="https://developer.nvidia.com/blog/introduction-turing-mesh-shaders/">Introduction to Turing Mesh Shaders</a> <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#shaders-task">Vulkan spec</a> <a href="https://github.com/KhronosGroup/GLSL/raw/master/extensions/nv/GLSL_NV_mesh_shader.txt">GLSL spec</a> <a href="https://microsoft.github.io/DirectX-Specs/d3d/MeshShader.html">DirectX spec</a> <a href="https://stackoverflow.com/a/21649403">Radius of projected sphere in screen space</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
