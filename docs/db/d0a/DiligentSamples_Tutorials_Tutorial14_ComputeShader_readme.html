<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial14 - Compute Shader</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/d0a/DiligentSamples_Tutorials_Tutorial14_ComputeShader_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial14 - Compute Shader</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial shows how to implement a simple particle simulation system using compute shaders.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial14_ComputeShader/Animation_Large.gif" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial14_ComputeShader/Tutorial14_ComputeShader.html">â–¶ Run in the browser</a></p>
<p>The particle system consists of a number of spherical particles moving in random directions that encounter <a href="https://en.wikipedia.org/wiki/Elastic_collision">elastic collisions</a>. The simulation and collision detection is performed on the GPU by compute shaders. To accelerate collision detection, the shader subdivides the screen into bins and for every bin creates a list of particles residing in the bin. The number of bins is the same as the number of particles and the bins are distributed evenly on the screen, thus every bin on average contains one particle. The size of the particle does not exceed the bin size, so a particle should only be tested for collision against particles residing in its own or eight neighboring bins, resulting in O(n) overall algorithmic complexity.</p>
<h2><a class="anchor" id="autotoc_md365"></a>
Buffers</h2>
<p>The tutorial uses a number of buffers described below.</p>
<h2><a class="anchor" id="autotoc_md366"></a>
Particle Attributes Buffer</h2>
<p>This buffer contains the particle attributes organized into the following structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ParticleAttribs</div>
<div class="line">{</div>
<div class="line">    float2 f2Pos;</div>
<div class="line">    float2 f2NewPos;</div>
<div class="line"> </div>
<div class="line">    float2 f2Speed;</div>
<div class="line">    float2 f2NewSpeed;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">float</span>  fSize;</div>
<div class="line">    <span class="keywordtype">float</span>  fTemperature;</div>
<div class="line">    <span class="keywordtype">int</span>    iNumCollisions;</div>
<div class="line">    <span class="keywordtype">float</span>  fPadding0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Notice the padding element that is required to make the struct size <code>float4</code>-aligned. Note also that the struct contains current and new values of position and speed. This is required because they can't be updated in place due to unspecified execution order of GPU threads. The buffer initialization is pretty standard except for the fact that we use <code>BIND_UNORDERED_ACCESS</code> bind flag to make the buffer available for unordered read/write operations in the shader. Another important thing is that we use <code>BUFFER_MODE_STRUCTURED</code> to allow the buffer be accessed as a structured buffer in the shader. When <code>BUFFER_MODE_STRUCTURED</code> mode is used, <code>ElementByteStride</code> must define the element stride, in bytes, which in our case is <code>sizeof(ParticleAttribs)</code>.</p>
<div class="fragment"><div class="line">BufferDesc BuffDesc;</div>
<div class="line">BuffDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>              = <span class="stringliteral">&quot;Particle attribs buffer&quot;</span>;</div>
<div class="line">BuffDesc.Usage             = USAGE_DEFAULT;</div>
<div class="line">BuffDesc.BindFlags         = BIND_SHADER_RESOURCE | BIND_UNORDERED_ACCESS;</div>
<div class="line">BuffDesc.Mode              = BUFFER_MODE_STRUCTURED;</div>
<div class="line">BuffDesc.ElementByteStride = <span class="keyword">sizeof</span>(ParticleAttribs);</div>
<div class="line">BuffDesc.Size              = <span class="keyword">sizeof</span>(ParticleAttribs) * m_NumParticles;</div>
<div class="line">m_pDevice-&gt;CreateBuffer(BuffDesc, &amp;VBData, &amp;m_pParticleAttribsBuffer);</div>
<div class="ttc" id="astructDiligent_1_1DeviceObjectAttribs_html_a14a31dc6ad69e0b79514e5349e9b4fc0"><div class="ttname"><a href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Diligent::DeviceObjectAttribs::Name</a></div><div class="ttdeci">const Char * Name</div><div class="ttdoc">Object name.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1319</div></div>
</div><!-- fragment --><p>Structured buffers can be defined as both read-only or read-write buffers in the shader:</p>
<div class="fragment"><div class="line">StructuredBuffer&lt;ParticleAttribs&gt; g_Particles;</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">RWStructuredBuffer&lt;ParticleAttribs&gt; g_Particles;</div>
</div><!-- fragment --><p>The buffers can be accessed using array-style indexing in the shaders:</p>
<div class="fragment"><div class="line">ParticleAttribs Particle = g_Particles[iParticleIdx];</div>
<div class="line"> </div>
<div class="line">// Update the particle attribs</div>
<div class="line"> </div>
<div class="line">g_Particles[iParticleIdx] = Particle;</div>
</div><!-- fragment --><p>To bind structured buffers to shader variables, we can request default shader resource and unordered access views and set them in the shader resource binding like any other variable:</p>
<div class="fragment"><div class="line">IBufferView* pParticleAttribsBufferSRV = m_pParticleAttribsBuffer-&gt;GetDefaultView(BUFFER_VIEW_SHADER_RESOURCE);</div>
<div class="line">IBufferView* pParticleAttribsBufferUAV = m_pParticleAttribsBuffer-&gt;GetDefaultView(BUFFER_VIEW_UNORDERED_ACCESS);</div>
<div class="line"> </div>
<div class="line">m_pRenderParticleSRB-&gt;GetVariableByName(SHADER_TYPE_VERTEX, <span class="stringliteral">&quot;g_Particles&quot;</span>)</div>
<div class="line">                    -&gt;Set(pParticleAttribsBufferSRV);</div>
<div class="line">m_pMoveParticlesSRB-&gt;GetVariableByName(SHADER_TYPE_COMPUTE, <span class="stringliteral">&quot;g_Particles&quot;</span>)</div>
<div class="line">                   -&gt;Set(pParticleAttribsBufferUAV);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md367"></a>
Particle List Heads and Particle List Buffer</h2>
<p>The second buffer that we will use is going to contain the index of the first particle in the list, for every bin. Finally, the last buffer will contain the index of the next particle in the list, for every particle. Both buffers will store one integer per particle and will be initialized as structured buffers:</p>
<div class="fragment"><div class="line">BuffDesc.ElementByteStride = <span class="keyword">sizeof</span>(int);</div>
<div class="line">BuffDesc.Mode              = BUFFER_MODE_STRUCTURED;</div>
<div class="line">BuffDesc.Size              = BuffDesc.ElementByteStride * m_NumParticles;</div>
<div class="line">BuffDesc.BindFlags         = BIND_UNORDERED_ACCESS | BIND_SHADER_RESOURCE;</div>
<div class="line">m_pDevice-&gt;CreateBuffer(BuffDesc, <span class="keyword">nullptr</span>, &amp;m_pParticleListHeadsBuffer);</div>
<div class="line">m_pDevice-&gt;CreateBuffer(BuffDesc, <span class="keyword">nullptr</span>, &amp;m_pParticleListsBuffer);</div>
<div class="line">IBufferView* pParticleListHeadsBufferUAV = m_pParticleListHeadsBuffer-&gt;GetDefaultView(BUFFER_VIEW_UNORDERED_ACCESS);</div>
<div class="line">IBufferView* pParticleListsBufferUAV     = m_pParticleListsBuffer-&gt;GetDefaultView(BUFFER_VIEW_UNORDERED_ACCESS);</div>
<div class="line">IBufferView* pParticleListHeadsBufferSRV = m_pParticleListHeadsBuffer-&gt;GetDefaultView(BUFFER_VIEW_SHADER_RESOURCE);</div>
<div class="line">IBufferView* pParticleListsBufferSRV     = m_pParticleListsBuffer-&gt;GetDefaultView(BUFFER_VIEW_SHADER_RESOURCE);</div>
</div><!-- fragment --><p>In the shader, the buffers are declared as follows:</p>
<div class="fragment"><div class="line">RWStructuredBuffer&lt;int&gt; g_ParticleListHead;</div>
<div class="line">RWStructuredBuffer&lt;int&gt; g_ParticleLists;</div>
</div><!-- fragment --><p>The buffer views are bound to shader resource binding objects in a typical way:</p>
<div class="fragment"><div class="line">m_pMoveParticlesSRB-&gt;GetVariableByName(SHADER_TYPE_COMPUTE, <span class="stringliteral">&quot;g_ParticleListHead&quot;</span>)</div>
<div class="line">                   -&gt;Set(pParticleListHeadsBufferUAV);</div>
<div class="line">m_pMoveParticlesSRB-&gt;GetVariableByName(SHADER_TYPE_COMPUTE, <span class="stringliteral">&quot;g_ParticleLists&quot;</span>)</div>
<div class="line">                   -&gt;Set(pParticleListsBufferUAV);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md368"></a>
Compute Shaders</h2>
<p>Particle update pipeline consists of the following steps described in details below:</p>
<ol type="1">
<li>Reset particle lists</li>
<li>Move particles and perform binning</li>
<li>Particle collision - position update</li>
<li>Particle collision - speed update</li>
</ol>
<h3><a class="anchor" id="autotoc_md369"></a>
Resetting the Particle Lists</h3>
<p>The first shader in our particle simulation pipeline resets the particle list heads for every bin by writing -1:</p>
<div class="fragment"><div class="line">cbuffer Constants</div>
<div class="line">{</div>
<div class="line">    GlobalConstants g_Constants;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">RWStructuredBuffer&lt;int&gt; g_ParticleListHead;</div>
<div class="line"> </div>
<div class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</div>
<div class="line">void main(uint3 Gid  : SV_GroupID,</div>
<div class="line">          uint3 GTid : SV_GroupThreadID)</div>
<div class="line">{</div>
<div class="line">    uint uiGlobalThreadIdx = Gid.x * uint(THREAD_GROUP_SIZE) + GTid.x;</div>
<div class="line">    if (uiGlobalThreadIdx &lt; uint(g_Constants.i2ParticleGridSize.x * g_Constants.i2ParticleGridSize.y))</div>
<div class="line">        g_ParticleListHead[uiGlobalThreadIdx] = -1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>THREAD_GROUP_SIZE</code> macro is defined by the host and defines the size of the compute shader thread group.</p>
<p>Please refer to <a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-dispatch">this page</a> for explanation of group index, group thread index and other compute shader specific elements.</p>
<h3><a class="anchor" id="autotoc_md370"></a>
Moving Particles</h3>
<p>The second compute shader in the pipeline moves every particle, updates the speed calculated by the collision shader previously and performs particle binning. The full source is given below:</p>
<div class="fragment"><div class="line">#include &quot;structures.fxh&quot;</div>
<div class="line">#include &quot;particles.fxh&quot;</div>
<div class="line"> </div>
<div class="line">cbuffer Constants</div>
<div class="line">{</div>
<div class="line">    GlobalConstants g_Constants;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">#ifndef THREAD_GROUP_SIZE</div>
<div class="line">#   define THREAD_GROUP_SIZE 64</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">RWStructuredBuffer&lt;ParticleAttribs&gt; g_Particles;</div>
<div class="line">struct HeadData</div>
<div class="line">{</div>
<div class="line">    int FirstParticleIdx;</div>
<div class="line">};</div>
<div class="line">RWStructuredBuffer&lt;HeadData&gt; g_ParticleListHead;</div>
<div class="line"> </div>
<div class="line">RWStructuredBuffer&lt;int&gt; g_ParticleLists;</div>
<div class="line"> </div>
<div class="line">[numthreads(THREAD_GROUP_SIZE, 1, 1)]</div>
<div class="line">void main(uint3 Gid  : SV_GroupID,</div>
<div class="line">          uint3 GTid : SV_GroupThreadID)</div>
<div class="line">{</div>
<div class="line">    uint uiGlobalThreadIdx = Gid.x * uint(THREAD_GROUP_SIZE) + GTid.x;</div>
<div class="line">    if (uiGlobalThreadIdx &gt;= g_Constants.uiNumParticles)</div>
<div class="line">        return;</div>
<div class="line"> </div>
<div class="line">    int iParticleIdx = int(uiGlobalThreadIdx);</div>
<div class="line"> </div>
<div class="line">    ParticleAttribs Particle = g_Particles[iParticleIdx];</div>
<div class="line">    Particle.f2Pos   = Particle.f2NewPos;</div>
<div class="line">    Particle.f2Speed = Particle.f2NewSpeed;</div>
<div class="line">    Particle.f2Pos  += Particle.f2Speed * g_Constants.f2Scale * g_Constants.fDeltaTime;</div>
<div class="line">    Particle.fTemperature -= Particle.fTemperature * min(g_Constants.fDeltaTime * 2.0, 1.0);</div>
<div class="line"> </div>
<div class="line">    ClampParticlePosition(Particle.f2Pos, Particle.f2Speed, Particle.fSize, g_Constants.f2Scale);</div>
<div class="line">    g_Particles[iParticleIdx] = Particle;</div>
<div class="line"> </div>
<div class="line">    // Bin particles</div>
<div class="line">    int GridIdx = GetGridLocation(Particle.f2Pos, g_Constants.i2ParticleGridSize).z;</div>
<div class="line">    int OriginalListIdx;</div>
<div class="line">    InterlockedExchange(g_ParticleListHead[GridIdx].FirstParticleIdx, iParticleIdx, OriginalListIdx);</div>
<div class="line">    g_ParticleLists[iParticleIdx] = OriginalListIdx;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that Metal backend has a limitation that structured buffers must have different element types. So we use a <code>HeadData</code> struct to wrap the particle index.</p>
<p>The shader starts by loading the particle attributes and updating the position and temperature. The temperature is not a real temperature but rather indicates if the particle has been hit recently. It then clamps the particle position against the screen boundaries and writes the updated particle back to the structured buffer:</p>
<div class="fragment"><div class="line">ParticleAttribs Particle = g_Particles[iParticleIdx];</div>
<div class="line">Particle.f2Pos   = Particle.f2NewPos;</div>
<div class="line">Particle.f2Speed = Particle.f2NewSpeed;</div>
<div class="line">Particle.f2Pos  += Particle.f2Speed * g_Constants.f2Scale * g_Constants.fDeltaTime;</div>
<div class="line">Particle.fTemperature -= Particle.fTemperature * g_Constants.fDeltaTime * 2.0;</div>
<div class="line"> </div>
<div class="line">ClampParticlePosition(Particle.f2Pos, Particle.f2Speed, Particle.fSize, g_Constants.f2Scale);</div>
<div class="line">g_Particles[iParticleIdx] = Particle;</div>
</div><!-- fragment --><p>The most interesting part of this shader is particle binning that is performed by the following code:</p>
<div class="fragment"><div class="line">int GridIdx = GetGridLocation(Particle.f2Pos, g_Constants.i2ParticleGridSize).z;</div>
<div class="line">int OriginalListIdx;</div>
<div class="line">InterlockedExchange(g_ParticleListHead[GridIdx].FirstParticleIdx, iParticleIdx, OriginalListIdx);</div>
<div class="line">g_ParticleLists[iParticleIdx] = OriginalListIdx;</div>
</div><!-- fragment --><p>The code relies on an interlocked exchange operation that atomically writes a value to the buffer and returns an old value. Using interlocked operation is crucial here as multiple GPU threads may potentially attempt to access the same memory when more than one particle resides in a bin.</p>
<p>The update process is illustrated below:</p>
<ol type="1">
<li>Atomically write particle Id to the buffer and get original list head index.</li>
</ol>
<div class="fragment"><div class="line">           GridId</div>
<div class="line">... |     |  N  |     |     | ...  List heads</div>
<div class="line">   </div>
<div class="line">                ||</div>
<div class="line">                \/</div>
<div class="line"> </div>
<div class="line">           GridId</div>
<div class="line">... |     |PatId|     |     | ...  List heads</div>
<div class="line"> </div>
<div class="line">OriginalListIdx == N</div>
</div><!-- fragment --><ol type="1">
<li>Write original list head to the particle list buffer:</li>
</ol>
<div class="fragment"><div class="line">           GridId</div>
<div class="line">... |     |PatId|     |     | ...  List heads</div>
<div class="line">             |</div>
<div class="line">             |_____</div>
<div class="line">                   |</div>
<div class="line">                   V</div>
<div class="line">       N         PatId</div>
<div class="line">... |     |     |  N  |     | ...  Particle lists</div>
<div class="line">       ^          |</div>
<div class="line">       |__________|</div>
</div><!-- fragment --><p>The lists are thus grown from the start by replacing the head. Given this linked list structure defined by these two buffers, the particles can be iterated as shown in the collision shader.</p>
<h3><a class="anchor" id="autotoc_md371"></a>
Particle Collision</h3>
<p>Particle collision is performed in two steps. On the first step, we update the particle position to make sure it does not intersect with other particles. On the second step, we update the particle speed. The reasons the steps are separated is because the math we use for speed updates is only valid for two-particle collisions, so we count the number of collisions on the first step and use this number at the second step</p>
<p>Both steps are implemented by the same shader. Whether we perform position or speed update is controlled by the value of <code>UPDATE_SPEED</code> macro. The shader uses all three particle-related buffers:</p>
<div class="fragment"><div class="line">RWStructuredBuffer&lt;ParticleAttribs&gt; g_Particles;</div>
<div class="line"> </div>
<div class="line">struct HeadData</div>
<div class="line">{</div>
<div class="line">    int FirstParticleIdx;</div>
<div class="line">};</div>
<div class="line">StructuredBuffer&lt;HeadData&gt; g_ParticleListHead;</div>
<div class="line"> </div>
<div class="line">StructuredBuffer&lt;int&gt; g_ParticleLists;</div>
</div><!-- fragment --><p>The shader starts by reading the current particle attributes and computing the grid location:</p>
<div class="fragment"><div class="line">int iParticleIdx = int(uiGlobalThreadIdx);</div>
<div class="line">ParticleAttribs Particle = g_Particles[iParticleIdx];</div>
<div class="line">    </div>
<div class="line">int2 i2GridPos = GetGridLocation(Particle.f2Pos, g_Constants.i2ParticleGridSize).xy;</div>
<div class="line">int GridWidth  = g_Constants.i2ParticleGridSize.x;</div>
<div class="line">int GridHeight = g_Constants.i2ParticleGridSize.y;</div>
</div><!-- fragment --><p>The shader then goes through all bins in a 3x3 neighborhood, and for every bin it iterates through the list of particles assigned to that bin:</p>
<div class="fragment"><div class="line">for (int y = max(i2GridPos.y - 1, 0); y &lt;= min(i2GridPos.y + 1, GridHeight-1); ++y)</div>
<div class="line">{</div>
<div class="line">    for (int x = max(i2GridPos.x - 1, 0); x &lt;= min(i2GridPos.x + 1, GridWidth-1); ++x)</div>
<div class="line">    {</div>
<div class="line">        int AnotherParticleIdx = g_ParticleListHead[x + y * GridWidth].FirstParticleIdx;</div>
<div class="line">        while (AnotherParticleIdx &gt;= 0)</div>
<div class="line">        {</div>
<div class="line">            if (iParticleIdx != AnotherParticleIdx)</div>
<div class="line">            {</div>
<div class="line">                ParticleAttribs AnotherParticle = g_Particles[AnotherParticleIdx];</div>
<div class="line">                CollideParticles(Particle, AnotherParticle);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            AnotherParticleIdx = g_ParticleLists[AnotherParticleIdx];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Notice how iteration through the list is performed: we first read the index of the first particle:</p>
<div class="fragment"><div class="line">int AnotherParticleIdx = g_ParticleListHead[x + y * GridWidth].FirstParticleIdx;</div>
</div><!-- fragment --><p>And then run the loop until we reach the end of the list (<code>AnotherParticleIdx == -1</code>).</p>
<p>Inside the loop we go to the next particle by reading the next index from the particle's list buffer:</p>
<div class="fragment"><div class="line">AnotherParticleIdx = g_ParticleLists[AnotherParticleIdx];</div>
</div><!-- fragment --><p><code>CollideParticles</code> function implements the crux of particle collision. Please refer to the shader's <a href="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial14_ComputeShader/assets/collide_particles.csh">full source code</a> for details.</p>
<h2><a class="anchor" id="autotoc_md372"></a>
Particle Rendering Shader</h2>
<p>Particle rendering shader is pretty straightforward. The only thing worth mentioning is the usage of the particle attributes structured buffer:</p>
<div class="fragment"><div class="line">StructuredBuffer&lt;ParticleAttribs&gt; g_Particles;</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">ParticleAttribs Attribs = g_Particles[VSIn.InstID];</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md373"></a>
Initializing Compute Pipeline States</h2>
<p>Initialization of the compute pipeline is performed very similar to a graphics pipeline except that there is way fewer states to describe. Resource layout is pretty much everything you need to specify except for the compute shader itself:</p>
<div class="fragment"><div class="line">ComputePipelineStateCreateInfo PSOCreateInfo;</div>
<div class="line">PipelineStateDesc&amp;             PSODesc = PSOCreateInfo.PSODesc;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pipeline state name is used by the engine to report issues.</span></div>
<div class="line">PSODesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a> = <span class="stringliteral">&quot;Reset particle lists PSO&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This is a compute pipeline</span></div>
<div class="line">PSODesc.PipelineType = PIPELINE_TYPE_COMPUTE;</div>
<div class="line"> </div>
<div class="line">PSODesc.ResourceLayout.DefaultVariableType = SHADER_RESOURCE_VARIABLE_TYPE_MUTABLE;</div>
<div class="line">ShaderResourceVariableDesc Vars[] = </div>
<div class="line">{</div>
<div class="line">    {SHADER_TYPE_COMPUTE, <span class="stringliteral">&quot;Constants&quot;</span>, SHADER_RESOURCE_VARIABLE_TYPE_STATIC}</div>
<div class="line">};</div>
<div class="line">PSODesc.ResourceLayout.Variables    = Vars;</div>
<div class="line">PSODesc.ResourceLayout.NumVariables = _countof(Vars);</div>
<div class="line">    </div>
<div class="line">PSOCreateInfo.pCS = pResetParticleListsCS;</div>
<div class="line">m_pDevice-&gt;CreateGraphicsPipelineState(PSOCreateInfo, &amp;m_pResetParticleListsPSO);</div>
<div class="line">m_pResetParticleListsPSO-&gt;GetStaticVariableByName(SHADER_TYPE_COMPUTE, <span class="stringliteral">&quot;Constants&quot;</span>)-&gt;Set(m_Constants);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md374"></a>
Dispatching Compute Commands</h2>
<p>Compute commands are executed by the <code>DispatchCompute()</code> method of the device context. The method takes <code>DispatchComputeAttribs</code> argument that describes the compute grid size. Note that we round the grid x dimension up to make sure that all particles are processed. Every compute shader thread checks if the particle id is in the range and exits early if it is not.</p>
<div class="fragment"><div class="line">DispatchComputeAttribs DispatAttribs;</div>
<div class="line">DispatAttribs.<a class="code hl_variable" href="../../d4/d24/structDiligent_1_1DispatchComputeAttribs.html#ad6268495eacc1bdf2ae19538c5937c20">ThreadGroupCountX</a> = (m_NumParticles + m_ThreadGroupSize-1) / m_ThreadGroupSize;</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;SetPipelineState(m_pResetParticleListsPSO);</div>
<div class="line">m_pImmediateContext-&gt;CommitShaderResources(m_pResetParticleListsSRB,</div>
<div class="line">                                            RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line">m_pImmediateContext-&gt;DispatchCompute(DispatAttribs);</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;SetPipelineState(m_pMoveParticlesPSO);</div>
<div class="line">m_pImmediateContext-&gt;CommitShaderResources(m_pMoveParticlesSRB,</div>
<div class="line">                                           RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line">m_pImmediateContext-&gt;DispatchCompute(DispatAttribs);</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;SetPipelineState(m_pCollideParticlesPSO);</div>
<div class="line">m_pImmediateContext-&gt;CommitShaderResources(m_pCollideParticlesSRB,</div>
<div class="line">                                           RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line">m_pImmediateContext-&gt;DispatchCompute(DispatAttribs);</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;SetPipelineState(m_pUpdateParticleSpeedPSO);</div>
<div class="line"><span class="comment">// Use the same SRB</span></div>
<div class="line">m_pImmediateContext-&gt;CommitShaderResources(m_pCollideParticlesSRB,</div>
<div class="line">                                           RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line">m_pImmediateContext-&gt;DispatchCompute(DispatAttribs);</div>
<div class="ttc" id="astructDiligent_1_1DispatchComputeAttribs_html_ad6268495eacc1bdf2ae19538c5937c20"><div class="ttname"><a href="../../d4/d24/structDiligent_1_1DispatchComputeAttribs.html#ad6268495eacc1bdf2ae19538c5937c20">Diligent::DispatchComputeAttribs::ThreadGroupCountX</a></div><div class="ttdeci">Uint32 ThreadGroupCountX</div><div class="ttdoc">The number of groups dispatched in X direction.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:798</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md375"></a>
Rendering</h2>
<p>Particle rendering is pretty typical: we draw one instance per particle and the vertex shader reads the particle attributes from the structured buffer updated by the compute shaders.</p>
<div class="fragment"><div class="line">m_pImmediateContext-&gt;SetPipelineState(m_pRenderParticlePSO);</div>
<div class="line">m_pImmediateContext-&gt;CommitShaderResources(m_pRenderParticleSRB[m_BufferIdx],</div>
<div class="line">                                           RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line">DrawAttribs drawAttrs;</div>
<div class="line">drawAttrs.<a class="code hl_variable" href="../../d6/dd0/structDiligent_1_1DrawAttribs.html#aac1a1696f8dbbbcc612ad6747ceb48de">NumVertices</a>  = 4;</div>
<div class="line">drawAttrs.NumInstances = m_NumParticles;</div>
<div class="line">m_pImmediateContext-&gt;Draw(drawAttrs);</div>
<div class="ttc" id="astructDiligent_1_1DrawAttribs_html_aac1a1696f8dbbbcc612ad6747ceb48de"><div class="ttname"><a href="../../d6/dd0/structDiligent_1_1DrawAttribs.html#aac1a1696f8dbbbcc612ad6747ceb48de">Diligent::DrawAttribs::NumVertices</a></div><div class="ttdeci">Uint32 NumVertices</div><div class="ttdoc">The number of vertices to draw.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:262</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
