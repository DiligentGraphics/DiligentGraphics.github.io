<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Temporal Anti Aliasing</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/d24/DiligentFX_PostProcess_TemporalAntiAliasing_README.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Temporal Anti Aliasing</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md223"></a>
Table of contents</h2>
<ul>
<li>Introduction</li>
<li>Integration guidelines<ul>
<li>Input resources</li>
<li>Host API</li>
</ul>
</li>
<li>Implementation details</li>
<li><a class="el" href="../../de/d6b/README.html#references">References</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md224"></a>
Introduction</h2>
<p>We needed to add temporal antialiasing to our project that could run in WebGL. We based our implementation on the method described in <a href="https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/"><b>[Emilio LÃ³pez, 2022]</b></a></p>
<h2><a class="anchor" id="autotoc_md225"></a>
Integration guidelines</h2>
<h3><a class="anchor" id="autotoc_md226"></a>
Input resources</h3>
<p>The following table enumerates all external inputs required by TAA.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Name</b>   </th><th class="markdownTableHeadNone"><b>Format</b>   </th><th class="markdownTableHeadNone"><b>Notes</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Color buffer   </td><td class="markdownTableBodyNone"><code>APPLICATION SPECIFIED (3x FLOAT)</code>   </td><td class="markdownTableBodyNone">The color buffer of the current frame provided by the application, in linear space.   </td></tr>
</table>
<p>The effect uses a number of parameters to control the quality of the effect organized into the <code>HLSL::TemporalAntiAliasingAttribs</code> structure. The following table lists the parameters and their descriptions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Name</b>   </th><th class="markdownTableHeadNone"><b>Notes</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Temporal stability factor   </td><td class="markdownTableBodyNone">The current implementation of TAA uses linear weighting based on the number of accumulated samples for each pixel. However, we can still determine a minimum alpha when blending the current and previous frames.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Reset accumulation   </td><td class="markdownTableBodyNone">If this parameter is set to true, the current frame will be written to the current history buffer without interpolation with the previous history buffer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Skip rejection   </td><td class="markdownTableBodyNone">This parameter allows skipping the disocclusion check stage. Disocclusion check can cause flickering on a high-frequency signal. Use this parameter for static images to achieve honest supersampling.   </td></tr>
</table>
<p>The effect can be configured using the <code>TemporalAntiAliasing::FEATURE_FLAGS</code> enumeration. The following table lists the flags and their descriptions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Name</b>   </th><th class="markdownTableHeadNone"><b>Notes</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>FEATURE_FLAG_GAUSSIAN_WEIGHTING</code>   </td><td class="markdownTableBodyNone">Use Gaussian weighting in the variance clipping step    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>FEATURE_FLAG_BICUBIC_FILTER</code>   </td><td class="markdownTableBodyNone">Use Catmull-Rom filter to sample from the history buffer   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md227"></a>
Host API</h3>
<p>To integrate TAA into your project, include the following necessary header files: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;PostFXContext.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../da/d2e/TemporalAntiAliasing_8hpp.html">TemporalAntiAliasing.hpp</a>&quot;</span></div>
<div class="ttc" id="aTemporalAntiAliasing_8hpp_html"><div class="ttname"><a href="../../da/d2e/TemporalAntiAliasing_8hpp.html">TemporalAntiAliasing.hpp</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">namespace </span>HLSL</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#include &quot;Shaders/Common/public/BasicStructures.fxh&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Shaders/PostProcess/TemporalAntiAliasing/public/TemporalAntiAliasingStructures.fxh&quot;</span></div>
<div class="line">} <span class="comment">// namespace HLSL</span></div>
</div><!-- fragment --><p>Now, create the necessary objects: </p><div class="fragment"><div class="line">m_PostFXContext = std::make_unique&lt;PostFXContext&gt;(m_pDevice);</div>
<div class="line">m_TAA           = std::make_unique&lt;TemporalAntiAliasing&gt;(m_pDevice);</div>
</div><!-- fragment --><p>Next, call the methods to prepare resources for the <code>PostFXContext</code> and <code>TemporalAntiAliasing</code> objects. This needs to be done every frame before starting the rendering process. </p><div class="fragment"><div class="line">{</div>
<div class="line">    PostFXContext::FrameDesc FrameDesc;</div>
<div class="line">    FrameDesc.Index  = m_CurrentFrameNumber; <span class="comment">// Current frame number.</span></div>
<div class="line">    FrameDesc.Width  = SCDesc.Width;         <span class="comment">// Current screen width.</span></div>
<div class="line">    FrameDesc.Height = SCDesc.Height;        <span class="comment">// Current screen height.</span></div>
<div class="line">    m_PostFXContext-&gt;PrepareResources(m_pDevice, FrameDesc, PostFXContext::FEATURE_FLAG_NONE);</div>
<div class="line"> </div>
<div class="line">    TemporalAntiAliasing::FEATURE_FLAGS ActiveFeatures = ...;</div>
<div class="line">    m_TAA-&gt;PrepareResources(m_pDevice, m_pImmediateContext, m_PostFXContext.get(), ActiveFeatures);</div>
<div class="line">}</div>
</div><!-- fragment --><p>After that, invoke the <code>PostFXContext::Execute</code> method. At this stage, some intermediate resources necessary for all post-processing objects dependent on <code>PostFXContext</code> are calculated. This method can take a constant buffer directly containing an array from the current and previous cameras (for this method, you can refer to this section of the code [<a href="https://github.com/DiligentGraphics/DiligentSamples/raw/380b0a05b6c72d80fd6d574d7343ead77d6dd7eb/Tutorials/Tutorial27_PostProcessing/src/Tutorial27_PostProcessing.cpp#L164">0</a>] and [<a href="https://github.com/DiligentGraphics/DiligentSamples/raw/380b0a05b6c72d80fd6d574d7343ead77d6dd7eb/Tutorials/Tutorial27_PostProcessing/src/Tutorial27_PostProcessing.cpp#L228">1</a>]). Alternatively, you can pass the corresponding pointers <code>const HLSL::CameraAttribs* pCurrCamera</code> and <code>const HLSL::CameraAttribs* pPrevCamera</code> for the current and previous cameras, respectively. You also need to pass the depth of the current and previous frames (the depth buffers should not contain transparent objects), and a buffer with motion vectors in NDC space, into the corresponding <code>ITextureView* pCurrDepthBufferSRV</code>, <code>ITextureView* pPrevDepthBufferSRV</code>, <code>ITextureView* pMotionVectorsSRV</code> pointers.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    PostFXContext::RenderAttributes PostFXAttibs;</div>
<div class="line">    PostFXAttibs.pDevice             = m_pDevice;</div>
<div class="line">    PostFXAttibs.pDeviceContext      = m_pImmediateContext;</div>
<div class="line">    PostFXAttibs.pCameraAttribsCB    = m_FrameAttribsCB;  <span class="comment">// m_Resources[RESOURCE_IDENTIFIER_CAMERA_CONSTANT_BUFFER].AsBuffer();</span></div>
<div class="line">    PostFXAttibs.pCurrDepthBufferSRV = m_CurrDepthBuffer; <span class="comment">// m_Resources[RESOURCE_IDENTIFIER_DEPTH0 + CurrFrameIdx].GetTextureSRV();</span></div>
<div class="line">    PostFXAttibs.pPrevDepthBufferSRV = m_PrevDepthBuffer; <span class="comment">// m_Resources[RESOURCE_IDENTIFIER_DEPTH0 + PrevFrameIdx].GetTextureSRV();</span></div>
<div class="line">    PostFXAttibs.pMotionVectorsSRV   = m_MotionBuffer;    <span class="comment">// m_GBuffer-&gt;GetBuffer(GBUFFER_RT_MOTION_VECTORS)-&gt;GetDefaultView(TEXTURE_VIEW_SHADER_RESOURCE);</span></div>
<div class="line">    m_TAA-&gt;Execute(PostFXAttibs);</div>
<div class="line">}</div>
</div><!-- fragment --><p>TAA requires that each frame be rendered with some offset relative to the pixel. Therefore, you need to pass a modified projection matrix and jitter when updating the camera buffer <code>HLSL::CameraAttribs</code> for the current frame, as in the code below (you can refer to this section of the code [<a href="https://github.com/DiligentGraphics/DiligentSamples/raw/380b0a05b6c72d80fd6d574d7343ead77d6dd7eb/Tutorials/Tutorial27_PostProcessing/src/Tutorial27_PostProcessing.cpp#L270">2</a>]) </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ComputeProjJitterMatrix = [&amp;](<span class="keyword">const</span> float4x4&amp; ProjMatrix, float2 Jitter) -&gt; float4x4 {</div>
<div class="line">    float4x4 Result = ProjMatrix;</div>
<div class="line">    Result[2][0]    = Jitter.x;</div>
<div class="line">    Result[2][1]    = Jitter.y;</div>
<div class="line">    <span class="keywordflow">return</span> Result;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> float2 Jitter = m_TAA-&gt;GetJitterOffset();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> float4x4 CameraView     = m_Camera.GetViewMatrix();</div>
<div class="line"><span class="keyword">const</span> float4x4 CameraProj     = ComputeProjJitterMatrix(GetAdjustedProjectionMatrix(YFov, ZNear, ZFar), Jitter);</div>
<div class="line"><span class="keyword">const</span> float4x4 CameraViewProj = CameraView * CameraProj;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span>&amp; CurrCamAttribs          = m_CameraAttribs[CurrFrameIdx];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">CurrCamAttribs.mViewT         = CameraView.Transpose();</div>
<div class="line">CurrCamAttribs.mProjT         = CameraProj.Transpose();</div>
<div class="line">CurrCamAttribs.mViewProjT     = CameraViewProj.Transpose();</div>
<div class="line">CurrCamAttribs.mViewInvT      = CameraView.Inverse().Transpose();</div>
<div class="line">CurrCamAttribs.mProjInvT      = CameraProj.Inverse().Transpose();</div>
<div class="line">CurrCamAttribs.mViewProjInvT  = CameraViewProj.Inverse().Transpose();</div>
<div class="line">CurrCamAttribs.f2Jitter.x     = Jitter.x;</div>
<div class="line">CurrCamAttribs.f2Jitter.y     = Jitter.y;</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>After rendering the entire frame, you need to invoke the TAA computation. Note that the frame passed in the color buffer argument must be in linear space, that is, before the tone mapping, as well as before effects such as Bloom and Depth Of Field. To do this, we call the <code>TemporalAntiAliasing::Execute</code> method. Before this, we need to fill the passed structures <code>TemporalAntiAliasingAttribs</code> and <code>TemporalAntiAliasing::RenderAttributes</code> with the necessary data. Refer to the Input resources section for parameter description. </p><div class="fragment"><div class="line">{</div>
<div class="line">    HLSL::TemporalAntiAliasingAttribs TAASettings{};</div>
<div class="line"> </div>
<div class="line">    TemporalAntiAliasing::RenderAttributes TAARenderAttribs{};</div>
<div class="line">    TAARenderAttribs.pDevice         = m_pDevice;</div>
<div class="line">    TAARenderAttribs.pDeviceContext  = m_pImmediateContext;</div>
<div class="line">    TAARenderAttribs.pPostFXContext  = m_PostFXContext.get();</div>
<div class="line">    TAARenderAttribs.pColorBufferSRV = m_ColorBuffer; <span class="comment">// m_Resources[RESOURCE_IDENTIFIER_RADIANCE0 + CurrFrameIdx].GetTextureSRV();</span></div>
<div class="line">    TAARenderAttribs.pTAAAttribs     = &amp;TAASettings;</div>
<div class="line">    m_TAA-&gt;Execute(TAARenderAttribs);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, you can directly obtain a <code>ITextureView</code> on the texture containing the TAA result using the method <code>TemporalAntiAliasing::GetAccumulatedFrameSRV</code>. After this, you can pass the TAA result to the tone mapping stage.</p>
<h2><a class="anchor" id="autotoc_md228"></a>
Implementation details</h2>
<p>In general, all TAA implementations use similar core concepts. For a brief introduction to how the initial implementation of temporal anti-aliasing works, refer to <a href="https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/"><b>[Emilio LÃ³pez, 2022]</b></a>. We based our implementation on the one described in the article, but we made some modifications:</p><ul>
<li>We use linear weighting instead of exponential weighting, meaning we keep track of the number of accumulated samples for each pixel. This allows us to increase the rate of convergence and reduce ghosting. You can read more about it in <a href="https://developer.download.nvidia.com/video/gputechconf/gtc/2020/presentations/s22699-fast-denoising-with-self-stabilizing-recurrent-blurs.pdf"><b>[ReBLUR, 2020]</b></a> page 25</li>
<li>We use variance clipping instead of AABB clamping. This results in slightly better quality, more detailed description can be found here <a href="https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf"><b>[Marco Salvi, 2016]</b></a>. We perform variance clipping in the YCoCg space, as it helps to eliminate the artifact of a purple hue appearing on some surfaces <a href="https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf"><b>[Brian Karis, 2014]</b></a> page 35.</li>
<li>We use dynamic variance gamma based on pixel velocity, which helps to reduce flickering on static frames.</li>
<li>During cubic filtering from the history buffer, we use the approach from <a href="https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf"><b>[Jorge Jimenez, 2016]</b></a> slide 77. This allows a slight performance improvement.</li>
</ul>
<h2><a class="anchor" id="autotoc_md229"></a>
References</h2>
<ul>
<li><b>[Lei Yang, 2020]</b>: A Survey of Temporal Antialiasing Techniques - <a href="http://behindthepixels.io/assets/files/TemporalAA.pdf">http://behindthepixels.io/assets/files/TemporalAA.pdf</a></li>
<li><b>[Emilio LÃ³pez, 2022]</b>: Temporal AA and the quest for the Holy Trail - <a href="https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/">https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/</a></li>
<li><b>[Brian Karis, 2014]</b>: High Quality Temporal Supersampling - <a href="https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf">https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf</a></li>
<li><b>[Marco Salvi, 2016]</b>: An Excursion in Temporal Supersampling - <a href="https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf">https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf</a></li>
<li><b>[ReBLUR, 2020]</b>: Fast Denoising with Self Stabilizing Recurrent Blurs - <a href="https://developer.download.nvidia.com/video/gputechconf/gtc/2020/presentations/s22699-fast-denoising-with-self-stabilizing-recurrent-blurs.pdf">https://developer.download.nvidia.com/video/gputechconf/gtc/2020/presentations/s22699-fast-denoising-with-self-stabilizing-recurrent-blurs.pdf</a></li>
<li><b>[Jorge Jimenez, 2016]</b>: Filmic SMAA - <a href="https://advances.realtimerendering.com/s2016/Filmic%20SMAA%20v7.pptx">https://advances.realtimerendering.com/s2016/Filmic%20SMAA%20v7.pptx</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
