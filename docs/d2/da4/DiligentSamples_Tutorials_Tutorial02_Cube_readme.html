<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial02 - Cube</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/da4/DiligentSamples_Tutorials_Tutorial02_Cube_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial02 - Cube</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial builds on top of Tutorial01 and demonstrates how to render an actual 3D object, a cube. It shows how to load shaders from files, create and use vertex, index and uniform buffers.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial02_Cube/Animation_Large.gif" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial02_Cube/Tutorial02_Cube.html">â–¶ Run in the browser</a></p>
<h2><a class="anchor" id="autotoc_md288"></a>
Shaders</h2>
<p>This tutorial uses a little bit more complicated vertex shader that reads two attributes from the input vertex buffer, a <code>float3</code> position and a <code>float4</code> color:</p>
<div class="fragment"><div class="line">struct VSInput</div>
<div class="line">{</div>
<div class="line">    float3 Pos   : ATTRIB0;</div>
<div class="line">    float4 Color : ATTRIB1;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void main(in  VSInput VSIn,</div>
<div class="line">          out PSInput PSIn) </div>
</div><!-- fragment --><p>By convention, <b>vertex shader inputs should be labeled as ATTRIBn, where n is the attribute number.</b> The attributes must match the input layout defined in the pipeline state object. Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex shader output variable name must match exactly the name of the pixel shader input variable. If the variable has structure type (like in this example), the structure declarations must also be identical. The shader also uses a world-view-projection matrix defined in a constant (uniform) buffer called <code>Constants</code> to transform vertex positions:</p>
<div class="fragment"><div class="line">cbuffer Constants</div>
<div class="line">{</div>
<div class="line">    float4x4 g_WorldViewProj;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The full vertex shader source code is as follows:</p>
<div class="fragment"><div class="line">cbuffer Constants</div>
<div class="line">{</div>
<div class="line">    float4x4 g_WorldViewProj;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct VSInput</div>
<div class="line">{</div>
<div class="line">    float3 Pos   : ATTRIB0;</div>
<div class="line">    float4 Color : ATTRIB1;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct PSInput </div>
<div class="line">{ </div>
<div class="line">    float4 Pos   : SV_POSITION; </div>
<div class="line">    float4 Color : COLOR0; </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void main(in  VSInput VSIn,</div>
<div class="line">          out PSInput PSIn) </div>
<div class="line">{</div>
<div class="line">    PSIn.Pos   = mul( float4(VSIn.Pos,1.0), g_WorldViewProj);</div>
<div class="line">    PSIn.Color = VSIn.Color;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Similar to Tutorial01, pixel (fragment) shader simply interpolates vertex colors.</p>
<h2><a class="anchor" id="autotoc_md289"></a>
Initializing the Pipeline State</h2>
<p>In this tutorial, we will be using depth buffer, so besides color output, we need to specify the format of the depth output in the <code>PSOCreateInfo</code>:</p>
<div class="fragment"><div class="line">PSOCreateInfo.GraphicsPipeline.NumRenderTargets             = 1;</div>
<div class="line">PSOCreateInfo.GraphicsPipeline.RTVFormats[0]                = pSwapChain-&gt;GetDesc().ColorBufferFormat;</div>
<div class="line">PSOCreateInfo.GraphicsPipeline.DSVFormat                    = pSwapChain-&gt;GetDesc().DepthBufferFormat;</div>
<div class="line">PSOCreateInfo.GraphicsPipeline.DepthStencilDesc.DepthEnable = True;</div>
</div><!-- fragment --><p>Also, we will enable back-face culling:</p>
<div class="fragment"><div class="line">PSOCreateInfo.GraphicsPipeline.RasterizerDesc.CullMode = CULL_MODE_BACK;</div>
</div><!-- fragment --><p>In this tutorial, we create shaders from files rather than from the source code strings. <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine accesses platform-specific files through <code>IShaderSourceInputStreamFactory</code> interface. The engine provides default implementation for the interface that should be sufficient in most cases.</p>
<div class="fragment"><div class="line">RefCntAutoPtr&lt;IShaderSourceInputStreamFactory&gt; pShaderSourceFactory;</div>
<div class="line">m_pEngineFactory-&gt;CreateDefaultShaderSourceStreamFactory(<span class="keyword">nullptr</span>, &amp;pShaderSourceFactory);</div>
<div class="line">ShaderCI.pShaderSourceStreamFactory = pShaderSourceFactory;</div>
</div><!-- fragment --><p><code>CreateDefaultShaderSourceStreamFactory</code> method optionally takes a semicolon-separated list of directories where source files will be looked up.</p>
<p>Notice the use of the <code>SHADER_COMPILE_FLAG_PACK_MATRIX_ROW_MAJOR</code> flag:</p>
<div class="fragment"><div class="line">ShaderCI.CompileFlags = SHADER_COMPILE_FLAG_PACK_MATRIX_ROW_MAJOR;</div>
</div><!-- fragment --><p>By default, matrices are laid out in GPU memory in column-major order, which means that the first four values of a 4x4 matrix represent the first column, the next four values represent the second column, and so on. Using row-major layout is more intuitive as it matches the way matrices are defined in C++ code. The <code>SHADER_COMPILE_FLAG_PACK_MATRIX_ROW_MAJOR</code> flag tells the shader compiler to use the row-major layout for matrices. Note that only row-major matrices are supported in WebGPU backend.</p>
<p>Other than a couple of differences mentioned above, vertex shader initialization is the same as in Tutorial01:</p>
<div class="fragment"><div class="line">ShaderCI.Desc.ShaderType = SHADER_TYPE_VERTEX;</div>
<div class="line">ShaderCI.EntryPoint      = <span class="stringliteral">&quot;main&quot;</span>;</div>
<div class="line">ShaderCI.Desc.Name       = <span class="stringliteral">&quot;Cube VS&quot;</span>;</div>
<div class="line">ShaderCI.FilePath        = <span class="stringliteral">&quot;cube.vsh&quot;</span>;</div>
<div class="line">pDevice-&gt;CreateShader(ShaderCI, &amp;pVS);</div>
</div><!-- fragment --><p>This time our shader uses a resource - a uniform buffer. So the first step is to create the buffer that will hold the transformation matrix. To create a buffer, populate <code>BufferDesc</code> structure:</p>
<div class="fragment"><div class="line">BufferDesc CBDesc;</div>
<div class="line">CBDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>           = <span class="stringliteral">&quot;VS constants CB&quot;</span>;</div>
<div class="line">CBDesc.Size           = <span class="keyword">sizeof</span>(float4x4);</div>
<div class="line">CBDesc.Usage          = USAGE_DYNAMIC;</div>
<div class="line">CBDesc.BindFlags      = BIND_UNIFORM_BUFFER;</div>
<div class="line">CBDesc.CPUAccessFlags = CPU_ACCESS_WRITE;</div>
<div class="line">pDevice-&gt;CreateBuffer( CBDesc, <span class="keyword">nullptr</span>, &amp;m_VSConstants );</div>
<div class="ttc" id="astructDiligent_1_1DeviceObjectAttribs_html_a14a31dc6ad69e0b79514e5349e9b4fc0"><div class="ttname"><a href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Diligent::DeviceObjectAttribs::Name</a></div><div class="ttdeci">const Char * Name</div><div class="ttdoc">Object name.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1319</div></div>
</div><!-- fragment --><p>Usage and Bind flags are designed after <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff476259(v=vs.85).aspx">D3D11 Usage</a> and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff476085(v=vs.85).aspx">D3D11 Bind Flags</a>.</p>
<p>Since our vertex shader reads attributes from the vertex buffer, the pipeline state must define how the attributes are fetched from the buffer. The two attributes are defined as follows:</p>
<div class="fragment"><div class="line">LayoutElement LayoutElems[] =</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Attribute 0 - vertex position</span></div>
<div class="line">    LayoutElement{0, 0, 3, VT_FLOAT32, False},</div>
<div class="line">    <span class="comment">// Attribute 1 - vertex color</span></div>
<div class="line">    LayoutElement{1, 0, 4, VT_FLOAT32, False}</div>
<div class="line">};</div>
<div class="line">PSOCreateInfo.GraphicsPipeline.InputLayout.LayoutElements = LayoutElems;</div>
<div class="line">PSOCreateInfo.GraphicsPipeline.InputLayout.NumElements    = _countof(LayoutElems);</div>
</div><!-- fragment --><p>Our shader has one variable that needs to be bound by the application, a uniform buffer <code>Constants</code>. Shader variables can be assigned one of three types, static, dynamic, or mutable. Please read <a href="http://diligentgraphics.com/2016/03/23/resource-binding-model-in-diligent-engine-2-0/">this post</a> for details. If no explicit type is provided for a variable, default type will be used:</p>
<div class="fragment"><div class="line">PSOCreateInfo.PSODesc.ResourceLayout.DefaultVariableType = SHADER_RESOURCE_VARIABLE_TYPE_STATIC;</div>
</div><!-- fragment --><p><code>Constants</code> uniform buffer is a static resource variable. Static variables are bound directly to the pipeline state and cannot be changed once bound:</p>
<div class="fragment"><div class="line">m_pPSO-&gt;GetStaticVariableByName(SHADER_TYPE_VERTEX, <span class="stringliteral">&quot;Constants&quot;</span>)-&gt;Set(m_VSConstants);</div>
</div><!-- fragment --><p>Notice that only the binding cannot be changed. The contents of the buffer is modifiable.</p>
<h2><a class="anchor" id="autotoc_md290"></a>
Creating Vertex and Index Buffers</h2>
<p>To create a vertex buffer, we first prepare the data to fill the buffer with. Our vertex layout corresponds to the following structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Vertex</div>
<div class="line">{</div>
<div class="line">    float3 pos;</div>
<div class="line">    float4 color;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Our vertex buffer will contain 8 vertices. Every vertex will have position and color:</p>
<div class="fragment"><div class="line"><span class="comment">//      (-1,+1,+1)________________(+1,+1,+1) </span></div>
<div class="line"><span class="comment">//               /|              /|</span></div>
<div class="line"><span class="comment">//              / |             / |</span></div>
<div class="line"><span class="comment">//             /  |            /  |</span></div>
<div class="line"><span class="comment">//            /   |           /   |</span></div>
<div class="line"><span class="comment">//(-1,-1,+1) /____|__________/(+1,-1,+1)</span></div>
<div class="line"><span class="comment">//           |    |__________|____| </span></div>
<div class="line"><span class="comment">//           |   /(-1,+1,-1) |    /(+1,+1,-1)</span></div>
<div class="line"><span class="comment">//           |  /            |   /</span></div>
<div class="line"><span class="comment">//           | /             |  /</span></div>
<div class="line"><span class="comment">//           |/              | /</span></div>
<div class="line"><span class="comment">//           /_______________|/ </span></div>
<div class="line"><span class="comment">//        (-1,-1,-1)       (+1,-1,-1)</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"> </div>
<div class="line">Vertex CubeVerts[8] =</div>
<div class="line">{</div>
<div class="line">    {float3(-1,-1,-1), float4(1,0,0,1)},</div>
<div class="line">    {float3(-1,+1,-1), float4(0,1,0,1)},</div>
<div class="line">    {float3(+1,+1,-1), float4(0,0,1,1)},</div>
<div class="line">    {float3(+1,-1,-1), float4(1,1,1,1)},</div>
<div class="line"> </div>
<div class="line">    {float3(-1,-1,+1), float4(1,1,0,1)},</div>
<div class="line">    {float3(-1,+1,+1), float4(0,1,1,1)},</div>
<div class="line">    {float3(+1,+1,+1), float4(1,0,1,1)},</div>
<div class="line">    {float3(+1,-1,+1), float4(0.2f,0.2f,0.2f,1)},</div>
<div class="line">};</div>
</div><!-- fragment --><p>Similar to uniform buffer, to create a vertex buffer, we populate <code>BufferDesc</code> structure. Since the data in the buffer will never change, we create the buffer with immutable usage (<code>USAGE_IMMUTABLE</code>) and provide initial data to <code>CreateBuffer()</code>:</p>
<div class="fragment"><div class="line">BufferDesc VertBuffDesc;</div>
<div class="line">VertBuffDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>          = <span class="stringliteral">&quot;Cube vertex buffer&quot;</span>;</div>
<div class="line">VertBuffDesc.Usage         = USAGE_IMMUTABLE;</div>
<div class="line">VertBuffDesc.BindFlags     = BIND_VERTEX_BUFFER;</div>
<div class="line">VertBuffDesc.Size          = <span class="keyword">sizeof</span>(CubeVerts);</div>
<div class="line">BufferData VBData;</div>
<div class="line">VBData.<a class="code hl_variable" href="../../d2/d3c/structDiligent_1_1BufferData.html#a26cc7ca53f891a63ed1846e27b8e50d8">pData</a>    = CubeVerts;</div>
<div class="line">VBData.DataSize = <span class="keyword">sizeof</span>(CubeVerts);</div>
<div class="line">pDevice-&gt;CreateBuffer(VertBuffDesc, &amp;VBData, &amp;m_CubeVertexBuffer);</div>
<div class="ttc" id="astructDiligent_1_1BufferData_html_a26cc7ca53f891a63ed1846e27b8e50d8"><div class="ttname"><a href="../../d2/d3c/structDiligent_1_1BufferData.html#a26cc7ca53f891a63ed1846e27b8e50d8">Diligent::BufferData::pData</a></div><div class="ttdeci">const void * pData</div><div class="ttdoc">Pointer to the data.</div><div class="ttdef"><b>Definition</b> Buffer.h:188</div></div>
</div><!-- fragment --><p>Index buffer is initialized in a very similar fashion.</p>
<h2><a class="anchor" id="autotoc_md291"></a>
Creating Shader Resource Binding Object</h2>
<p>Since our fragment shader uses shader resources (constant buffer), we need to create a shader resource binding object that will manage all required resource bindings:</p>
<div class="fragment"><div class="line">m_pPSO-&gt;CreateShaderResourceBinding(&amp;m_pSRB, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>The second parameter tells the engine to initialize all static resources bindings in the created SRB object.</p>
<h2><a class="anchor" id="autotoc_md292"></a>
Rendering</h2>
<p>There are few changes that we need to make to our rendering procedure compared to Tutorial01. First, we need to update our transformation matrix. Since we created our constant buffer as dynamic buffer, it can be mapped. <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine provides <code>MapHelper</code> template class that facilitates buffer mapping:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="comment">// Map the buffer and write current world-view-projection matrix</span></div>
<div class="line">    MapHelper&lt;float4x4&gt; CBConstants(m_pImmediateContext, m_VSConstants, MAP_WRITE, MAP_FLAG_DISCARD);</div>
<div class="line">    *CBConstants = m_WorldViewProjMatrix;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Second, we need to bind vertex and index buffer to the GPU pipeline. We use <code>RESOURCE_STATE_TRANSITION_MODE_TRANSITION</code> to let the engine automatically transition the buffers to required states.</p>
<div class="fragment"><div class="line">Uint64   offset   = 0;</div>
<div class="line">IBuffer* pBuffs[] = {m_CubeVertexBuffer};</div>
<div class="line">m_pImmediateContext-&gt;SetVertexBuffers(0, 1, pBuffs, &amp;offset, RESOURCE_STATE_TRANSITION_MODE_TRANSITION,</div>
<div class="line">                                      SET_VERTEX_BUFFERS_FLAG_RESET);</div>
<div class="line">m_pImmediateContext-&gt;SetIndexBuffer(m_CubeIndexBuffer, 0, RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
</div><!-- fragment --><p>Next step is very important: we need to commit shader resources:</p>
<div class="fragment"><div class="line">m_pImmediateContext-&gt;CommitShaderResources(m_pSRB, RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
</div><!-- fragment --><p>The first argument of <code>CommitShaderResources()</code> is the shader resource binding object. The <code>RESOURCE_STATE_TRANSITION_MODE_TRANSITION</code> tells the system that resources need to be transitioned to correct states by the engine. Transitioning resources introduces some overhead and can be avoided when it is known that resources are already in correct states.</p>
<p>Finally, this time the draw call is an indexed one:</p>
<div class="fragment"><div class="line">DrawIndexedAttribs DrawAttrs; <span class="comment">// This is an indexed draw call</span></div>
<div class="line">DrawAttrs.<a class="code hl_variable" href="../../d2/dce/structDiligent_1_1DrawIndexedAttribs.html#ac726f684a259d8f04d5136a7499843ba">IndexType</a>  = VT_UINT32; <span class="comment">// Index type</span></div>
<div class="line">DrawAttrs.NumIndices = 36;</div>
<div class="line"><span class="comment">// Verify the state of vertex and index buffers as well as consistence of </span></div>
<div class="line"><span class="comment">// render targets and correctness of draw command arguments</span></div>
<div class="line">DrawAttrs.Flags = DRAW_FLAG_VERIFY_ALL;</div>
<div class="line">m_pImmediateContext-&gt;DrawIndexed(DrawAttrs);</div>
<div class="ttc" id="astructDiligent_1_1DrawIndexedAttribs_html_ac726f684a259d8f04d5136a7499843ba"><div class="ttname"><a href="../../d2/dce/structDiligent_1_1DrawIndexedAttribs.html#ac726f684a259d8f04d5136a7499843ba">Diligent::DrawIndexedAttribs::IndexType</a></div><div class="ttdeci">VALUE_TYPE IndexType</div><div class="ttdoc">The type of elements in the index buffer.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:323</div></div>
</div><!-- fragment --><p>We want the engine to verify that the states are correct, so we use <code>DRAW_FLAG_VERIFY_ALL</code> flag. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
