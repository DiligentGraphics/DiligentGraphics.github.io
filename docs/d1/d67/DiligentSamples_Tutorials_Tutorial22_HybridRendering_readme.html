<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial 22 - Hybrid Rendering</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/d67/DiligentSamples_Tutorials_Tutorial22_HybridRendering_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial 22 - Hybrid Rendering</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates how to implement a simple hybrid renderer that combines rasterization with ray tracing.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial22_HybridRendering/Animation_Large.gif" alt="" class="inline"/></p>
<p>Ray tacing is very useful for creating high-quality effects that are difficult to do with rasterization (e.g. reflections), but its performance is generally much lower. This tutorial demonstrates a simple hybrid rendering approach, where the scene is first rendered into the G-buffer with rasterization, and then ray-tracing is used to compute reflections and shadows. The rendering process consists of three stages:</p>
<ul>
<li>G-buffer pass: a simple G-buffer that contains color, normals, and depth is rendered.</li>
<li>Ray tracing from compute shader: reflections and shadows are computed.</li>
<li>Post processing: results of the first two stages are combined into a shaded scene.</li>
</ul>
<p>This tutorial runs in Vulkan, DirectX12 and Metal (on compatible hardware).</p>
<h2><a class="anchor" id="autotoc_md417"></a>
Scene Description</h2>
<p>Ray tracing shaders need to have access to the entire scene, since, unlike rasterization, it is unknown ahead of time which object a ray will hit. To achieve this, we use bindless mode, where all required textures, buffers, samplers and other resources are bound once and can be dynamically indexed by any draw call. In this tutorial, we use a single vertex and index buffer that store multiple meshes, but a real application may use buffer arrays for multiple index and vertex buffers.</p>
<p>Each scene objects is described by the following structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ObjectAttribs</div>
<div class="line">{</div>
<div class="line">    float4x4 ModelMat;</div>
<div class="line">    float4x3 NormalMat;</div>
<div class="line"> </div>
<div class="line">    uint MaterialId;</div>
<div class="line">    uint FirstIndex;</div>
<div class="line">    uint FirstVertex;</div>
<div class="line">    uint MeshId; </div>
<div class="line">};</div>
</div><!-- fragment --><p><code>ModelMat</code> and <code>NormalMat</code> are local-to-world transformations for object positions and normals. <code>MaterialId</code> indicates the object material. <code>FirstIndex</code> and <code>FirstVertex</code> specify the position of the first index and first vertex in the index and vertex buffers correspondingly. <code>MeshId</code> is currently unused, but may indicate e.g. an index in the vertex buffer array.</p>
<p>For ray tracing, each mesh needs a bottom-level acceleration structure (BLAS). Note that in some cases, it may better to merge all static meshes into a single BLAS, which may improve ray tracing performance and speed up top-level AS construction.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Mesh</div>
<div class="line">{</div>
<div class="line">    RefCntAutoPtr&lt;IBottomLevelAS&gt; BLAS;</div>
<div class="line">    RefCntAutoPtr&lt;IBuffer&gt;        VertexBuffer;</div>
<div class="line">    RefCntAutoPtr&lt;IBuffer&gt;        IndexBuffer;</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>BLAS and TLAS construction is performed <a href="https://github.com/DiligentGraphics/DiligentSamples/tree/master/Tutorials/Tutorial21_RayTracing#acceleration-structures">similar to previous tutorial</a>.</p>
<p>To decrease the number of draw calls, objects with the same mesh are drawn using instancing.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>InstancedObjects</div>
<div class="line">{</div>
<div class="line">    Uint32 MeshInd             = 0;</div>
<div class="line">    Uint32 ObjectAttribsOffset = 0;</div>
<div class="line">    Uint32 NumObjects          = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that when we access a resource by index in the shader, we need to use <code>NonUniformResourceIndex()</code> qualifier, since otherwise the compiler may assume that this index is constant during the draw call and may apply optimizations that will result in an undefined behaviour:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main(in  PSInput  PSIn,</div>
<div class="line">          out PSOutput PSOut)</div>
<div class="line">{</div>
<div class="line">    MaterialAttribs Mtr = g_MaterialAttribs[NonUniformResourceIndex(PSIn.MatId)];</div>
<div class="line"> </div>
<div class="line">    PSOut.Color =</div>
<div class="line">        Mtr.BaseColorMask * g_Textures[NonUniformResourceIndex(Mtr.BaseColorTexInd)].</div>
<div class="line">                            Sample(g_Samplers[NonUniformResourceIndex(Mtr.SampInd)], PSIn.UV);</div>
<div class="line">    PSOut.Norm  = float4(normalize(PSIn.Norm), 0.0);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md418"></a>
Metal ray tracing</h2>
<p>All shaders are written in HLSL and can be used by DirectX12 and Vulkan backends directly. For compatibility with Metal and MSL, we use <a href="../../assets/RayQueryMtl.fxh">a wrapper</a> on top of Metal <code>raytracing::intersector&lt;...&gt;</code> that emulates the <code>RayQuery</code> functionality. The wrapper supports a minimal set of functions that are needed in this tutorial. In particular, there is no support for non-opaque objects that require iterating through multiple intersections. Note that instead of using a builtin <code>RayQuery::CommittedObjectToWorld4x3()</code>, as in the previous tutorial, we use matrices from <code>ObjectAttribs</code>.</p>
<p><code>RayQuery</code> wrapper can be further extended to use e.g. <code>TLASInstancesBuffer</code>, for example:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> device MTLAccelerationStructureInstanceDescriptor* g_TLASInstances [[buffer(0)]]</div>
<div class="line">...</div>
<div class="line"><span class="comment">// in RayQuery structure</span></div>
<div class="line">uint     CommittedInstanceIndex()                       { <span class="keywordflow">return</span> g_TLASInstances[m_LastIntersection.instance_id].accelerationStructureIndex; }</div>
<div class="line">uint     CommittedInstanceContributionToHitGroupIndex() { <span class="keywordflow">return</span> g_TLASInstances[m_LastIntersection.instance_id].intersectionFunctionTableOffset; }</div>
<div class="line">float4x3 CommittedObjectToWorld4x3()                    { <span class="keywordflow">return</span> g_TLASInstances[m_LastIntersection.instance_id].transformationMatrix; }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md419"></a>
Shader Resource Declaration</h2>
<p>While rasterization shaders can be cross-compiled by <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine from HLSL to MSL, ray tracing shaders require a bit more care. It is currently not possible to use verbatim HLSL for ray tracing. While HLSL is generally very similar to MSL, and core logic will work in both languages, resource declaration differs. We use macros to hide the differences, e.g.:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef METAL</span></div>
<div class="line"><span class="preprocessor">#    define TextureSample(Texture, Sampler, f2Coord, fLevel) Texture.sample(Sampler, f2Coord, level(fLevel))</span></div>
<div class="line"><span class="preprocessor">#    define TextureLoad(Texture, u2Coord)                    Texture.read(u2Coord)</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#    define TEXTURE(Name)       const texture2d&lt;float&gt; Name</span></div>
<div class="line"><span class="preprocessor">#    define BUFFER(Name, Type)  const device Type*     Name</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#    define TextureSample(Texture, Sampler, f2Coord, fLevel) Texture.SampleLevel(Sampler, f2Coord, fLevel)</span></div>
<div class="line"><span class="preprocessor">#    define TextureLoad(Texture, u2Coord)                    Texture.Load(int3(u2Coord, 0))</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#    define TEXTURE(Name)        Texture2D&lt;float4&gt;      Name</span></div>
<div class="line"><span class="preprocessor">#    define BUFFER(Name, Type)   StructuredBuffer&lt;Type&gt; Name</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>This tutorial only defines the required macros, but a real application may follow this idea to add more functionality.</p>
<p>Shader function declaration requires a bit more macros trickery as in HLSL, shader resources are defined as global variables, while in MSL, all resources are inputs to the shader function:</p>
<div class="fragment"><div class="line">BEGIN_SHADER_DECLARATION(CSMain)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// m_pRayTracingSceneResourcesSign</span></div>
<div class="line">    RaytracingAccelerationStructure g_TLAS                              MTL_BINDING(buffer,  0)  END_ARG</div>
<div class="line">    CONSTANT_BUFFER(                g_Constants,       GlobalConstants) MTL_BINDING(buffer,  1)  END_ARG</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// m_pRayTracingScreenResourcesSign</span></div>
<div class="line">    WTEXTURE(                       g_RayTracedTex)                     MTL_BINDING(texture, 5)  END_ARG</div>
<div class="line">    TEXTURE(                        g_GBuffer_Normal)                   MTL_BINDING(texture, 6)  END_ARG</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">   </div>
<div class="line">END_SHADER_DECLARATION(CSMain, 8, 8)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Shader body</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Please take a look at <a href="../../assets/RayTracing.csh">RayTracing.csh</a> for more details.</p>
<p>This tutorial uses explicit pipeline resource signatures to split resources of a ray-tracing pipeline into two groups: scene resources (<code>m_pRayTracingSceneResourcesSign</code>) and resources that depend on the window size (<code>m_pRayTracingScreenResourcesSign</code>). While in DirectX12 and Vulkan, the engine can perform required shader bindig remappings automatically under the hood, it is not currently possible in Metal backend. As a result, an application must explicitly define bindings that match the signature (using the <code>MTL_BINDING</code> macro in this example).</p>
<h2><a class="anchor" id="autotoc_md420"></a>
Ray Tracing</h2>
<p>The ray tracing shader performs the following steps:</p>
<ul>
<li>Reconstructs the world space position from the screen-space position and depth.</li>
<li>Casts a shadow ray in the light direction using the <code>CastShadow(...)</code> function. The function searches for any intersection and returns 0 if the intersection is found, and 1 otherwise.</li>
<li>Casts another ray in the reflection direction using the <code>Reflection(...)</code> function. This function finds the closest intersection with the scene, applies material and calculates lighting by casting a secondary shadow ray.</li>
<li>Writes the result to the output texture: reflection color is stored in the rgb components, and lighting information is stored in the alpha component.</li>
</ul>
<h2><a class="anchor" id="autotoc_md421"></a>
Post-Processing</h2>
<p>Post-processing is the final stage of the rendering process that does the following:</p>
<ul>
<li>Loads the G-buffer data (color, normal and depth) and reconstructs the world-space position.</li>
<li>Loads the ray-tracing data.</li>
<li>Computes the <a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">Fresnel term</a> using the view direction and surface normal and uses it to combine the reflection with the shaded pixel. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
