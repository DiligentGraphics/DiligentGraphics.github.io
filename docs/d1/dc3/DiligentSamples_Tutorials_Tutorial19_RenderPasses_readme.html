<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial19 - Render Passes</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/dc3/DiligentSamples_Tutorials_Tutorial19_RenderPasses_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial19 - Render Passes</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates how to use the render passes API to implement simple deferred shading.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial19_RenderPasses/Animation_Large.gif" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial19_RenderPasses/Tutorial19_RenderPasses.html">â–¶ Run in the browser</a></p>
<p>Render passes is a feature of the next-generation APIs that allows applications to define rendering commands in a way that better maps to tiled-deferred rendering architectures used by virtually all mobile platforms. Unlike immediate rendering architectures typical for desktop platforms, tiled-deferred renderers split the screen into small tiles (e.g. 64x64 pixels, the actual size depends on multiple factors including render target format, fast memory size, GPU vendor, etc.) and perform rendering operations tile after tile. This allows GPU to keep all data in a fast GPU-local cache, which is both faster and more power-efficient. When GPU is done processing one tile, it flushes all the data to the main memory and moves to the next tile.</p>
<p>Render passes were introduced to give applications explicit control over tile operations. A good metal model of a render pass is a set of operations that the GPU performs in a local tile cache before flushing the data to the main memory and moving to the next tile.</p>
<p>A render pass is defined by the following key components:</p>
<ul>
<li><em>Render pass attachments</em>, which are the set of texture views used within the render pass. Every attachment defines how its contents should be treated at the beginning of the render pass (load operations) as well as at the end of the render pass (store operation). The attachments can be used as outputs (render target or depth-stencil) in one subpass as well as inputs to other subpasses. A render pass can also perform multisample resolve operations at the end of the subpass.</li>
<li><em>Subpasses</em>. A render pass has one more subpasses. Every subpass defines a subset of render pass attachments that are used as output attachments, input attachments and resolve attachments.</li>
<li><em>Subpass dependencies</em> that define subpass attachment state transitions (e.g. from render target to input attachment).</li>
</ul>
<p><a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine enables applications to use and intermix render target API and render passes API. While the former one is a more implicit way, the latter is a more explicit approach and requires more effort from the application developers. Most importantly, <b>no state transitions are allowed within the render pass</b>. As a result, an application must not use <code>RESOURCE_STATE_TRANSITION_MODE_TRANSITION</code> with any command while a render pass is active.</p>
<h2><a class="anchor" id="autotoc_md386"></a>
Deferred Shading Using Render Passes</h2>
<p>This tutorial demonstrates a simple deferred shading renderer implemented using render passes API. The render pass consists of two subpasses. The first subpass is a G-buffer pass: it renders the scene and populates two buffers - color and depth. The second pass is a lighting pass. It renders light volumes and applies simple distance-based lighting to the G-buffer. Using the render passes API lets the driver reorder the operations and fuse G-buffer pass and lighting pass into a single tile operation thus avoiding the need to store intermediate G-buffer data to the main memory and reading it back.</p>
<h2><a class="anchor" id="autotoc_md387"></a>
Creating Render Pass</h2>
<p>To create a render pass we need to prepare an instance of <code>RenderPassDesc</code> struct. But first we need to define some auxiliary data.</p>
<h3><a class="anchor" id="autotoc_md388"></a>
Render Pass Attachments</h3>
<p>The first piece of the information we need to define is the render pass attachments. In this tutorial we will be using 4 attachments:</p>
<ol type="1">
<li>Color buffer</li>
<li>Depth Z</li>
<li>Depth buffer</li>
<li>Final color buffer</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> Uint32 NumAttachments = 4;</div>
<div class="line">RenderPassAttachmentDesc Attachments[NumAttachments];</div>
</div><!-- fragment --><p>The first attachment is the color G-Buffer:</p>
<div class="fragment"><div class="line">Attachments[0].Format       = TEX_FORMAT_RGBA8_UNORM;</div>
<div class="line">Attachments[0].InitialState = RESOURCE_STATE_RENDER_TARGET;</div>
<div class="line">Attachments[0].FinalState   = RESOURCE_STATE_INPUT_ATTACHMENT;</div>
<div class="line">Attachments[0].LoadOp       = ATTACHMENT_LOAD_OP_CLEAR;</div>
<div class="line">Attachments[0].StoreOp      = ATTACHMENT_STORE_OP_DISCARD;</div>
</div><!-- fragment --><p>Notice that we must specify the initial attachment state that the corresponding texture will be in before the render pass begins as well as the final state it will be in after the render pass ends. Also notice that as the load operation, we specify <code>ATTACHMENT_LOAD_OP_CLEAR</code>. This will tell the driver that old contents of the texture is not needed and should not be loaded from the main memory. Also note that as the store operation we use <code>ATTACHMENT_STORE_OP_DISCARD</code> that instructs the driver to discard all the data after the end of the render pass thus avoiding the need to write it back to the main memory.</p>
<p>The second attachment is the normalized device Z coordinate. Note that we can't extract this from the depth buffer (attacment 3), as we can't use it as both depth-stencil and input attachment during the second lighting subpass.</p>
<div class="fragment"><div class="line">Attachments[1].Format       = TEX_FORMAT_R32_FLOAT;</div>
<div class="line">Attachments[1].InitialState = RESOURCE_STATE_RENDER_TARGET;</div>
<div class="line">Attachments[1].FinalState   = RESOURCE_STATE_INPUT_ATTACHMENT;</div>
<div class="line">Attachments[1].LoadOp       = ATTACHMENT_LOAD_OP_CLEAR;</div>
<div class="line">Attachments[1].StoreOp      = ATTACHMENT_STORE_OP_DISCARD;</div>
</div><!-- fragment --><p> Note again that we use <code>ATTACHMENT_LOAD_OP_CLEAR</code> and <code>ATTACHMENT_STORE_OP_DISCARD</code> as load and store operations.</p>
<p>The third attachment is the depth buffer:</p>
<div class="fragment"><div class="line">Attachments[2].Format       = DepthBufferFormat;</div>
<div class="line">Attachments[2].InitialState = RESOURCE_STATE_DEPTH_WRITE;</div>
<div class="line">Attachments[2].FinalState   = RESOURCE_STATE_DEPTH_WRITE;</div>
<div class="line">Attachments[2].LoadOp       = ATTACHMENT_LOAD_OP_CLEAR;</div>
<div class="line">Attachments[2].StoreOp      = ATTACHMENT_STORE_OP_DISCARD;</div>
</div><!-- fragment --><p>The last attachment is the final buffer where the shaded result will be written to:</p>
<div class="fragment"><div class="line">Attachments[3].Format       = m_pSwapChain-&gt;GetDesc().ColorBufferFormat;</div>
<div class="line">Attachments[3].InitialState = RESOURCE_STATE_RENDER_TARGET;</div>
<div class="line">Attachments[3].FinalState   = RESOURCE_STATE_RENDER_TARGET;</div>
<div class="line">Attachments[3].LoadOp       = ATTACHMENT_LOAD_OP_CLEAR;</div>
<div class="line">Attachments[3].StoreOp      = ATTACHMENT_STORE_OP_STORE;</div>
</div><!-- fragment --><p>Note that unlike previous attachments, this time we use <code>ATTACHMENT_STORE_OP_STORE</code> because we will need to keep the final image to display it on the screen.</p>
<h3><a class="anchor" id="autotoc_md389"></a>
Subpasses</h3>
<p>As discussed above, the render pass will have two subpasses. The first subpass is the G-buffer pass, the second one is the lighting pass:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> Uint32 NumSubpasses = 2;</div>
<div class="line">SubpassDesc Subpasses[NumSubpasses];</div>
</div><!-- fragment --><p>The first subpass uses attachments 0 and 1 as render targets, and attachment 2 as depth-stencil buffer.</p>
<div class="fragment"><div class="line">AttachmentReference RTAttachmentRefs0[] =</div>
<div class="line">{</div>
<div class="line">    {0, RESOURCE_STATE_RENDER_TARGET},</div>
<div class="line">    {1, RESOURCE_STATE_RENDER_TARGET}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">AttachmentReference DepthAttachmentRef0 = {2, RESOURCE_STATE_DEPTH_WRITE};</div>
<div class="line"> </div>
<div class="line">Subpasses[0].RenderTargetAttachmentCount = _countof(RTAttachmentRefs0);</div>
<div class="line">Subpasses[0].pRenderTargetAttachments    = RTAttachmentRefs0;</div>
<div class="line">Subpasses[0].pDepthStencilAttachment     = &amp;DepthAttachmentRef0;</div>
</div><!-- fragment --><p>The <code>AttachmentReference</code> struct defines the attachment number as well as its state during the subpass.</p>
<p>The second subpass uses attachments 0 and 1 as input attachments, attachment 2 as depth-stencil buffer, and attachment 3 as render target:</p>
<div class="fragment"><div class="line">AttachmentReference RTAttachmentRefs1[] =</div>
<div class="line">{</div>
<div class="line">    {3, RESOURCE_STATE_RENDER_TARGET}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">AttachmentReference DepthAttachmentRef1 = {2, RESOURCE_STATE_DEPTH_WRITE};</div>
<div class="line"> </div>
<div class="line">AttachmentReference InputAttachmentRefs1[] =</div>
<div class="line">{</div>
<div class="line">    {0, RESOURCE_STATE_INPUT_ATTACHMENT},</div>
<div class="line">    {1, RESOURCE_STATE_INPUT_ATTACHMENT}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Subpasses[1].RenderTargetAttachmentCount = _countof(RTAttachmentRefs1);</div>
<div class="line">Subpasses[1].pRenderTargetAttachments    = RTAttachmentRefs1;</div>
<div class="line">Subpasses[1].pDepthStencilAttachment     = &amp;DepthAttachmentRef1;</div>
<div class="line">Subpasses[1].InputAttachmentCount        = _countof(InputAttachmentRefs1);</div>
<div class="line">Subpasses[1].pInputAttachments           = InputAttachmentRefs1;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md390"></a>
Dependencies</h3>
<p>Each subpass defines the states of all its attachments, and the attachments are transitioned between the states when going from one subpasspass to the next. However, besides attachment states, a render pass must also specify execution dependencies. In our specific example, attachments 0 and 1 are used as render targets in the first subpass and as input attachments in the second. So we need to specify a dependency from <code>ACCESS_FLAG_RENDER_TARGET_WRITE</code> access type performed by <code>PIPELINE_STAGE_FLAG_RENDER_TARGET</code> pipeline stage of subass 0 to <code>ACCESS_FLAG_SHADER_READ</code> access type from <code>PIPELINE_STAGE_FLAG_PIXEL_SHADER</code> pipeline stage of subpass 1.</p>
<div class="fragment"><div class="line">SubpassDependencyDesc Dependencies[1];</div>
<div class="line">Dependencies[0].<a class="code hl_variable" href="../../d0/de4/structDiligent_1_1SubpassDependencyDesc.html#a47be9e7520b7d2574501f5360923bbe7">SrcSubpass</a>    = 0;</div>
<div class="line">Dependencies[0].DstSubpass    = 1;</div>
<div class="line">Dependencies[0].SrcStageMask  = PIPELINE_STAGE_FLAG_RENDER_TARGET;</div>
<div class="line">Dependencies[0].DstStageMask  = PIPELINE_STAGE_FLAG_PIXEL_SHADER;</div>
<div class="line">Dependencies[0].SrcAccessMask = ACCESS_FLAG_RENDER_TARGET_WRITE;</div>
<div class="line">Dependencies[0].DstAccessMask = ACCESS_FLAG_SHADER_READ;</div>
<div class="ttc" id="astructDiligent_1_1SubpassDependencyDesc_html_a47be9e7520b7d2574501f5360923bbe7"><div class="ttname"><a href="../../d0/de4/structDiligent_1_1SubpassDependencyDesc.html#a47be9e7520b7d2574501f5360923bbe7">Diligent::SubpassDependencyDesc::SrcSubpass</a></div><div class="ttdeci">Uint32 SrcSubpass</div><div class="ttdoc">The subpass index of the first subpass in the dependency, or SUBPASS_EXTERNAL.</div><div class="ttdef"><b>Definition</b> RenderPass.h:383</div></div>
</div><!-- fragment --><p>Execution dependencies is a very complicated topic and is beyond the scope of this tutorial.</p>
<h3><a class="anchor" id="autotoc_md391"></a>
Creating the Render Pass Object</h3>
<p>Finally, when we have all pieces that describe the render pass, we can populate the <code>RenderPassDesc</code> structure and create the render pass object:</p>
<div class="fragment"><div class="line">RenderPassDesc RPDesc;</div>
<div class="line">RPDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>            = <span class="stringliteral">&quot;Deferred shading render pass desc&quot;</span>;</div>
<div class="line">RPDesc.AttachmentCount = _countof(Attachments);</div>
<div class="line">RPDesc.pAttachments    = Attachments;</div>
<div class="line">RPDesc.SubpassCount    = _countof(Subpasses);</div>
<div class="line">RPDesc.pSubpasses      = Subpasses;</div>
<div class="line">RPDesc.DependencyCount = _countof(Dependencies);</div>
<div class="line">RPDesc.pDependencies   = Dependencies;</div>
<div class="line"> </div>
<div class="line">m_pDevice-&gt;CreateRenderPass(RPDesc, &amp;m_pRenderPass);</div>
<div class="ttc" id="astructDiligent_1_1DeviceObjectAttribs_html_a14a31dc6ad69e0b79514e5349e9b4fc0"><div class="ttname"><a href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Diligent::DeviceObjectAttribs::Name</a></div><div class="ttdeci">const Char * Name</div><div class="ttdoc">Object name.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1319</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md392"></a>
Creating the PSO</h2>
<p>Creating a pipeline state object that uses explicit render pass is mostly the same as creating a PSO that uses render targets, with one difference: the PSO description structure should use the <code>pRenderPass</code> and <code>SubpassIndex</code> members:</p>
<div class="fragment"><div class="line">PSOCreateInfo.GraphicsPipeline.pRenderPass  = m_pRenderPass;</div>
<div class="line">PSOCreateInfo.GraphicsPipeline.SubpassIndex = 0;</div>
</div><!-- fragment --><p>Note that when <code>pRenderPass</code> is not null, all render target formats as well as depth-stencil format must be <code>TEX_FORMAT_UNKNOWN</code>, and the number of render targets must be 0.</p>
<h3><a class="anchor" id="autotoc_md393"></a>
Using Subpass Attachments in the Shader</h3>
<p>The only backend that currently natively supports input attachments is Vulkan, and subpass attachments are only supported in GLSL. To define subpass inputs in the shader, use the following syntax:</p>
<div class="fragment"><div class="line">layout(input_attachment_index = 0, binding = 0) uniform highp subpassInput g_SubpassInputColor;</div>
<div class="line">layout(input_attachment_index = 1, binding = 1) uniform highp subpassInput g_SubpassInputDepthZ;</div>
</div><!-- fragment --><p>In the shader, use <code>subpassLoad</code> function to load the subpass data:</p>
<div class="fragment"><div class="line">float Depth = subpassLoad(g_SubpassInputDepthZ).r;</div>
<div class="line">vec3  Color = subpassLoad(g_SubpassInputColor).rgb;</div>
</div><!-- fragment --><p>Note that <code>subpassLoad</code> function does not take the position because it is implicitly defined by the position of the current fragment.</p>
<p>In all other backends input attachments should be defined as regular textures and accessed appropriately:</p>
<div class="fragment"><div class="line">Texture2D&lt;float4&gt; g_SubpassInputColor;</div>
<div class="line">SamplerState      g_SubpassInputColor_sampler;</div>
<div class="line"> </div>
<div class="line">Texture2D&lt;float4&gt; g_SubpassInputDepthZ;</div>
<div class="line">SamplerState      g_SubpassInputDepthZ_sampler;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">float  Depth = g_SubpassInputDepthZ.Load(int3(PSIn.Pos.xy, 0)).r</div>
<div class="line">float3 Color = g_SubpassInputColor.Load(int3(PSIn.Pos.xy, 0)).rgb;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md394"></a>
Creating the Framebuffer</h2>
<p>The final part of the render passes API is the framebuffer. The framebuffer encapsulates the actual textures that will be used as attachments in the render pass. The framebuffer must use exactly same number of attachments as the render pass, and the the texture view formats must match exactly the corresponding render pass attachment formats. To create a framebuffer, prepare <code>FramebufferDesc</code> structure and call <code>IRenderDevice::CreateFramebuffer</code> method:</p>
<div class="fragment"><div class="line">ITextureView* pAttachments[] =</div>
<div class="line">{</div>
<div class="line">    pColorBuffer-&gt;GetDefaultView(TEXTURE_VIEW_RENDER_TARGET),</div>
<div class="line">    pDepthZBuffer-&gt;GetDefaultView(TEXTURE_VIEW_RENDER_TARGET),</div>
<div class="line">    pDepthBuffer-&gt;GetDefaultView(TEXTURE_VIEW_DEPTH_STENCIL),</div>
<div class="line">    pDstRenderTarget</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">FramebufferDesc FBDesc;</div>
<div class="line">FBDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>            = <span class="stringliteral">&quot;G-buffer framebuffer&quot;</span>;</div>
<div class="line">FBDesc.pRenderPass     = m_pRenderPass;</div>
<div class="line">FBDesc.AttachmentCount = _countof(pAttachments);</div>
<div class="line">FBDesc.ppAttachments   = pAttachments;</div>
<div class="line"> </div>
<div class="line">RefCntAutoPtr&lt;IFramebuffer&gt; pFramebuffer;</div>
<div class="line">m_pDevice-&gt;CreateFramebuffer(FBDesc, &amp;pFramebuffer);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md395"></a>
Using Render Passes</h2>
<p>There are three main subpass commands: <code>BeginRenderPass</code>, <code>NextSubpass</code>, and <code>EndRenderPass</code>.</p>
<p><code>BeginRenderPass</code> as the name suggests begins a render pass and starts the first subpass. To begin a render pass, besides the render pass itself we also need to specify a framebuffer, as well as clear values for all attachments that use <code>ATTACHMENT_LOAD_OP_CLEAR</code> load operation:</p>
<div class="fragment"><div class="line">BeginRenderPassAttribs RPBeginInfo;</div>
<div class="line">RPBeginInfo.<a class="code hl_variable" href="../../d7/dfe/structDiligent_1_1BeginRenderPassAttribs.html#a7c1225f579de4ac1650b540f6b20fe8a">pRenderPass</a>  = m_pRenderPass;</div>
<div class="line">RPBeginInfo.pFramebuffer = pFramebuffer;</div>
<div class="line"> </div>
<div class="line">OptimizedClearValue ClearValues[4];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Color</span></div>
<div class="line">ClearValues[0].<a class="code hl_variable" href="../../d6/d37/structDiligent_1_1OptimizedClearValue.html#a11898e2bde2185d78d2ca05bc850e92f">Color</a>[0] = 0.f;</div>
<div class="line">ClearValues[0].Color[1] = 0.f;</div>
<div class="line">ClearValues[0].Color[2] = 0.f;</div>
<div class="line">ClearValues[0].Color[3] = 0.f;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Depth Z</span></div>
<div class="line">ClearValues[1].Color[0] = 1.f;</div>
<div class="line">ClearValues[1].Color[1] = 1.f;</div>
<div class="line">ClearValues[1].Color[2] = 1.f;</div>
<div class="line">ClearValues[1].Color[3] = 1.f;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Depth buffer</span></div>
<div class="line">ClearValues[2].DepthStencil.Depth = 1.f;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Final color buffer</span></div>
<div class="line">ClearValues[3].Color[0] = 0.0625f;</div>
<div class="line">ClearValues[3].Color[1] = 0.0625f;</div>
<div class="line">ClearValues[3].Color[2] = 0.0625f;</div>
<div class="line">ClearValues[3].Color[3] = 0.f;</div>
<div class="line"> </div>
<div class="line">RPBeginInfo.pClearValues        = ClearValues;</div>
<div class="line">RPBeginInfo.ClearValueCount     = _countof(ClearValues);</div>
<div class="line">RPBeginInfo.StateTransitionMode = RESOURCE_STATE_TRANSITION_MODE_TRANSITION;</div>
<div class="line">m_pImmediateContext-&gt;BeginRenderPass(RPBeginInfo);</div>
<div class="ttc" id="astructDiligent_1_1BeginRenderPassAttribs_html_a7c1225f579de4ac1650b540f6b20fe8a"><div class="ttname"><a href="../../d7/dfe/structDiligent_1_1BeginRenderPassAttribs.html#a7c1225f579de4ac1650b540f6b20fe8a">Diligent::BeginRenderPassAttribs::pRenderPass</a></div><div class="ttdeci">IRenderPass * pRenderPass</div><div class="ttdoc">Render pass to begin.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:1210</div></div>
<div class="ttc" id="astructDiligent_1_1OptimizedClearValue_html_a11898e2bde2185d78d2ca05bc850e92f"><div class="ttname"><a href="../../d6/d37/structDiligent_1_1OptimizedClearValue.html#a11898e2bde2185d78d2ca05bc850e92f">Diligent::OptimizedClearValue::Color</a></div><div class="ttdeci">Float32 Color[4]</div><div class="ttdoc">Render target clear value.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1273</div></div>
</div><!-- fragment --><p>In the first subpass of our render pass, we render the scene. Then we call <code>NextSubpass</code> to move to the lighting subpass and draw the lights. Finally, we call <code>EndRenderPass</code> to finish the render pass:</p>
<div class="fragment"><div class="line">m_pImmediateContext-&gt;BeginRenderPass(RPBeginInfo);</div>
<div class="line">DrawScene();</div>
<div class="line">m_pImmediateContext-&gt;NextSubpass();</div>
<div class="line">ApplyLighting();</div>
<div class="line">m_pImmediateContext-&gt;EndRenderPass();</div>
</div><!-- fragment --><p>A very important aspect of render passes that needs to be mentioned again is that state transitions are not allowed between <code>BeginRenderPass</code> and <code>EndRenderPass</code> calls. The tutorial explicitly transitions all resources it uses to correct state during the initialization:</p>
<div class="fragment"><div class="line">StateTransitionDesc Barriers[] =</div>
<div class="line">{</div>
<div class="line">    {m_pShaderConstantsCB, RESOURCE_STATE_UNKNOWN, RESOURCE_STATE_CONSTANT_BUFFER, <span class="keyword">true</span>},</div>
<div class="line">    {m_CubeVertexBuffer, RESOURCE_STATE_UNKNOWN, RESOURCE_STATE_VERTEX_BUFFER, <span class="keyword">true</span>},</div>
<div class="line">    {m_CubeIndexBuffer, RESOURCE_STATE_UNKNOWN, RESOURCE_STATE_INDEX_BUFFER, <span class="keyword">true</span>},</div>
<div class="line">    {m_pLightsBuffer, RESOURCE_STATE_UNKNOWN, RESOURCE_STATE_VERTEX_BUFFER, <span class="keyword">true</span>},</div>
<div class="line">    {m_CubeTextureSRV-&gt;GetTexture(), RESOURCE_STATE_UNKNOWN, RESOURCE_STATE_SHADER_RESOURCE, <span class="keyword">true</span>} <span class="comment">//</span></div>
<div class="line">};</div>
<div class="line">m_pImmediateContext-&gt;TransitionResourceStates(_countof(Barriers), Barriers);</div>
</div><!-- fragment --><p>and then uses <code>RESOURCE_STATE_TRANSITION_MODE_VERIFY</code> mode with every call that requires state transition mode.</p>
<h2><a class="anchor" id="autotoc_md396"></a>
Further Reading</h2>
<p><a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine's render passes API largely resembles Vulkan, so <a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#renderpass">Vulkan spec</a> will provide the most comprehensive description. ARM software maintains a list of <a href="https://github.com/ARM-software/vulkan_best_practice_for_mobile_developers">Vulkan best practices for mobile developers</a> that include <a href="https://github.com/ARM-software/vulkan_best_practice_for_mobile_developers/raw/master/samples/performance/render_passes/render_passes_tutorial.md">attachment load/store operations</a>, <a href="https://github.com/ARM-software/vulkan_best_practice_for_mobile_developers/raw/master/samples/performance/layout_transitions/layout_transitions_tutorial.md">attachment layouts transitions</a>, and <a href="https://github.com/ARM-software/vulkan_best_practice_for_mobile_developers/raw/master/samples/performance/render_subpasses/render_subpasses_tutorial.md">subpasses</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
