<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial08 - Tessellation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/d89/DiligentSamples_Tutorials_Tutorial08_Tessellation_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial08 - Tessellation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial shows how to use hardware tessellation to implement simple adaptive terrain rendering algorithm.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial08_Tessellation/Animation_Large.gif" alt="" class="inline"/></p>
<p>Hardware tessellation allows 3D application to generate geometry entirely on the GPU by using two programmable stages (hull shader and domain shader) and a fixed-function tessellator. This tutorial shows how to program these stages to generate simple adaptive terrain tessellation. It loads 1k x 1k height map and breaks it up into 32x32 blocks. For every edge of every block, hull shader computes tessellation factors based on the distance to the camera. Tessellator then takes these factors to generate triangulation, and domain shader evaluates position for every point in it.</p>
<p>Puget Sound height map and texture are downloaded from this <a href="https://www.cc.gatech.edu/projects/large_models/ps.html">page</a>.</p>
<h2><a class="anchor" id="autotoc_md316"></a>
Shaders</h2>
<h3><a class="anchor" id="autotoc_md317"></a>
Vertex shader</h3>
<p>When tessellation is enabled, vertex shader processes every point in an input patch and can implement things like animation. We do not animate our terrain, so the vertex shader is almost pass-through. The only thing it does is computing the offset of the current block using the instance Id.</p>
<div class="fragment"><div class="line">#include &quot;structures.fxh&quot;</div>
<div class="line"> </div>
<div class="line">cbuffer VSConstants</div>
<div class="line">{</div>
<div class="line">    GlobalConstants g_Constants;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct TerrainVSIn</div>
<div class="line">{</div>
<div class="line">    uint BlockID : SV_VertexID;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void TerrainVS(in  TerrainVSIn  VSIn,</div>
<div class="line">               out TerrainVSOut VSOut)</div>
<div class="line">{</div>
<div class="line">    uint BlockHorzOrder = VSIn.BlockID % g_Constants.NumHorzBlocks;</div>
<div class="line">    uint BlockVertOrder = VSIn.BlockID / g_Constants.NumHorzBlocks;</div>
<div class="line">    </div>
<div class="line">    float2 BlockOffset = float2( </div>
<div class="line">        float(BlockHorzOrder) / g_Constants.fNumHorzBlocks,</div>
<div class="line">        float(BlockVertOrder) / g_Constants.fNumVertBlocks</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    VSOut.BlockOffset = BlockOffset;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the vertex shader includes <code>structures.fxh</code> file that contains definitions of structures used by the shaders.</p>
<h3><a class="anchor" id="autotoc_md318"></a>
Hull shader</h3>
<p>The hull shader consists of two parts. The first part processes all input patch control points (in contrast to the vertex shader that handles individual control points). It can generate another set of control points. In our case the shader input as well as output is one-control-point patch, so we only need to pass the block offset to the domain shader. Here we also need to define the properties of tessellation generated by the fixed-function stage:</p>
<div class="fragment"><div class="line">[domain(&quot;quad&quot;)]</div>
<div class="line">[partitioning(&quot;fractional_even&quot;)]</div>
<div class="line">[outputtopology(&quot;triangle_ccw&quot;)]</div>
<div class="line">[outputcontrolpoints(1)]</div>
<div class="line">[patchconstantfunc(&quot;ConstantHS&quot;)]</div>
<div class="line">[maxtessfactor( (float)(BLOCK_SIZE) )]</div>
<div class="line">TerrainHSOut TerrainHS(InputPatch&lt;TerrainVSOut, 1&gt; inputPatch, uint uCPID : SV_OutputControlPointID )</div>
<div class="line">{</div>
<div class="line">    TerrainHSOut HSOut = {inputPatch[0].BlockOffset};</div>
<div class="line"> </div>
<div class="line">    return HSOut;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second part is called <em>constant function</em>, whose purpose is to compute tessellation factors for the patch edges and interior. This tutorial uses a very simple method to evlaute the factors for every edge of every block: the edge factor is inversely proportional to the distance from the edge center to the camera:</p>
<div class="fragment"><div class="line">float2 BlockOffset = inputPatch[0].BlockOffset;</div>
<div class="line">float4 UV = float4(0.0, 0.0, 1.0, 1.0) / float2(g_Constants.fNumHorzBlocks, g_Constants.fNumVertBlocks).xyxy + BlockOffset.xyxy;</div>
<div class="line">float2 leftEdgeCntrUV  = float2(UV.x, (UV.y + UV.w)/2.0);</div>
<div class="line">// Compute edge center position</div>
<div class="line">float3 leftEdgeCntr  = float3((leftEdgeCntrUV - float2(0.5, 0.5)) * g_Constants.LengthScale, 0);</div>
<div class="line">// Sample height map at the location of the edge center</div>
<div class="line">leftEdgeCntr.z  = g_HeightMap.SampleLevel(g_HeightMap_sampler, leftEdgeCntrUV, 0)  * g_Constants.HeightScale;</div>
<div class="line">// Transform to camera space</div>
<div class="line">float3 leftEdgeCntrViewSpace  = mul(float4(leftEdgeCntr.xzy, 1.0), g_Constants.WorldView).xyz;</div>
<div class="line">// Compute distance to camera</div>
<div class="line">float distToLeftEdge = length(leftEdgeCntrViewSpace);</div>
<div class="line"> </div>
<div class="line">Out.Edges[0] = clamp( g_Constants.TessDensity / distToLeftEdge,  2.0, g_Constants.fBlockSize);</div>
</div><!-- fragment --><p>Interior factors are then computes as maximum of edge factors</p>
<div class="fragment"><div class="line">Out.Inside[0] = min(Out.Edges[1], Out.Edges[3]);</div>
<div class="line">Out.Inside[1] = min(Out.Edges[0], Out.Edges[2]);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md319"></a>
Domain shader</h3>
<p>The purpose of the domain shader is to evaluate the position of every vertex generated by the tessellator. It essentially replaces the vertex shader in the tessellation pipeline.</p>
<div class="fragment"><div class="line">[domain(&quot;quad&quot;)]</div>
<div class="line">/* partitioning = fractional_even, outputtopology = triangle_cw */</div>
<div class="line">TerrainDSOut TerrainDS( TerrainHSConstFuncOut ConstFuncOut, </div>
<div class="line">                        OutputPatch&lt;TerrainHSOut, 1&gt; QuadPatch,</div>
<div class="line">                        float2 DomainUV : SV_DomainLocation)</div>
<div class="line">{</div>
<div class="line">    TerrainDSOut Out;</div>
<div class="line">    float2 BlockOffset = QuadPatch[0].BlockOffset;</div>
<div class="line">    // Scale domain UV by the block size and add offset</div>
<div class="line">    float2 UV = DomainUV / float2(g_Constants.fNumHorzBlocks, g_Constants.fNumVertBlocks) + BlockOffset;</div>
<div class="line">    // Scale to world units</div>
<div class="line">    float2 XY = (UV - float2(0.5,0.5)) * g_Constants.LengthScale;</div>
<div class="line">    // Sample the height map</div>
<div class="line">    float Height = g_HeightMap.SampleLevel(g_HeightMap_sampler, UV, 0) * g_Constants.HeightScale;</div>
<div class="line">    float4 PosWorld = float4(XY, Height, 1.0);</div>
<div class="line">    // Apply world-view-projection matrix:</div>
<div class="line">    Out.Pos = mul(PosWorld.xzyw, g_Constants.WorldViewProj);</div>
<div class="line">    // Pass uv coordinates to the pixel shader</div>
<div class="line">    Out.uv = UV;</div>
<div class="line">    return Out;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that special comment on top of the function body is used by the HLSL-&gt;GLSL converter to generate proper tessellation evaluation shader code in OpenGL mode. Please visit <a href="http://diligentgraphics.com/diligent-engine/shader-converter/">this page</a> for more details.</p>
<h3><a class="anchor" id="autotoc_md320"></a>
Pixel shader</h3>
<p>Pixel shader simply samples the color texture and is quite straightforward:</p>
<div class="fragment"><div class="line">#include &quot;structures.fxh&quot;</div>
<div class="line"> </div>
<div class="line">Texture2D    g_Texture;</div>
<div class="line">SamplerState g_Texture_sampler;</div>
<div class="line"> </div>
<div class="line">float4 TerrainPS(TerrainDSOut ps_in) : SV_TARGET</div>
<div class="line">{</div>
<div class="line">    return g_Texture.Sample(g_Texture_sampler, ps_in.uv);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md321"></a>
Geometry and Pixel Shaders for Wireframe Mode</h3>
<p>The tutorial implements the technique shown in Tutorial07 to render wireframe. It uses geometry shader that goes after domain shader rather than vertex shader when tessellation is enabled to compute the distances to triangle edges. The distances are used by the pixel shader to generate smooth wireframe.</p>
<h2><a class="anchor" id="autotoc_md322"></a>
Initializing the Pipeline State and Rendering</h2>
<p>Pipeline state initialization is done in the same way as in previous tutorials. The only difference is that primitive topology is one-control-point patchlist:</p>
<div class="fragment"><div class="line">PSOCreateInfo.GraphicsPipeline.PrimitiveTopology = PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST;</div>
</div><!-- fragment --><p>Two pipeline state objects are created. The first one renders terrain in normal mode, the second one initializes all 5 shader stages to render wireframe overlay.</p>
<p>Rendering is done as usual, with one primitive being one patch:</p>
<div class="fragment"><div class="line">DrawAttribs DrawAttrs;</div>
<div class="line">DrawAttrs.<a class="code hl_variable" href="../../d6/dd0/structDiligent_1_1DrawAttribs.html#aac1a1696f8dbbbcc612ad6747ceb48de">NumVertices</a> = NumHorzBlocks * NumVertBlocks;</div>
<div class="line">DrawAttrs.Flags       = DRAW_FLAG_VERIFY_ALL;</div>
<div class="line">m_pImmediateContext-&gt;Draw(DrawAttrs);</div>
<div class="ttc" id="astructDiligent_1_1DrawAttribs_html_aac1a1696f8dbbbcc612ad6747ceb48de"><div class="ttname"><a href="../../d6/dd0/structDiligent_1_1DrawAttribs.html#aac1a1696f8dbbbcc612ad6747ceb48de">Diligent::DrawAttribs::NumVertices</a></div><div class="ttdeci">Uint32 NumVertices</div><div class="ttdoc">The number of vertices to draw.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:262</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
