<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial09 - Quads</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/d20/DiligentSamples_Tutorials_Tutorial09_Quads_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial09 - Quads</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial shows how to render multiple 2D quads, frequently switching textures and blend modes.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial09_Quads/Animation_Large.gif" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial09_Quads/Tutorial09_Quads.html">â–¶ Run in the browser</a></p>
<p>The tutorial is based on <a href="../../../Tutorial06_Multithreading">Tutorial06 - Multithreading</a>, but renders 2D quads instead of 3D cubes and changes the states frequently. It also demonstrates <em>Pipeline State compatibility feature</em> - if two PSOs share the same shader resource layout, they can use shader resource binding objects interchangeably, i.e. SRBs created by one PSO can be committed when another PSO is bound.</p>
<h2><a class="anchor" id="autotoc_md323"></a>
Shaders</h2>
<p>The tutorial has two rendering modes, non-batched (Batch Size parameter equals 1) and batched (Batch Size parameter greater than 1). In the first mode, the quads are rendered one-by-one. In the second mode, the quads are rendered in small batches, which is more efficient.</p>
<p>Non-batched vertex shader generates two triangles and applies rotation, scale and offset transformation. It does not use any input other than the vertex id. Quad transformation 2x2 matrix is packed into one <code>float4</code> vector.</p>
<div class="fragment"><div class="line">cbuffer QuadAttribs</div>
<div class="line">{</div>
<div class="line">    float4 g_QuadRotationAndScale; // float2x2 doesn&#39;t work</div>
<div class="line">    float4 g_QuadCenter;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct VSInput</div>
<div class="line">{</div>
<div class="line">    uint VertID : SV_VertexID;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct PSInput </div>
<div class="line">{ </div>
<div class="line">    float4 Pos : SV_POSITION; </div>
<div class="line">    float2 uv  : TEX_COORD;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void main(in  VSInput VSIn,</div>
<div class="line">          out PSInput PSIn)</div>
<div class="line">{</div>
<div class="line">    float4 pos_uv[4];</div>
<div class="line">    pos_uv[0] = float4(-1.0,+1.0, 0.0,0.0);</div>
<div class="line">    pos_uv[1] = float4(-1.0,-1.0, 0.0,1.0);</div>
<div class="line">    pos_uv[2] = float4(+1.0,+1.0, 1.0,0.0);</div>
<div class="line">    pos_uv[3] = float4(+1.0,-1.0, 1.0,1.0);</div>
<div class="line"> </div>
<div class="line">    float2 pos = pos_uv[VSIn.VertID].xy;</div>
<div class="line">    float2x2 mat = MatrixFromRows(g_QuadRotationAndScale.xy, g_QuadRotationAndScale.zw);</div>
<div class="line">    pos = mul(pos, mat);</div>
<div class="line">    pos += g_QuadCenter.xy;</div>
<div class="line">    PSIn.Pos = float4(pos, 0.0, 1.0);</div>
<div class="line">    PSIn.uv = pos_uv[VSIn.VertID].zw;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>MatrixFromRows()</code> is a function defined by the engine that creates a matrix from rows, in an API-specific fashion.</p>
<p>Non-batched pixel shader is straightforward and simply samples the texture:</p>
<div class="fragment"><div class="line">Texture2D    g_Texture;</div>
<div class="line">SamplerState g_Texture_sampler;</div>
<div class="line"> </div>
<div class="line">struct PSInput </div>
<div class="line">{ </div>
<div class="line">    float4 Pos : SV_POSITION; </div>
<div class="line">    float2 uv : TEX_COORD;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct PSOutput</div>
<div class="line">{</div>
<div class="line">    float4 Color : SV_TARGET;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void main(in  PSInput  PSIn,</div>
<div class="line">          out PSOutput PSOut)</div>
<div class="line">{</div>
<div class="line">    PSOut.Color = g_Texture.Sample(g_Texture_sampler, PSIn.uv).rgbg;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In batched mode, instancing is used to rendered a number of quads in the same draw call. The quad attributes (rotation, scale, translation) are fetched by the vertex shader from the vertex buffer:</p>
<div class="fragment"><div class="line">struct VSInput</div>
<div class="line">{</div>
<div class="line">    uint   VertID               : SV_VertexID;</div>
<div class="line">    float4 QuadRotationAndScale : ATTRIB0;</div>
<div class="line">    float2 QuadCenter           : ATTRIB1;</div>
<div class="line">    float  TexArrInd            : ATTRIB2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct PSInput </div>
<div class="line">{ </div>
<div class="line">    float4 Pos     : SV_POSITION; </div>
<div class="line">    float2 uv      : TEX_COORD;</div>
<div class="line">    float TexIndex : TEX_ARRAY_INDEX;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void main(in  VSInput VSIn,</div>
<div class="line">          out PSInput PSIn)</div>
<div class="line">{</div>
<div class="line">    float4 pos_uv[4];</div>
<div class="line">    pos_uv[0] = float4(-1.0,+1.0, 0.0,0.0);</div>
<div class="line">    pos_uv[1] = float4(-1.0,-1.0, 0.0,1.0);</div>
<div class="line">    pos_uv[2] = float4(+1.0,+1.0, 1.0,0.0);</div>
<div class="line">    pos_uv[3] = float4(+1.0,-1.0, 1.0,1.0);</div>
<div class="line"> </div>
<div class="line">    float2 pos = pos_uv[VSIn.VertID].xy;</div>
<div class="line">    float2x2 mat = MatrixFromRows(VSIn.QuadRotationAndScale.xy, VSIn.QuadRotationAndScale.zw);</div>
<div class="line">    pos = mul(pos, mat);</div>
<div class="line">    pos += VSIn.QuadCenter.xy;</div>
<div class="line">    PSIn.Pos = float4(pos, 0.0, 1.0);</div>
<div class="line">    PSIn.uv = pos_uv[VSIn.VertID].zw;</div>
<div class="line">    PSIn.TexIndex = VSIn.TexArrInd;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Quad textures are packed into the texture array. The vertex shader passes texture array index over to the pixel shader that uses the index to select texture array slice:</p>
<div class="fragment"><div class="line">Texture2DArray g_Texture;</div>
<div class="line">SamplerState   g_Texture_sampler;</div>
<div class="line"> </div>
<div class="line">struct PSInput</div>
<div class="line">{</div>
<div class="line">    float4 Pos     : SV_POSITION;</div>
<div class="line">    float2 uv      : TEX_COORD;</div>
<div class="line">    float TexIndex : TEX_ARRAY_INDEX;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct PSOutput</div>
<div class="line">{</div>
<div class="line">    float4 Color : SV_TARGET;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void main(in  PSInput  PSIn,</div>
<div class="line">          out PSOutput PSOut)</div>
<div class="line">{</div>
<div class="line">    PSOut.Color = g_Texture.Sample(g_Texture_sampler, float3(PSIn.uv, PSIn.TexIndex)).rgbg;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md324"></a>
Initializing Pipeline States and Shader Resource Binding Objects</h2>
<p>The tutorial creates multiple PSO objects that share the same shaders, but define different blend modes. Two pipeline states that share the same shader resource layout are called <em>compatible</em>. The enigne exposes <code>IPipelineState::IsCompatibleWith()</code> method that checks if two pipeline states are compatible. Compatible pipeline states can use shader resource binding objects interchangeably. We create shader resource binding objects using the first pipeline state version, but use them with other PSOs:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> tex = 0; tex &lt; NumTextures; ++tex)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create one Shader Resource Binding for every texture</span></div>
<div class="line">    <span class="comment">// http://diligentgraphics.com/2016/03/23/resource-binding-model-in-diligent-engine-2-0/</span></div>
<div class="line">    m_pPSO[0][0]-&gt;CreateShaderResourceBinding(&amp;m_SRB[tex]);</div>
<div class="line">    m_SRB[tex]-&gt;GetVariableByName(SHADER_TYPE_PIXEL, <span class="stringliteral">&quot;g_Texture&quot;</span>)-&gt;Set(m_TextureSRV[tex]);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">m_pPSO[1][0]-&gt;CreateShaderResourceBinding(&amp;m_BatchSRB);</div>
<div class="line">m_BatchSRB-&gt;GetVariableByName(SHADER_TYPE_PIXEL, <span class="stringliteral">&quot;g_Texture&quot;</span>)-&gt;Set(m_TexArraySRV);</div>
</div><!-- fragment --><p>Note that we create one SRB per texture for non-batched mode and just one SRB for batched mode.</p>
<h2><a class="anchor" id="autotoc_md325"></a>
Rendering</h2>
<p>The tutorial largely uses the same rendering scheme as <a href="../../../Tutorial06_Multithreading">Tutorial06 - Multithreading</a>. If multithreading is enabled, command lists are recorded in parallel by multiple threads and are then executed by the immediate context. An important thing to notice is that resources are transitioned to correct states once after the initialization:</p>
<div class="fragment"><div class="line">m_pImmediateContext-&gt;TransitionResourceStates(<span class="keyword">static_cast&lt;</span>Uint32<span class="keyword">&gt;</span>(Barriers.size()), Barriers.data());</div>
</div><!-- fragment --><p>This avoids checking the states inside every draw command:</p>
<div class="fragment"><div class="line"><span class="comment">// Shader resources have been explicitly transitioned to correct states, so</span></div>
<div class="line"><span class="comment">// RESOURCE_STATE_TRANSITION_MODE_TRANSITION mode is not needed.</span></div>
<div class="line"><span class="comment">// Instead, we use RESOURCE_STATE_TRANSITION_MODE_VERIFY mode to</span></div>
<div class="line"><span class="comment">// verify that all resources are in correct states. This mode only has effect</span></div>
<div class="line"><span class="comment">// in debug and development builds</span></div>
<div class="line">pCtx-&gt;CommitShaderResources(m_SRB[CurrInstData.TextureInd], RESOURCE_STATE_TRANSITION_MODE_VERIFY);</div>
</div><!-- fragment --><p>Every thread uses its own rendering context to avoid contention. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
