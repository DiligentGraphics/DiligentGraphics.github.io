<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: GLFW Demo</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d9c/DiligentSamples_Samples_GLFWDemo_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">GLFW Demo</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This simple maze mini-game demonstrates how to use <a href="https://www.glfw.org/">GLFW</a> to create window and handle keyboard and mouse input.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Samples/GLFWDemo/Animation_Large.gif" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md283"></a>
GLFW Initialization</h2>
<p>GLFW natively supports OpenGL and Vulkan only. To use all available backends, we need to use <code>GLFW_NO_API</code> flag to create GLFW window only:</p>
<div class="fragment"><div class="line">glfwInit();</div>
<div class="line">glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);</div>
<div class="line"> </div>
<div class="line">m_Window = glfwCreateWindow(Width, Height, Title, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>Initialization of the render device and device context is performed similar to other examples (take a look at Tutorial00 for instance).</p>
<p>To create a swapchain, we need to prepare the <code>NativeWindow</code> structure. To get native handles, we will use the appropriate platform-specific GLFW functions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if PLATFORM_WIN32</span></div>
<div class="line">    Win32NativeWindow Window{glfwGetWin32Window(m_Window)};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#if PLATFORM_LINUX</span></div>
<div class="line">    LinuxNativeWindow Window;</div>
<div class="line">    Window.WindowId = glfwGetX11Window(m_Window);</div>
<div class="line">    Window.pDisplay = glfwGetX11Display();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#if PLATFORM_MACOS</span></div>
<div class="line">    MacOSNativeWindow Window{GetNSWindowView(m_Window)};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>On MacOS, we need to additionally initialize <code>CAMetalLayer</code> to allow rendering into the view using the Metal API:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>* GetNSWindowView(GLFWwindow* wnd)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">id</span> Window = glfwGetCocoaWindow(wnd);</div>
<div class="line">    <span class="keywordtype">id</span> View   = [Window contentView];</div>
<div class="line">    </div>
<div class="line">    NSBundle* bundle = [NSBundle bundleWithPath:<span class="stringliteral">@&quot;/System/Library/Frameworks/QuartzCore.framework&quot;</span>];</div>
<div class="line">    <span class="keywordflow">if</span> (!bundle)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">id</span> Layer = [[bundle classNamed:<span class="stringliteral">@&quot;CAMetalLayer&quot;</span>] layer];</div>
<div class="line">    <span class="keywordflow">if</span> (!Layer)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    </div>
<div class="line">    [View setLayer:Layer];</div>
<div class="line">    [View setWantsLayer:YES];</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> View;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md284"></a>
The Maze Game</h2>
<p>The goal of this mini-game is to reach the target point in the maze using the flashlight to find the way in the dark.</p>
<p>Controls:</p><ul>
<li><code>WASD</code>, arrows, or numpad arrows: move the player.<br  />
</li>
<li><code>Tab</code>: generate new map.<br  />
</li>
<li><code>Esc</code>: exit the game.<br  />
</li>
<li>Left mouse button: activate the flashlight.<br  />
</li>
</ul>
<p>There are no pre-drawn textures and meshes in this game, only procedural content. The maze is randomly generated, the target point is placed in the empty space near one of the map borders (note that there is no 100% guarantees that the target point can be reached). For rendering, the game uses signed-distance fields (SDF) and ray marching.</p>
<p>The map is a 16-bit floating-point single-channel texture that contains:</p><ul>
<li>When outside the wall, the distance from the nearest wall; this distance has positive sign (red color).</li>
<li>When insdie the wall, the distance to the nearest empty space; this distance has negative sign (green color).</li>
</ul>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Samples/GLFWDemo/sdf_map.jpg" alt="image" class="inline"/></p>
<p>The player shape and light around the player are circles with the attenuation from the center to border. The circle function is the distance from the current pixel to the player position:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span>  DistToPlayer = distance(PosOnMap, g_PlayerConstants.PlayerPos);</div>
<div class="line"><span class="keywordtype">float</span> Factor = saturate(1.0 - DistToPlayer / g_PlayerConstants.PlayerRadius);</div>
<div class="line">Color.rgb    = Blend(Color.rgb, PlayerColor, Factor);</div>
</div><!-- fragment --><p>The target point (or the teleport to the next map) is rendered as a circle with wave animation:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> DistToTeleport = distance(PosOnMap, g_MapConstants.TeleportPos);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> WaveWidth = 0.2;</div>
<div class="line"><span class="keywordtype">float</span>       Wave      = BumpStep(DistToTeleport, g_MapConstants.TeleportWaveRadius, g_MapConstants.TeleportWaveRadius + WaveWidth);</div>
<div class="line">Color.rgb             = Blend(Color.rgb, TeleportWaveColor, Wave);</div>
</div><!-- fragment --><p><code>BumpStep()</code> in the snippet above converts the distance in the range [0, inf] to the range [WaveRadius, WaveRadius + WaveWidth], then converts it to the triangle wave <code>/\/\</code> in the range [0, 1]. The result is a circle outline.</p>
<p><code>TeleportWaveRadius</code> is animated using the <code>WaveRadius = fract(WaveRadius + TimeDelta)</code> function, and produces another triangle wave <code>/|/|</code>. It creates the repeating effect of a pulsing circle with increasing radius from 0 to 1.</p>
<p>Flashlight uses a bit more complex function. First, we calculate the distance from the current pixel to the flashlight ray. Calculate <code>A</code>, <code>B</code>, <code>C</code> coefficients of the line equation <code>Ax + By + C = 0</code> and get minimal distance from the point to the ray:</p>
<div class="fragment"><div class="line">float2 Dir       = g_PlayerConstants.FlashLightDir;</div>
<div class="line">float2 Begin     = g_PlayerConstants.PlayerPos;</div>
<div class="line">float2 End       = Begin + Dir;</div>
<div class="line"><span class="keywordtype">float</span>  A         = Begin.y - End.y;</div>
<div class="line"><span class="keywordtype">float</span>  B         = End.x - Begin.x;</div>
<div class="line"><span class="keywordtype">float</span>  C         = Begin.x * End.y - End.x * Begin.y;</div>
<div class="line"><span class="keywordtype">float</span>  DistToRay = abs((A * PosOnMap.x + B * PosOnMap.y + C) / sqrt(A * A + B * B));</div>
</div><!-- fragment --><p>This code can be simplified to:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span>  DistToRay = abs((-Dir.y * PosOnMap.x) + (Dir.x * PosOnMap.y) + (Begin.x * End.y - End.x * Begin.y));</div>
</div><!-- fragment --><p>The radius of the light cone is calculated as <code>ConeHeight * tan(Angle)/2</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span>  TanOfAngle = 0.5; <span class="comment">// tan(45 degrees) * 0.5</span></div>
<div class="line"><span class="keywordtype">float</span>  ConeRadius = DistToPlayer * TanOfAngle;</div>
</div><!-- fragment --><p>The light attenuation is proportional to the distance squared:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span>  Atten  = DistToPlayer / g_PlayerConstants.FlshLightMaxDist;</div>
<div class="line">Atten         = saturate(1.0 - Atten * Atten);</div>
<div class="line"><span class="keywordtype">float</span>  Factor = saturate(1.0 - DistToRay / ConeRadius) * g_PlayerConstants.FlashLightPower * Atten;</div>
<div class="line">LightColor    = Blend(LightColor, FlashLightColor, Factor);</div>
</div><!-- fragment --><p>To cast shadows, we use the sphere tracing algorithm on the signed distance field. We trace a ray from the current pixel position to the light source position. The function returns 1 if there are no intersections, which means the pixle is in light. All coordinates and distances in the snippet below are in SDF texture space:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> TraceRay(float2 LightPos, float2 Origin)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>  TMax    = distance(LightPos, Origin);   <span class="comment">// distance from current pixel to light source.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>  MinDist = 0.00625;                      <span class="comment">// some minimal value.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    MaxIter = 128;                          <span class="comment">// maximum number of loop cycles to prevent infinite loops.</span></div>
<div class="line">    <span class="keyword">const</span> float2 Dir     = normalize(LightPos - Origin); <span class="comment">// ray marching direction.</span></div>
<div class="line">    float2       Pos     = Origin;                       <span class="comment">// ray marching start position.</span></div>
<div class="line">    <span class="keywordtype">float</span>        t       = 0.0;                          <span class="comment">// ray length</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; MaxIter; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// read the maximum radius of the sphere inside which there are no intersections</span></div>
<div class="line">        <span class="keywordtype">float</span> d = ReadSDF(Pos);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// stop ray marching on negative or too small distance</span></div>
<div class="line">        <span class="keywordflow">if</span> (d &lt; MinDist)</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// me can increase ray length to the sphere radius</span></div>
<div class="line">        t += d;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// calculate new position</span></div>
<div class="line">        Pos = Origin + Dir * t;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// stop ray marching if ray distance is equal or greater than distance from current pixel to the light source</span></div>
<div class="line">        <span class="keywordflow">if</span> (t &gt; TMax)</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> t &gt; TMax ? 1.0 : 0.0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To implement soft shadows, we cast additional rays:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> Shading = TraceRay(g_PlayerConstants.PlayerPos, PosOnMap) * 0.5;</div>
<div class="line"> </div>
<div class="line">float2 Norm = float2(-DirToPlayer.y, DirToPlayer.x); <span class="comment">// left normal to the line</span></div>
<div class="line">Shading += TraceRay(g_PlayerConstants.PlayerPos, PosOnMap + Norm * 0.125) * 0.25;</div>
<div class="line">Shading += TraceRay(g_PlayerConstants.PlayerPos, PosOnMap - Norm * 0.125) * 0.25;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
