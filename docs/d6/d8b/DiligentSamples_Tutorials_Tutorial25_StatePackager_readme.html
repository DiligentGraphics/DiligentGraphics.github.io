<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial25 - Render State Packager</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d8b/DiligentSamples_Tutorials_Tutorial25_StatePackager_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial25 - Render State Packager</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial shows how to create and archive pipeline states with the render state packager off-line tool on the example of a simple path tracer.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial25_StatePackager/Screenshot.jpg" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md438"></a>
Render State Packager</h2>
<p><a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine allows compiling shaders from source code at run-time and using them to create pipeline states. While simple and convenient, this approach has downsides:</p>
<ul>
<li>Compiling shaders at run-time is expensive. An application that uses a lot of shaders may see significant load times.</li>
<li>Compiling shaders at run-time requires bundling the compiler with the engine. For Vulkan, this includes glslang, SPIRV-Tools and other components, which significantly increase the binary size.</li>
<li>After shaders are compiled, <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> further needs to patch them to make them compatible with the pipeline resource layout or resource signatures.</li>
</ul>
<p>Pipeline state processing can be completely performed off-line using the <a href="https://github.com/DiligentGraphics/DiligentTools/tree/master/RenderStatePackager">Render state packager</a> tool. The tool uses the <code><a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Render State Notation</code>, a JSON-based render state description language. One archive produced by the packager can contain multiple pipeline states as well as shaders and pipeline resource signatures that can be loaded and immediately used at run-time without any overhead. Each object can also contain data for different backends (e.g. DX12 and Vulkan), thus one archive can be used on different platforms.</p>
<p>Archivig pipelines off-line provides a number of benefits:</p>
<ul>
<li>Run-time loading overhead is reduced to minimum as no shader compilation or byte code patching is performed.</li>
<li>Shader compilation tool chain can be removed from the binary to reduce its size.</li>
<li>Render states are separated from the executable code that improves the code structure. Shaders and pipeline states can be updated without the need to rebuild the application.</li>
<li>Shader compilation errors and pipeline state issues are detected at build time.</li>
</ul>
<p>In this tutorial, we will use the render state packager to create an archive that contains all pipeline states required to perform basic path tracing.</p>
<h2><a class="anchor" id="autotoc_md439"></a>
Path Tracing</h2>
<p>This tutorial implements a basic path tracing algorithm with the next event estimation (aka light source sampling). In this section we provide some details about the rendering process. Additional information about path tracing can be easily found on the internet. <a href="https://github.com/RayTracing/raytracing.github.io/">Ray Tracing in One Weekend</a> and <a href="https://www.cg.tuwien.ac.at/courses/Rendering/VU/2021S">Rendering Introduction Course from TU Wien University</a> could be good starting points. <a href="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial25_StatePackager/assets/path_trace.psh">Path tracing shader source code</a> also contains a lot of additional details.</p>
<p>The rendering process consists of the following three stages:</p>
<ol type="1">
<li>G-buffer generation</li>
<li>Path tracing and radiance accumulation</li>
<li>Resolve</li>
</ol>
<p>At the first stage, the scene is rendered into a G-buffer consisting of the following render targets:</p>
<ul>
<li>Albedo (<code>RGBA8_UNORM</code>)</li>
<li>Normal (<code>RGBA8_UNORM</code>)</li>
<li>Emittance (<code>R11G11B10_FLOAT</code>)</li>
<li>Depth (<code>R32_FLOAT</code>)</li>
</ul>
<p>At the second stage, a screen-size quad is rendered that for each pixel of the G-buffer reconstructs its world-space position, traces a light path through the scene and adds the contribution to the radiance accumulation buffer. Each frame, a set number of new paths are traced and their contributions are accumulated. If camera moves or light attributes change, the accumulation buffer is cleard and the process starts over.</p>
<p>Finally, at the third stage, the radiance in the light accumulation buffer is resolved by averaging all light path contributions.</p>
<h3><a class="anchor" id="autotoc_md440"></a>
Scene Representtion</h3>
<p>For the sake of illustration, the scene in this tutorial is defined by a number of analytic shapes (boxes) and rays are traced through the scene by computing intersections with each box and finding the closest one for each ray. Real applications will likely use DXR/Vulkan ray tracing (see <a href="https://github.com/DiligentGraphics/DiligentSamples/tree/master/Tutorials/Tutorial21_RayTracing">Tutorial 21 - Ray Tracing</a> and <a href="https://github.com/DiligentGraphics/DiligentSamples/tree/master/Tutorials/Tutorial22_HybridRendering">Tutorial 22 - Hybrid Rendering</a>).</p>
<p>A box is defined by its center, size, albedo, emissive power and type:</p>
<div class="fragment"><div class="line">struct BoxInfo</div>
<div class="line">{</div>
<div class="line">    float3 Center;</div>
<div class="line">    float3 Size;</div>
<div class="line">    float3 Albedo;</div>
<div class="line">    float3 Emittance;</div>
<div class="line">    int    Type;</div>
<div class="line">};</div>
</div><!-- fragment --><p>For the <code>Type</code> field, two values are allowed: lambertian diffuse surface and light source.</p>
<p>A ray is defined by its origin and normalized direction:</p>
<div class="fragment"><div class="line">struct RayInfo</div>
<div class="line">{</div>
<div class="line">    float3 Origin;</div>
<div class="line">    float3 Dir;</div>
<div class="line">};</div>
</div><!-- fragment --><p>A hit point contains information about the color at the intersection, the surface normal, the distance from the ray origin to the hit point and also the hit type (lambertian surface, diffuse light source or none):</p>
<div class="fragment"><div class="line">struct HitInfo</div>
<div class="line">{</div>
<div class="line">    float3 Albedo;</div>
<div class="line">    float3 Emittance;</div>
<div class="line">    float3 Normal;</div>
<div class="line">    float  Distance;</div>
<div class="line">    int    Type;</div>
<div class="line">};</div>
</div><!-- fragment --><p>An intersection of the ray with the box is computed by the <code>IntersectAABB</code> function:</p>
<div class="fragment"><div class="line">bool IntersectAABB(in    RayInfo Ray,</div>
<div class="line">                   in    BoxInfo Box,</div>
<div class="line">                   inout HitInfo Hit)</div>
</div><!-- fragment --><p>The function takes the ray information, box attributes and also the current hit point information. If the new hit point is closer than the current one defined by the <code>Hit</code>, the struct is updated with the new color, normal, distance and hit type.</p>
<p>Casting a ray though the scene consists of intersecting the ray with each box:</p>
<div class="fragment"><div class="line">float RoomSize  = 10.0;</div>
<div class="line">float WallThick = 0.05;</div>
<div class="line"> </div>
<div class="line">BoxInfo Box;</div>
<div class="line">Box.Type      = HIT_TYPE_LAMBERTIAN;</div>
<div class="line">Box.Emittance = float3(0.0, 0.0, 0.0);</div>
<div class="line"> </div>
<div class="line">float3 Green = float3(0.1, 0.6, 0.1);</div>
<div class="line">float3 Red   = float3(0.6, 0.1, 0.1);</div>
<div class="line">float3 Grey  = float3(0.5, 0.5, 0.5);</div>
<div class="line"> </div>
<div class="line">// Right wall</div>
<div class="line">Box.Center = float3(RoomSize * 0.5 + WallThick * 0.5, 0.0, 0.0);</div>
<div class="line">Box.Size   = float3(WallThick, RoomSize * 0.5, RoomSize * 0.5);</div>
<div class="line">Box.Albedo = Green;</div>
<div class="line">IntersectAABB(Ray, Box, Hit);</div>
<div class="line"> </div>
<div class="line">// Left wall</div>
<div class="line">Box.Center = float3(-RoomSize * 0.5 - WallThick * 0.5, 0.0, 0.0);</div>
<div class="line">Box.Size   = float3(WallThick, RoomSize * 0.5, RoomSize * 0.5);</div>
<div class="line">Box.Albedo = Red;</div>
<div class="line">IntersectAABB(Ray, Box, Hit);</div>
<div class="line"> </div>
<div class="line">// Ceiling</div>
<div class="line">// ...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md441"></a>
G-buffer Rendering</h3>
<p>The G-buffer is rendered by a full-screen render pass, where the pixel shader performs ray casting through the scene. It starts by computing the ray starting and end points using the inverse view-projection matrix:</p>
<div class="fragment"><div class="line">float3 f3RayStart = ScreenToWorld(PSIn.Pos.xy, 0.0, g_Constants.f2ScreenSize, g_Constants.ViewProjInvMat);</div>
<div class="line">float3 f3RayEnd   = ScreenToWorld(PSIn.Pos.xy, 1.0, g_Constants.f2ScreenSize, g_Constants.ViewProjInvMat);</div>
<div class="line"> </div>
<div class="line">RayInfo Ray;</div>
<div class="line">Ray.Origin = f3RayStart; </div>
<div class="line">Ray.Dir    = normalize(f3RayEnd - f3RayStart);</div>
</div><!-- fragment --><p>Next, the shader casts a ray though the scene and writes the hit point properties to the G-buffer targets:</p>
<div class="fragment"><div class="line">PSOutput PSOut;</div>
<div class="line"> </div>
<div class="line">HitInfo Hit = IntersectScene(Ray, g_Constants.Light);</div>
<div class="line"> </div>
<div class="line">PSOut.Albedo    = float4(Hit.Albedo,   float(Hit.Type) / 255.0);</div>
<div class="line">PSOut.Emittance = float4(Hit.Emittance, 0.0);</div>
<div class="line">PSOut.Normal    = float4(saturate(Hit.Normal * 0.5 + 0.5), 0.0);</div>
</div><!-- fragment --><p>Finally, the shader computes the depth by transforming the hit point with the view-projection matrix:</p>
<div class="fragment"><div class="line">float3 HitWorldPos = Ray.Origin + Ray.Dir * Hit.Distance;</div>
<div class="line">float4 HitClipPos  = mul(float4(HitWorldPos, 1.0), g_Constants.ViewProjMat);</div>
<div class="line">PSOut.Depth        = min(HitClipPos.z / HitClipPos.w, 1.0);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md442"></a>
Path Tracing</h3>
<p>Path tracing is the core part of the rendering process and is implemented by a pixel shader that is executed for each screen pixel. The shader starts from positions defined by the G-buffer and traces a given number of light paths through the scene, each path performing a given number of bounces. For each bounce, the shader traces a ray towards the light source and computes its contribution. It then selects a random direction at the shading point using the cosine-weighted hemispherical distribution, casts a ray in this direction and repeats the process at the new location.</p>
<p>The shader starts by reading the G-buffer and reconstructing the attributes of the primary camera ray:</p>
<div class="fragment"><div class="line">HitInfo Hit0;</div>
<div class="line">RayInfo Ray0;</div>
<div class="line">GetPrimaryRay(uint2(PSIn.Pos.xy), Hit0, Ray0);</div>
</div><!-- fragment --><p>Where <code>PSIn.Pos.xy</code> are the pixel's screen coordinates.</p>
<p>The shader then prepares a two-dimensional hash seed that will be used for pseudo-random number generation:</p>
<div class="fragment"><div class="line">uint2 Seed = ThreadId.xy * uint2(11417, 7801) + uint2(g_Constants.uFrameSeed1, g_Constants.uFrameSeed2);</div>
</div><!-- fragment --><p>This is quite important moment: the seed must be unique for each frame, each sample and every bounce to produce a good random sequence. Bad sequences will result in slower convergence or biased result. <code>g_Constants.uFrameSeed1</code> and <code>g_Constants.uFrameSeed2</code> are random seeds computed by the CPU for each frame.</p>
<p>The shader then traces a given number of light paths and accumulates their contributions. Each path starts with the primary camera ray:</p>
<div class="fragment"><div class="line">HitInfo Hit = Hit0;</div>
<div class="line">RayInfo Ray = Ray0;</div>
<div class="line"> </div>
<div class="line">// Total contribution of this path</div>
<div class="line">float3 f3PathContrib = float3(0.0, 0.0, 0.0);</div>
<div class="line">if (g_Constants.iUseNEE != 0)</div>
<div class="line">{</div>
<div class="line">    // We need to add emittance from the first hit, which is like performing</div>
<div class="line">    // light source sampling for the primary ray origin (aka &quot;0-th&quot; hit).</div>
<div class="line">    f3PathContrib += Hit0.Emittance;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Path throughput, or the maximum possible remaining contribution after all bounces so far.</div>
<div class="line">float3 f3Throughput = float3(1.0, 1.0, 1.0);</div>
<div class="line">for (int j = 0; j &lt; g_Constants.iNumBounces; ++j)</div>
<div class="line">{</div>
<div class="line">    // ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the loop, the shader first samples the light source:</p>
<div class="fragment"><div class="line">// Get uniform random variables</div>
<div class="line">float2 rnd2 = hash22(Seed);</div>
<div class="line">Seed += uint2(129, 1725);</div>
<div class="line"> </div>
<div class="line">LightSampleAttribs LightSample = SampleLightSource(g_Constants.Light, rnd2, f3HitPos);</div>
</div><!-- fragment --><p>The <code>SampleLightSource</code> function samples a random point on the light source surface and evaluates terms required for the next event estimation. It starts by using two pseudo-random values in the [0, 1] range produced by the <code>hash22</code> to select a random point on the light source and computing the direction vector to this point:</p>
<div class="fragment"><div class="line">LightSampleAttribs Sample;</div>
<div class="line"> </div>
<div class="line">Sample.f3Emittance = Light.f4Intensity.rgb * Light.f4Intensity.a;</div>
<div class="line"> </div>
<div class="line">float3 f3SamplePos = GetLightSamplePos(Light, rnd2);</div>
<div class="line">Sample.f3Dir       = f3SamplePos - f3SrfPos;</div>
<div class="line">float fDistToLightSqr = dot(Sample.f3Dir, Sample.f3Dir);</div>
<div class="line">Sample.f3Dir /= sqrt(fDistToLightSqr);</div>
</div><!-- fragment --><p>Next, the function casts a shadow ray towards the selected point and computes it visibility:</p>
<div class="fragment"><div class="line">RayInfo ShadowRay;</div>
<div class="line">ShadowRay.Origin   = f3SrfPos;</div>
<div class="line">ShadowRay.Dir      = Sample.f3Dir;</div>
<div class="line">Sample.fVisibility = TestShadow(ShadowRay);</div>
</div><!-- fragment --><p>Finally, the function computes the probability density of the selected direction, which in our case is constant and is equal to 1 over the projected solid angle spanned by the light source:</p>
<div class="fragment"><div class="line">float  fLightArea    = (Light.f2SizeXZ.x * 2.0) * (Light.f2SizeXZ.y * 2.0);</div>
<div class="line">float3 f3LightNormal = Light.f4Normal.xyz;</div>
<div class="line">float  fSolidAngle   = fLightArea * max(dot(-Sample.f3Dir, f3LightNormal), 0.0) / fDistToLightSqr;</div>
<div class="line"> </div>
<div class="line">Sample.Prob = fSolidAngle &gt; 0.0 ? 1.0 / fSolidAngle : 0.0;</div>
</div><!-- fragment --><p>After we get the light source sample properties, we update the path radiance as follows:</p>
<div class="fragment"><div class="line">float NdotL = max(dot(LightSample.f3Dir, Hit.Normal), 0.0);</div>
<div class="line">f3PathContrib +=</div>
<div class="line">    f3Throughput                             // Ti-1</div>
<div class="line">    * BRDF(Hit, -Ray.Dir, LightSample.f3Dir) // BRDF(xi, vi, li)</div>
<div class="line">    * NdotL                                  // (ni, li)</div>
<div class="line">    * LightSample.f3Emittance                // L(xi, li)</div>
<div class="line">    * LightSample.fVisibility                // V(xi, li)</div>
<div class="line">    / LightSample.Prob;                      // p(li)</div>
</div><!-- fragment --><p>Where:</p>
<ul>
<li><code>f3Throughput</code> is the path throughput, i.e. the maximum possible remaining contribution after all bounces so far. Initially it is <code>float3(1, 1, 1)</code>, and is updated at each bounce.</li>
<li><code>BRDF</code> is the bidirectional reflectance distribution function that determines how much of the incoming light is reflected into the view direction. In our case, it is a simple Lambertian BRDF (perfectly diffuse surface), and equals to <code>Hit.Albedo / PI</code>.</li>
<li><code>NdotL</code> aka cos(Theta) is the cosine of the angle between the surface normal and the direction to the light source.</li>
<li><code>LightSample.f3Emittance</code> is the light source emittance.</li>
<li><code>LightSample.fVisibility</code> is the light source sample point visibility.</li>
<li><code>LightSample.Prob</code> is the probabity of selecting the direction.</li>
</ul>
<p>After adding the light contribution, we go to the next sample by selecting a random direction using the cosine-weighted hemispherical distribution:</p>
<div class="fragment"><div class="line">float3 Dir;</div>
<div class="line">float  Prob;</div>
<div class="line">SampleBRDFDirection(Hit, rnd2, Dir, Prob);</div>
</div><!-- fragment --><p><code>Dir</code> is the direction and <code>Prob</code> is its corresponding probability density. Cosine-weighted distribution assigns more random samples near the normal direction and fewer at the horizon, since they produce lesser contribution due to the 'N dot L' term.</p>
<p>We then update the throughput:</p>
<div class="fragment"><div class="line">float CosTheta = dot(Hit.Normal, Dir);</div>
<div class="line">// Ti = Ti-1 * BRDF(xi, vi, wi) * (ni, wi) / p(wi)</div>
<div class="line">f3Throughput = </div>
<div class="line">    f3Throughput                // Ti-1</div>
<div class="line">    * BRDF(Hit, -Ray.Dir, Dir)  // BRDF(xi, vi, wi)</div>
<div class="line">    * CosTheta                  // (ni, wi)</div>
<div class="line">    / Prob;                     // p(wi)</div>
</div><!-- fragment --><p>Finally, we trace a ray in the generated direction and update the hit properties:</p>
<div class="fragment"><div class="line">// Trace the scene in the selected direction</div>
<div class="line">Ray.Origin = f3HitPos;</div>
<div class="line">Ray.Dir    = Dir;</div>
<div class="line">Hit = IntersectScene(Ray, g_Constants.Light);</div>
</div><!-- fragment --><p>The process then repeats for the next surface sample location.</p>
<p>After all bounces in the path are traced, the path contribution is combined with the total radiance:</p>
<div class="fragment"><div class="line">f3Radiance += f3PathContrib;</div>
</div><!-- fragment --><p>After all samples are traced, the shader adds the total radiance to the accumulation buffer:</p>
<div class="fragment"><div class="line">if (g_Constants.fLastSampleCount &gt; 0)</div>
<div class="line">    f3Radiance += g_Radiance[ThreadId.xy].rgb;</div>
<div class="line">g_Radiance[ThreadId.xy] = float4(f3Radiance, 0.0);</div>
</div><!-- fragment --><p>The <code>fLastSampleCount</code> indicates how many samples have been accumulated so far. Zero value indicates that the shader is executed for the first time and in this case it overwrites the previous value.</p>
<p>Refer to the <a href="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial25_StatePackager/assets/path_trace.psh">shader source code</a> for additional details.</p>
<h3><a class="anchor" id="autotoc_md443"></a>
Resolve</h3>
<p>Radiance accumulation buffer resolve is done in another full-screen render pass and is pretty straightforward: it simply averages all the accumulated paths:</p>
<div class="fragment"><div class="line">void main(in  PSInput  PSIn,</div>
<div class="line">          out PSOutput PSOut)</div>
<div class="line">{</div>
<div class="line">    PSOut.Color = g_Radiance.Load(int3(PSIn.Pos.xy, 0)) / g_Constants.fCurrSampleCount;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md444"></a>
Pipeline State Packaging</h2>
<p>The three stages of the rendering process are implemented by three pipeline states. The pipelines are defined using the <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Render State Notation. They are created off-line using the render state packager and packed into a single archive. At run-time, the archive is loaded and pipelines are unpacked using the <code>IDearchiver</code> object.</p>
<h3><a class="anchor" id="autotoc_md445"></a>
Diligent Render State Notation</h3>
<p><a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Render State Notation (DRSN) is a JSON-based render state description language. The DRSN file conists of the following sections:</p>
<ul>
<li><code>Imports</code> sections defines other DRSN files whose objects should be imported into this one, pretty much the same way the <code>#include</code> directive works.</li>
<li><code>Defaults</code> section defines the default values for objects defined in the file.</li>
<li><code>Shaders</code> section contains shader descriptions.</li>
<li><code>RenderPasses</code> section defines render passes used by the pipelines.</li>
<li><code>ResourceSignatures</code> section defines pipeline resource signatures.</li>
<li><code>Pipelines</code> section contains pipeline states.</li>
</ul>
<p>All objects in DRSN files are referenced by names that must be unique for each object category. The names are used at run-time to unpack the states.</p>
<p>DRSN reflects the core structures of the engine in JSON format. For example, the G-buffer PSO is defined in DRSN as follows:</p>
<div class="fragment"><div class="line">&quot;Pipelines&quot;: [</div>
<div class="line">    {</div>
<div class="line">        &quot;PSODesc&quot;: {</div>
<div class="line">            &quot;Name&quot;: &quot;G-Buffer PSO&quot;,</div>
<div class="line">            &quot;ResourceLayout&quot;: {</div>
<div class="line">                &quot;Variables&quot;: [</div>
<div class="line">                    {</div>
<div class="line">                        &quot;Name&quot;: &quot;cbConstants&quot;,</div>
<div class="line">                        &quot;ShaderStages&quot;: &quot;PIXEL&quot;,</div>
<div class="line">                        &quot;Type&quot;: &quot;STATIC&quot;</div>
<div class="line">                    }</div>
<div class="line">                ]</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line">        &quot;GraphicsPipeline&quot;: {</div>
<div class="line">            &quot;PrimitiveTopology&quot;: &quot;TRIANGLE_LIST&quot;,</div>
<div class="line">            &quot;RasterizerDesc&quot;: {</div>
<div class="line">                &quot;CullMode&quot;: &quot;NONE&quot;</div>
<div class="line">            },</div>
<div class="line">            &quot;DepthStencilDesc&quot;: {</div>
<div class="line">                &quot;DepthEnable&quot;: false</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line">        &quot;pVS&quot;: {</div>
<div class="line">            &quot;Desc&quot;: {</div>
<div class="line">                &quot;Name&quot;: &quot;Screen Triangle VS&quot;</div>
<div class="line">            },</div>
<div class="line">            &quot;FilePath&quot;: &quot;screen_tri.vsh&quot;,</div>
<div class="line">            &quot;EntryPoint&quot;: &quot;main&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;pPS&quot;: {</div>
<div class="line">            &quot;Desc&quot;: {</div>
<div class="line">                &quot;Name&quot;: &quot;G-Buffer PS&quot;</div>
<div class="line">            },</div>
<div class="line">            &quot;FilePath&quot;: &quot;g_buffer.psh&quot;,</div>
<div class="line">            &quot;EntryPoint&quot;: &quot;main&quot;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">]</div>
</div><!-- fragment --><p>Refer to this page for more information about the <a href="https://github.com/DiligentGraphics/DiligentTools/tree/master/RenderStatePackager#render-state-notation">Diligent Render State Notation</a>.</p>
<h3><a class="anchor" id="autotoc_md446"></a>
Packager Command Line</h3>
<p>This tutorial uses the following command line to create the archive:</p>
<div class="fragment"><div class="line">Diligent-RenderStatePackager.exe -i RenderStates.json -r assets -s assets -o assets/StateArchive.bin --dx11 --dx12 --opengl --vulkan --metal_macos --metal_ios --print_contents</div>
</div><!-- fragment --><p>The command line uses the following options:</p>
<ul>
<li><code>-i</code> - The input DRSN file</li>
<li><code>-r</code> - Render state notation files search directory</li>
<li><code>-s</code> - Shader search directory</li>
<li><code>-o</code> - Output archive file</li>
<li><code>--dx11</code>, <code>--dx12</code>, <code>--opengl</code>, <code>--vulkan</code>, <code>--metal_macos</code>, <code>--metal_ios</code> - device flags for which to generate the pipeline data. Note that devices not supported on a platform (e.g. <code>--metal_macos</code> on Windows, or <code>--dx11</code> on Linux) are ignored.</li>
<li><code>--print_contents</code> - Print the archive contents to the log</li>
</ul>
<p>For the <a href="https://github.com/DiligentGraphics/DiligentTools/tree/master/RenderStatePackager#command-line-arguments">full list of command line options</a>, run the packager with <code>-h</code> or <code>--help</code> option.</p>
<p>If you use CMake, you can define a custom command to create the archive as a build step:</p>
<div class="fragment"><div class="line">set(PSO_ARCHIVE ${CMAKE_CURRENT_SOURCE_DIR}/assets/StateArchive.bin)</div>
<div class="line">set_source_files_properties(${PSO_ARCHIVE} PROPERTIES GENERATED TRUE)</div>
<div class="line"> </div>
<div class="line">set(DEVICE_FLAGS --dx11 --dx12 --opengl --vulkan --metal_macos --metal_ios)</div>
<div class="line">add_custom_command(OUTPUT ${PSO_ARCHIVE} # We must use full path here!</div>
<div class="line">                   COMMAND $&lt;TARGET_FILE:Diligent-RenderStatePackager&gt; -i RenderStates.json -r assets -s assets -o &quot;${PSO_ARCHIVE}&quot; ${DEVICE_FLAGS} --print_contents</div>
<div class="line">                   WORKING_DIRECTORY &quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;</div>
<div class="line">                   MAIN_DEPENDENCY &quot;${CMAKE_CURRENT_SOURCE_DIR}/assets/RenderStates.json&quot;</div>
<div class="line">                   DEPENDS &quot;${CMAKE_CURRENT_SOURCE_DIR}/assets/screen_tri.vsh&quot;</div>
<div class="line">                           &quot;${CMAKE_CURRENT_SOURCE_DIR}/assets/g_buffer.psh&quot;</div>
<div class="line">                           &quot;${CMAKE_CURRENT_SOURCE_DIR}/assets/resolve.psh&quot;</div>
<div class="line">                           &quot;${CMAKE_CURRENT_SOURCE_DIR}/assets/path_trace.csh&quot;</div>
<div class="line">                           &quot;${CMAKE_CURRENT_SOURCE_DIR}/assets/structures.fxh&quot;</div>
<div class="line">                           &quot;${CMAKE_CURRENT_SOURCE_DIR}/assets/scene.fxh&quot;</div>
<div class="line">                           &quot;${CMAKE_CURRENT_SOURCE_DIR}/assets/hash.fxh&quot;</div>
<div class="line">                           &quot;$&lt;TARGET_FILE:Diligent-RenderStatePackager&gt;&quot;</div>
<div class="line">                   COMMENT &quot;Creating render state archive...&quot;</div>
<div class="line">                   VERBATIM</div>
<div class="line">)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md447"></a>
Unpacking the Pipeline States</h3>
<p>To unpack pipeline states from the archive, first create a dearciver object using the engine factory:</p>
<div class="fragment"><div class="line">RefCntAutoPtr&lt;IDearchiver&gt; pDearchiver;</div>
<div class="line">DearchiverCreateInfo       DearchiverCI{};</div>
<div class="line">m_pEngineFactory-&gt;CreateDearchiver(DearchiverCI, &amp;pDearchiver);</div>
</div><!-- fragment --><p>Then read the archive data from the file and load it into the dearchiver:</p>
<div class="fragment"><div class="line">FileWrapper pArchive{<span class="stringliteral">&quot;StateArchive.bin&quot;</span>};</div>
<div class="line">RefCntAutoPtr&lt;DataBlobImpl&gt; pArchiveData = DataBlobImpl::Create();</div>
<div class="line">pArchive-&gt;Read(pArchiveData);</div>
<div class="line">pDearchiver-&gt;LoadArchive(pArchiveData);</div>
</div><!-- fragment --><p>To unpack the pipeline state from the archive, populate an instance of <code>PipelineStateUnpackInfo</code> struct with the pipeline type and name. Also, provide a pointer to the render device:</p>
<div class="fragment"><div class="line">PipelineStateUnpackInfo UnpackInfo;</div>
<div class="line">UnpackInfo.pDevice      = m_pDevice;</div>
<div class="line">UnpackInfo.PipelineType = PIPELINE_TYPE_GRAPHICS;</div>
<div class="line">UnpackInfo.Name         = <span class="stringliteral">&quot;Resolve PSO&quot;</span>;</div>
</div><!-- fragment --><p>While most of the pipeline state parameters can be defined at build time, some can only be specified at run-time. For instance, the swap chain format may not be known at the archive packing time. The dearchiver gives an application a chance to modify some of the pipeline state create properties through a special callback. Properties that can be modified include render target and depth buffer formats, depth-stencil state, blend state, rasterizer state. Note that properties that define the resource layout can't be modified. Note also that modifying properties does not affect the loading speed as no shader recompilation or patching is necessary.</p>
<p>We define the callback that sets the render target formats using the <code>MakeCallback</code> helper function:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ModifyResolvePSODesc = MakeCallback(</div>
<div class="line">    [<span class="keyword">this</span>](PipelineStateCreateInfo&amp; PSODesc) {</div>
<div class="line">        GraphicsPipelineStateCreateInfo&amp; GraphicsPSOCI    = <span class="keyword">static_cast&lt;</span>GraphicsPipelineStateCreateInfo&amp;<span class="keyword">&gt;</span>(PSODesc);</div>
<div class="line">        GraphicsPipelineDesc&amp;            GraphicsPipeline = GraphicsPSOCI.GraphicsPipeline;</div>
<div class="line"> </div>
<div class="line">        GraphicsPipeline.<a class="code hl_variable" href="../../d8/d14/structDiligent_1_1GraphicsPipelineDesc.html#a79e3c1dfb4c148b33a7e5d4ba171ba3e">NumRenderTargets</a> = 1;</div>
<div class="line">        GraphicsPipeline.RTVFormats[0]    = m_pSwapChain-&gt;GetDesc().ColorBufferFormat;</div>
<div class="line">        GraphicsPipeline.DSVFormat        = m_pSwapChain-&gt;GetDesc().DepthBufferFormat;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">UnpackInfo.ModifyPipelineStateCreateInfo = ModifyResolvePSODesc;</div>
<div class="line">UnpackInfo.pUserData                     = ModifyResolvePSODesc;</div>
<div class="ttc" id="astructDiligent_1_1GraphicsPipelineDesc_html_a79e3c1dfb4c148b33a7e5d4ba171ba3e"><div class="ttname"><a href="../../d8/d14/structDiligent_1_1GraphicsPipelineDesc.html#a79e3c1dfb4c148b33a7e5d4ba171ba3e">Diligent::GraphicsPipelineDesc::NumRenderTargets</a></div><div class="ttdeci">Uint8 NumRenderTargets</div><div class="ttdoc">The number of render targets in the RTVFormats array.</div><div class="ttdef"><b>Definition</b> PipelineState.h:318</div></div>
</div><!-- fragment --><p>Finally, we call the <code>UnpackPipelineState</code> method to create the PSO from the archive:</p>
<div class="fragment"><div class="line">pDearchiver-&gt;UnpackPipelineState(UnpackInfo, &amp;m_pResolvePSO);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md448"></a>
Rendering</h3>
<p>After the pipeline states are unpacked from the archive, they can be used in a usual way. We need to create the shader resource binding objects and initialize the variables.</p>
<p>To render the scene, we run each of the three stages described above. First, populate the G-buffer:</p>
<div class="fragment"><div class="line">ITextureView* ppRTVs[] = {</div>
<div class="line">    m_GBuffer.pAlbedo-&gt;GetDefaultView(TEXTURE_VIEW_RENDER_TARGET),</div>
<div class="line">    m_GBuffer.pNormal-&gt;GetDefaultView(TEXTURE_VIEW_RENDER_TARGET),</div>
<div class="line">    m_GBuffer.pEmittance-&gt;GetDefaultView(TEXTURE_VIEW_RENDER_TARGET),</div>
<div class="line">    m_GBuffer.pDepth-&gt;GetDefaultView(TEXTURE_VIEW_RENDER_TARGET)</div>
<div class="line">};</div>
<div class="line">m_pImmediateContext-&gt;SetRenderTargets(_countof(ppRTVs), ppRTVs, <span class="keyword">nullptr</span>, RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;CommitShaderResources(m_pGBufferSRB, RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line">m_pImmediateContext-&gt;SetPipelineState(m_pGBufferPSO);</div>
<div class="line">m_pImmediateContext-&gt;Draw({3, DRAW_FLAG_VERIFY_ALL});</div>
</div><!-- fragment --><p>Next, perform the path tracing using the full-screen render pass:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Uint32 SRBIndex = m_CurrentFrameNumber &amp; 0x01;</div>
<div class="line"> </div>
<div class="line">ITextureView* ppRTVs[] = {</div>
<div class="line">    m_pRadianceAccumulationBuffer[SRBIndex]-&gt;GetDefaultView(TEXTURE_VIEW_RENDER_TARGET) <span class="comment">//</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;SetRenderTargets(_countof(ppRTVs), ppRTVs, <span class="keyword">nullptr</span>, RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;CommitShaderResources(m_pPathTraceSRB[SRBIndex], RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line">m_pImmediateContext-&gt;SetPipelineState(m_pPathTracePSO);</div>
<div class="line">m_pImmediateContext-&gt;Draw({3, DRAW_FLAG_VERIFY_ALL});</div>
</div><!-- fragment --><p>Finally, resolve radiance:</p>
<div class="fragment"><div class="line">ITextureView* ppRTVs[] = {m_pSwapChain-&gt;GetCurrentBackBufferRTV()};</div>
<div class="line">m_pImmediateContext-&gt;SetRenderTargets(_countof(ppRTVs), ppRTVs, m_pSwapChain-&gt;GetDepthBufferDSV(), RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;SetPipelineState(m_pResolvePSO);</div>
<div class="line">m_pImmediateContext-&gt;CommitShaderResources(m_pResolveSRB[SRBIndex], RESOURCE_STATE_TRANSITION_MODE_TRANSITION);</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;Draw({3, DRAW_FLAG_VERIFY_ALL});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md449"></a>
Controlling the Application</h3>
<ul>
<li><em>Move camera</em>: left mouse button + WSADQE</li>
<li><em>Move light</em>: right mouse button</li>
</ul>
<p>You can also change the following parameters:</p><ul>
<li><em>Num bounces</em> - the number of bounces in each path</li>
<li><em>Show only last bounce</em> - render only the last bounce in the path</li>
<li><em>Next Event Estimation</em> - whether to perform next event estimation at each bounce</li>
<li><em>Samples per frame</em> - the number of light paths to take each frame for each pixel</li>
<li><em>Light intensity</em>, <em>width</em>, <em>height</em> and <em>color</em> - different light parameters</li>
</ul>
<h2><a class="anchor" id="autotoc_md450"></a>
Resources</h2>
<ol type="1">
<li><a href="https://github.com/RayTracing/raytracing.github.io/">Ray Tracing in One Weekend</a> by P.Shirley</li>
<li><a href="https://www.pbrt.org/">Physically Based Rendering: From Theory to Implementation</a> by M.Pharr, W.Jakob, and G.Humphreys</li>
<li><a href="https://www.cg.tuwien.ac.at/courses/Rendering/VU/2021S">Rendering Introduction Course from TU Wien University</a> by B.Kerbl, and A.Celarek </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
