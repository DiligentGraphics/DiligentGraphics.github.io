<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial21 - Ray Tracing</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/d66/DiligentSamples_Tutorials_Tutorial21_RayTracing_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial21 - Ray Tracing</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates the basics of using ray tracing API in <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial21_RayTracing/Animation_Large.gif" alt="" class="inline"/></p>
<p>In a traditional rendering pipeline triangles are processed by a number of programmable and fixed-function stages and are eventually projected and rasterized over the regular pixel grid. The final color is formed by a pixel shader and a number of optional blending operations. This is a very efficient and high-performance method, but performance comes for the price of a number of limitations. First, the pixel shader can only be invoked for the predefined sample locations (which enables GPUs to parallelize the execution very efficiently). Second, the GPU does not have access to the whole scene and only triangles visible by the camera are processed.</p>
<p>Ray tracing removes these limitations. Unlike the rasterization, it allows application to query scene properties at any location by casting a ray in any direction and running a specified shader at the intersection point. Ray tracing unlocks a variety of algorithms that have no efficient implementation in rasterization-based pipeline.</p>
<p>This tutorial demonstrates how ray tracing API in <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine can be used to simulate physics-based light transport in a scene to render soft shadows, multiple-bounce reflections and refractions, and dispersion.</p>
<p>Ray tracing is supported in D3D12 and Vulkan backends. <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine exposes common API for both backends and require no special handling for any of them. Shaders authored in HLSL will work in both backends without any special tricks or hacks. Vulkan backend can also take ray tracing shaders written in GLSL as well as compiled SPIRV bytecode.</p>
<h2><a class="anchor" id="autotoc_md404"></a>
Acceleration Structures</h2>
<p>Unlike rasterization, where objects do not require any pre-processing and can be thrown into the pipeline rightaway, things are a bit more complicated in ray tracing. Since a ray can be cast in any direction, the GPU must have an efficient way of intersecting the ray with the entire scene. This way is provided by acceleration structures that internally encomass some sort of bounding volume hierarchies.</p>
<p>There are two types of acceleration structures (AS) in ray tracing API: bottom-level AS, and top-level AS. Bottom-level acceleration structure (BLAS) is where the actual geometry resides. Top-level acceleration structure is a set of references to one or more BLASes. One TLAS may reference multiple instances of the same BLAS with different transformations. BLASes are more expensive to build or update than TLASes. The two-level structure is a trade-off between the ability to update the AS at run-time and ray tracing efficiency. For example, object animation can be implemented by updating instance transformations in the TLAS without the need to rebuild BLASes that represent animated objects.</p>
<h3><a class="anchor" id="autotoc_md405"></a>
Creating Bottom-level Acceleration Structures</h3>
<p>There are two types of geometries that a BLAS can contain: triangle geometry or procedural. Triangle geometry is represented by a conventional set of vertices and indices. Procedural geometry requires an application to define a special type of shader that determines how a ray intersects the object. That shader can implement any custom algorithm, but is more expensive than a built-in ray-triangle intersection test.</p>
<p>A single BLAS may contain only one type of geometry: either triangles or axis-aligned bounding boxes (AABBs) that define the basic object shape.</p>
<p>In this tutorial we will be using two types of objects: a cube and a sphere. The cube will be defined by a triangle geometry, while the sphere will be defined as procedural geometry. The cube data will be the same as in previous tutorials, but we will access it through a uniform buffer, so that a closest hit shader can read triangle properties (position, normal, UVs) for any primitive.</p>
<p>For our cube BLAS, we specify a single triangle geometry with 24 vertices and 12 primitives. BLAS will allocate space that is enough for this geometry description:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> float3 CubePos[24] = <span class="comment">/* ... */</span>;</div>
<div class="line"><span class="keyword">const</span> uint   Indices[36] = <span class="comment">/* ... */</span>;</div>
<div class="line"> </div>
<div class="line">BLASTriangleDesc Triangles;</div>
<div class="line">Triangles.<a class="code hl_variable" href="../../de/d32/structDiligent_1_1BLASTriangleDesc.html#a01956d1742008b133a110af446650bf4">GeometryName</a>         = <span class="stringliteral">&quot;Cube&quot;</span>;</div>
<div class="line">Triangles.MaxVertexCount       = _countof(CubePos);</div>
<div class="line">Triangles.VertexValueType      = VT_FLOAT32;</div>
<div class="line">Triangles.VertexComponentCount = 3;</div>
<div class="line">Triangles.MaxPrimitiveCount    = _countof(Indices) / 3;</div>
<div class="line">Triangles.IndexType            = VT_UINT32;</div>
<div class="line"> </div>
<div class="line">BottomLevelASDesc ASDesc;</div>
<div class="line">ASDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>          = <span class="stringliteral">&quot;Cube BLAS&quot;</span>;</div>
<div class="line">ASDesc.Flags         = RAYTRACING_BUILD_AS_PREFER_FAST_TRACE;</div>
<div class="line">ASDesc.pTriangles    = &amp;Triangles;</div>
<div class="line">ASDesc.TriangleCount = 1;</div>
<div class="line"> </div>
<div class="line">m_pDevice-&gt;CreateBLAS(ASDesc, &amp;m_pCubeBLAS);</div>
<div class="ttc" id="astructDiligent_1_1BLASTriangleDesc_html_a01956d1742008b133a110af446650bf4"><div class="ttname"><a href="../../de/d32/structDiligent_1_1BLASTriangleDesc.html#a01956d1742008b133a110af446650bf4">Diligent::BLASTriangleDesc::GeometryName</a></div><div class="ttdeci">const Char * GeometryName</div><div class="ttdoc">Geometry name.</div><div class="ttdef"><b>Definition</b> BottomLevelAS.h:59</div></div>
<div class="ttc" id="astructDiligent_1_1DeviceObjectAttribs_html_a14a31dc6ad69e0b79514e5349e9b4fc0"><div class="ttname"><a href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Diligent::DeviceObjectAttribs::Name</a></div><div class="ttdeci">const Char * Name</div><div class="ttdoc">Object name.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1319</div></div>
</div><!-- fragment --><p>Note that in this tutorial <code>GeometryName</code> member is not used anywhere else except in BLAS build, but in other cases, the geometry name may be used to change geometry data using BLAS update operation. Geometry name may also be used in a shader binding table as described below (see Shader binding table).</p>
<p>The cube BLAS is now created, but contains no data: we need to initialize it. For that, we will need to create regular vertex and index buffers, with the only difference that we will use the <code>BIND_RAY_TRACING</code> flag to allow access to the buffers during the BLAS build operation. All buffers which are used in BLAS or TLAS build commands must be created with <code>BIND_RAY_TRACING</code> flag. The GPU will need some scratch space to perform the build operation and keep temporary data. The scratch buffer must be given to <code>BuildBLAS</code> command. Call <code>m_pCubeBLAS-&gt;GetScratchBufferSizes()</code> to get the minimal buffer size.</p>
<div class="fragment"><div class="line">BLASBuildTriangleData TriangleData;</div>
<div class="line">TriangleData.<a class="code hl_variable" href="../../d9/db3/structDiligent_1_1BLASBuildTriangleData.html#ac5ce706f43021ada256d7453bc9eec32">GeometryName</a>         = Triangles.GeometryName;</div>
<div class="line">TriangleData.pVertexBuffer        = pCubeVertexBuffer;</div>
<div class="line">TriangleData.VertexStride         = <span class="keyword">sizeof</span>(CubePos[0]);</div>
<div class="line">TriangleData.VertexCount          = Triangles.MaxVertexCount;</div>
<div class="line">TriangleData.VertexValueType      = Triangles.VertexValueType;</div>
<div class="line">TriangleData.VertexComponentCount = Triangles.VertexComponentCount;</div>
<div class="line">TriangleData.pIndexBuffer         = CubeIndexBuffer;</div>
<div class="line">TriangleData.PrimitiveCount       = Triangles.MaxPrimitiveCount;</div>
<div class="line">TriangleData.IndexType            = Triangles.IndexType;</div>
<div class="line">TriangleData.Flags                = RAYTRACING_GEOMETRY_FLAG_OPAQUE;</div>
<div class="line"> </div>
<div class="line">BuildBLASAttribs Attribs;</div>
<div class="line">Attribs.<a class="code hl_variable" href="../../d9/d99/structDiligent_1_1BuildBLASAttribs.html#a7cb094945955259a3bb0e6a353018d84">pBLAS</a>             = m_pCubeBLAS;</div>
<div class="line">Attribs.pTriangleData     = &amp;TriangleData;</div>
<div class="line">Attribs.TriangleDataCount = 1;</div>
<div class="line">Attribs.pScratchBuffer    = pScratchBuffer;</div>
<div class="line"> </div>
<div class="line">m_pImmediateContext-&gt;BuildBLAS(Attribs);</div>
<div class="ttc" id="astructDiligent_1_1BLASBuildTriangleData_html_ac5ce706f43021ada256d7453bc9eec32"><div class="ttname"><a href="../../d9/db3/structDiligent_1_1BLASBuildTriangleData.html#ac5ce706f43021ada256d7453bc9eec32">Diligent::BLASBuildTriangleData::GeometryName</a></div><div class="ttdeci">const Char * GeometryName</div><div class="ttdoc">Geometry name used to map a geometry to a hit group in the shader binding table.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:1314</div></div>
<div class="ttc" id="astructDiligent_1_1BuildBLASAttribs_html_a7cb094945955259a3bb0e6a353018d84"><div class="ttname"><a href="../../d9/d99/structDiligent_1_1BuildBLASAttribs.html#a7cb094945955259a3bb0e6a353018d84">Diligent::BuildBLASAttribs::pBLAS</a></div><div class="ttdeci">IBottomLevelAS * pBLAS</div><div class="ttdoc">Target bottom-level AS.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:1436</div></div>
</div><!-- fragment --><p>Note that <code>GeometryName</code> member of <code>BLASBuildTriangleData</code> struct instance must match the geomertry name used in <code>BLASTriangleDesc</code>. When BLAS contains multiple geometries, this is how triangle data is mapped to the specific geometry in the BLAS.</p>
<p>Creating BLAS for procedural sphere is performed in a similar fashion.</p>
<h3><a class="anchor" id="autotoc_md406"></a>
Creating Top-level Acceleration Structure</h3>
<p>Top-level acceleration structure represents the entire scene and consists of multiple BLAS instances. To create a TLAS, we only need to specify the number of instances it will contain:</p>
<div class="fragment"><div class="line">TopLevelASDesc TLASDesc;</div>
<div class="line">TLASDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>             = <span class="stringliteral">&quot;TLAS&quot;</span>;</div>
<div class="line">TLASDesc.MaxInstanceCount = NumInstances;</div>
<div class="line">TLASDesc.Flags            = RAYTRACING_BUILD_AS_ALLOW_UPDATE | RAYTRACING_BUILD_AS_PREFER_FAST_TRACE;</div>
<div class="line">m_pDevice-&gt;CreateTLAS(TLASDesc, &amp;m_pTLAS);</div>
</div><!-- fragment --><p>Additional flags tell the system how the structure will be used by the application: <code>RAYTRACING_BUILD_AS_ALLOW_UPDATE</code> flag allows the TLAS to be updated after it has been created with different instance transformations; <code>RAYTRACING_BUILD_AS_PREFER_FAST_TRACE</code> flag tells the GPU to make some optimization to improve ray tracing efficiency, for the price of extra build time.</p>
<p>Similar to BLAS, a new TLAS contains no data and needs to be built. To build a TLAS, we need to prepare an array of <code>TLASBuildInstanceData</code> structs, where every element will contain the instance data:</p>
<div class="fragment"><div class="line">Instances[0].InstanceName = <span class="stringliteral">&quot;Cube Instance 1&quot;</span>;</div>
<div class="line">Instances[0].CustomId     = 0; <span class="comment">// texture index</span></div>
<div class="line">Instances[0].pBLAS        = m_pCubeBLAS;</div>
<div class="line">Instances[0].Mask         = OPAQUE_GEOM_MASK;</div>
<div class="line"> </div>
<div class="line">Instances[1].InstanceName = <span class="stringliteral">&quot;Cube Instance 2&quot;</span>;</div>
<div class="line">Instances[1].CustomId     = 1; <span class="comment">// texture index</span></div>
<div class="line">Instances[1].pBLAS        = m_pCubeBLAS;</div>
<div class="line">Instances[1].Mask         = OPAQUE_GEOM_MASK;</div>
<div class="line">AnimateOpaqueCube(Instances[1]);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">Instances[5].InstanceName = <span class="stringliteral">&quot;Sphere Instance&quot;</span>;</div>
<div class="line">Instances[5].CustomId     = 0; <span class="comment">// box index</span></div>
<div class="line">Instances[5].pBLAS        = m_pProceduralBLAS;</div>
<div class="line">Instances[5].Mask         = OPAQUE_GEOM_MASK;</div>
<div class="line"> </div>
<div class="line">Instances[6].InstanceName = <span class="stringliteral">&quot;Glass Instance&quot;</span>;</div>
<div class="line">Instances[6].pBLAS        = m_pCubeBLAS;</div>
<div class="line">Instances[6].Mask         = TRANSPARENT_GEOM_MASK;</div>
</div><!-- fragment --><p>The <code>InstanceName</code> member is used in TLAS update operation to match the instance data to the previous instance state and is also used in the shader binding table to bind the shader hit groups to instances (see Shader binding table).</p>
<p>Hit shader can query the instance index in the array via <code>InstanceIndex()</code> function. <code>CustomId</code> member is specified by the user and is passed to the hit shader via <code>InstanceID()</code> function. <code>CustomId</code> may be used to apply different materials to each instance with the same geometry.</p>
<p><code>Mask</code> can be used to group instances and trace rays only against selected groups (e.g. shadow rays vs primary rays).</p>
<p>For each instance, we specify the transformation matrix with the rotation and translation:</p>
<div class="fragment"><div class="line">Instances[6].Transform.SetTranslation(3.0f, 4.0f, -5.0f);</div>
</div><!-- fragment --><p>Updating the instance transformation during the TLAS update operation is much faster than updating BLAS with vertex transformation or using the transform buffer.</p>
<p>To build/update TLAS, we need to prepare an instance of <code>BuildTLASAttribs</code> struct:</p>
<div class="fragment"><div class="line">BuildTLASAttribs Attribs;</div>
<div class="line">Attribs.<a class="code hl_variable" href="../../d1/dc4/structDiligent_1_1BuildTLASAttribs.html#a725d2c55e060770deeded60067958bf5">HitGroupStride</a> = HIT_GROUP_STRIDE;</div>
<div class="line">Attribs.BindingMode    = HIT_GROUP_BINDING_MODE_PER_INSTANCE;</div>
<div class="ttc" id="astructDiligent_1_1BuildTLASAttribs_html_a725d2c55e060770deeded60067958bf5"><div class="ttname"><a href="../../d1/dc4/structDiligent_1_1BuildTLASAttribs.html#a725d2c55e060770deeded60067958bf5">Diligent::BuildTLASAttribs::HitGroupStride</a></div><div class="ttdeci">Uint32 HitGroupStride</div><div class="ttdoc">The number of hit shaders that can be bound for a single geometry or an instance (depends on BindingM...</div><div class="ttdef"><b>Definition</b> DeviceContext.h:1668</div></div>
</div><!-- fragment --><p><code>HitGroupStride</code> is the number of different ray types. In this tutorial we use two ray types: primary and shadow. You may add more ray types, e.g. a secondary ray that uses simplified hit shaders for reflected rays.</p>
<p><code>BindingMode</code> is the hit group location calculation mode. In our example we will be assigning different hit groups to different instances, so we use the <code>HIT_GROUP_BINDING_MODE_PER_INSTANCE</code> mode. If an application needs more control, it can use <code>HIT_GROUP_BINDING_MODE_PER_GEOMETRY</code> mode to assign indiviudal hit group to each geometry within every instance. On the other hand, it can use <code>HIT_GROUP_BINDING_MODE_PER_TLAS</code> mode to assign the same hit group to all geometries in all instances.</p>
<p>The actual TLAS instance data is stored in an instance buffer. The required size per one instance is fixed and is given by <code>TLAS_INSTANCE_DATA_SIZE</code> constant (64 bytes).</p>
<p>Similar to BLAS build operation, the GPU requires a scratch buffer to keep temporary data. The required scratch buffer sizes for building and updating is given by <code>m_pTLAS-&gt;GetScratchBufferSizes()</code> method.</p>
<div class="fragment"><div class="line">Attribs.pInstances      = Instances;</div>
<div class="line">Attribs.InstanceCount   = _countof(Instances);</div>
<div class="line">Attribs.pInstanceBuffer = m_InstanceBuffer;</div>
<div class="line">Attribs.pScratchBuffer  = m_ScratchBuffer;</div>
<div class="line">Attribs.pTLAS           = m_pTLAS;</div>
<div class="line">m_pImmediateContext-&gt;BuildTLAS(Attribs);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md407"></a>
Initializing the Pipeline State</h2>
<p>Ray tracing pipeline state object is more complex than a graphics or a compute pipeline as there may be multiple shaders of the same type in one shader stage. This is required so that the GPU can run different shaders when hitting different objects.</p>
<p>Similar to other pipeline types, we start by creating all shaders that will be used by the ray tracing pipeline. <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine allows using HLSL for both D3D12 and Vulkan backends. The minimum HLSL shader model that supports ray tracing is 6.3. Only the new DirectX compiler (DXC) supports shader model 6.0+, and we need to explicitly specify it:</p>
<div class="fragment"><div class="line">ShaderCI.ShaderCompiler = SHADER_COMPILER_DXC;</div>
<div class="line">ShaderCI.HLSLVersion    = {6, 3};</div>
<div class="line">ShaderCI.SourceLanguage = SHADER_SOURCE_LANGUAGE_HLSL;</div>
</div><!-- fragment --><p>To create a ray tracing PSO, we need to define an instance of <code>RayTracingPipelineStateCreateInfo</code> struct:</p>
<div class="fragment"><div class="line">RayTracingPipelineStateCreateInfo PSOCreateInfo;</div>
<div class="line">PSOCreateInfo.<a class="code hl_variable" href="../../da/d41/structDiligent_1_1PipelineStateCreateInfo.html#a7c216c149f216b75c424c9190cd160ec">PSODesc</a>.<a class="code hl_variable" href="../../d1/da6/structDiligent_1_1PipelineStateDesc.html#a05391765b168a8af66f2debc7dd3e0a2">PipelineType</a> = PIPELINE_TYPE_RAY_TRACING;</div>
<div class="ttc" id="astructDiligent_1_1PipelineStateCreateInfo_html_a7c216c149f216b75c424c9190cd160ec"><div class="ttname"><a href="../../da/d41/structDiligent_1_1PipelineStateCreateInfo.html#a7c216c149f216b75c424c9190cd160ec">Diligent::PipelineStateCreateInfo::PSODesc</a></div><div class="ttdeci">PipelineStateDesc PSODesc</div><div class="ttdoc">Pipeline state description.</div><div class="ttdef"><b>Definition</b> PipelineState.h:702</div></div>
<div class="ttc" id="astructDiligent_1_1PipelineStateDesc_html_a05391765b168a8af66f2debc7dd3e0a2"><div class="ttname"><a href="../../d1/da6/structDiligent_1_1PipelineStateDesc.html#a05391765b168a8af66f2debc7dd3e0a2">Diligent::PipelineStateDesc::PipelineType</a></div><div class="ttdeci">PIPELINE_TYPE PipelineType</div><div class="ttdoc">Pipeline type.</div><div class="ttdef"><b>Definition</b> PipelineState.h:593</div></div>
</div><!-- fragment --><p>The main component of a ray tracing pipeline is a set of shader hit groups. There are three group types:</p>
<ul>
<li><em>General hit group</em> that contains a single ray generation, ray miss or callable shader.</li>
<li><em>Triangle hit group</em> that contains a closest hit shader and an optional any-hit shader.</li>
<li><em>Procedural hit group</em> that contains an intersection shader and optional closest hit and any-hit shaders.</li>
</ul>
<p>Our ray-tracing pipeline will contain the following hit groups:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> RayTracingGeneralShaderGroup GeneralShaders[] =</div>
<div class="line">{</div>
<div class="line">    {<span class="stringliteral">&quot;Main&quot;</span>,        pRG},</div>
<div class="line">    {<span class="stringliteral">&quot;PrimaryMiss&quot;</span>, pPrimaryMiss},</div>
<div class="line">    {<span class="stringliteral">&quot;ShadowMiss&quot;</span>,  pShadowMiss}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">const</span> RayTracingTriangleHitShaderGroup TriangleHitShaders[] =</div>
<div class="line">{</div>
<div class="line">    {<span class="stringliteral">&quot;CubePrimaryHit&quot;</span>,  pCubePrimaryHit},</div>
<div class="line">    {<span class="stringliteral">&quot;GroundHit&quot;</span>,       pGroundHit},</div>
<div class="line">    {<span class="stringliteral">&quot;GlassPrimaryHit&quot;</span>, pGlassPrimaryHit}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">const</span> RayTracingProceduralHitShaderGroup ProceduralHitShaders[] =</div>
<div class="line">{</div>
<div class="line">    {<span class="stringliteral">&quot;SpherePrimaryHit&quot;</span>, pSphereIntersection, pSpherePrimaryHit},</div>
<div class="line">    {<span class="stringliteral">&quot;SphereShadowHit&quot;</span>,  pSphereIntersection}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">PSOCreateInfo.pGeneralShaders          = GeneralShaders;</div>
<div class="line">PSOCreateInfo.GeneralShaderCount       = _countof(GeneralShaders);</div>
<div class="line">PSOCreateInfo.pTriangleHitShaders      = TriangleHitShaders;</div>
<div class="line">PSOCreateInfo.TriangleHitShaderCount   = _countof(TriangleHitShaders);</div>
<div class="line">PSOCreateInfo.pProceduralHitShaders    = ProceduralHitShaders;</div>
<div class="line">PSOCreateInfo.ProceduralHitShaderCount = _countof(ProceduralHitShaders);</div>
</div><!-- fragment --><p>Besides the hit groups, we must define a few additional fields:</p>
<div class="fragment"><div class="line">PSOCreateInfo.RayTracingPipeline.MaxRecursionDepth = MaxRecursionDepth;</div>
<div class="line">PSOCreateInfo.RayTracingPipeline.ShaderRecordSize  = 0;</div>
<div class="line"> </div>
<div class="line">PSOCreateInfo.MaxAttributeSize = max(<span class="keyword">sizeof</span>(<span class="comment">/*BuiltInTriangleIntersectionAttributes*/</span>float2), <span class="keyword">sizeof</span>(ProceduralGeomIntersectionAttribs));</div>
<div class="line">PSOCreateInfo.MaxPayloadSize   = max(<span class="keyword">sizeof</span>(PrimaryRayPayload), <span class="keyword">sizeof</span>(ShadowRayPayload));</div>
</div><!-- fragment --><p><code>MaxRecursionDepth</code> specifies the number of recursive calls that an application may make in ray tracing shaders. Zero means that only ray generation shader may be executed. 1 means that ray generation shader may spawn rays that will not be allowed to generate another rays. 2 means that closest hit shaders of the rays spawned by the ray generation shader will also be allowed to generated secondary rays, etc.</p>
<p><code>MaxRecursionDepth</code> field is used by the driver to allocate the required stack size. An application should manually control the recursion depth and must not exceed the specified limit to avoid driver crashes. The maximum allowed value for this field is 31.</p>
<p><code>ShaderRecordSize</code> can be used to specify constants for each shader or instance or geometry, the maximum supported size is 4096 bytes minus the shader handle size (32 bytes).</p>
<p><code>MaxAttributeSize</code> and <code>MaxPayloadSize</code> are only used in DirectX 12 backend. These values should be as small as possible to minimize the memory usage.</p>
<p>When everything is ready, we call <code>CreateRayTracingPipelineState</code> to create the PSO:</p>
<div class="fragment"><div class="line">m_pDevice-&gt;CreateRayTracingPipelineState(PSOCreateInfo, &amp;m_pRayTracingPSO);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md408"></a>
Creating Shader Binding Table</h2>
<p>Another key component of the ray tracing setup is the Shader Binding Table (SBT) that is used to connect the instances in the TLAS with the shaders in ray tracing PSO that will be executed when a ray hits a particular instance. SBT must be created with the same pipeline that will be used with the trace rays command.</p>
<p>To create an SBT we define an instance of <code>ShaderBindingTableDesc</code> struct and call <code>CreateSBT()</code> device method:</p>
<div class="fragment"><div class="line">ShaderBindingTableDesc SBTDesc;</div>
<div class="line">SBTDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a> = <span class="stringliteral">&quot;SBT&quot;</span>;</div>
<div class="line">SBTDesc.pPSO = m_pRayTracingPSO;</div>
<div class="line">m_pDevice-&gt;CreateSBT(SBTDesc, &amp;m_pSBT);</div>
</div><!-- fragment --><p>After the SBT is created, we start making shader associations. The first shader we need to bind is the ray generation shader, which is the entry point for the ray tracing pipeline, and is very similar to a compute shader. </p><div class="fragment"><div class="line">m_pSBT-&gt;BindRayGenShader(<span class="stringliteral">&quot;Main&quot;</span>);</div>
</div><!-- fragment --><p>Notice that <code>"Main"</code> is the name of the general shader group that contains the ray generation shader that we used in our ray tracing PSO.</p>
<p>Next, we bind miss shaders. A miss shader is executed if a ray doesn't hit any object. We use different behavior for primary and shadow rays and thus have two miss shaders:</p>
<div class="fragment"><div class="line">m_pSBT-&gt;BindMissShader(<span class="stringliteral">&quot;PrimaryMiss&quot;</span>, PRIMARY_RAY_INDEX);</div>
<div class="line">m_pSBT-&gt;BindMissShader(<span class="stringliteral">&quot;ShadowMiss&quot;</span>,  SHADOW_RAY_INDEX );</div>
</div><!-- fragment --><p>Again, <code>"PrimaryMiss"</code> and <code>"ShadowMiss"</code> are the names that we associated with the miss shaders when created the PSO. The second parameter to <code>BindMissShader</code> function is the miss shader index: 0 for primary rays, and 1 for shadow rays.</p>
<p>Next, we define a set of hit shaders for different TLAS instances:</p>
<div class="fragment"><div class="line">m_pSBT-&gt;BindHitGroupForInstance(m_pTLAS, <span class="stringliteral">&quot;Cube Instance 1&quot;</span>,  PRIMARY_RAY_INDEX, <span class="stringliteral">&quot;CubePrimaryHit&quot;</span>  );</div>
<div class="line">m_pSBT-&gt;BindHitGroupForInstance(m_pTLAS, <span class="stringliteral">&quot;Cube Instance 2&quot;</span>,  PRIMARY_RAY_INDEX, <span class="stringliteral">&quot;CubePrimaryHit&quot;</span>  );</div>
<div class="line">m_pSBT-&gt;BindHitGroupForInstance(m_pTLAS, <span class="stringliteral">&quot;Cube Instance 3&quot;</span>,  PRIMARY_RAY_INDEX, <span class="stringliteral">&quot;CubePrimaryHit&quot;</span>  );</div>
<div class="line">m_pSBT-&gt;BindHitGroupForInstance(m_pTLAS, <span class="stringliteral">&quot;Cube Instance 4&quot;</span>,  PRIMARY_RAY_INDEX, <span class="stringliteral">&quot;CubePrimaryHit&quot;</span>  );</div>
<div class="line">m_pSBT-&gt;BindHitGroupForInstance(m_pTLAS, <span class="stringliteral">&quot;Ground Instance&quot;</span>,  PRIMARY_RAY_INDEX, <span class="stringliteral">&quot;GroundHit&quot;</span>       );</div>
<div class="line">m_pSBT-&gt;BindHitGroupForInstance(m_pTLAS, <span class="stringliteral">&quot;Glass Instance&quot;</span>,   PRIMARY_RAY_INDEX, <span class="stringliteral">&quot;GlassPrimaryHit&quot;</span> );</div>
<div class="line">m_pSBT-&gt;BindHitGroupForInstance(m_pTLAS, <span class="stringliteral">&quot;Sphere Instance&quot;</span>,  PRIMARY_RAY_INDEX, <span class="stringliteral">&quot;SpherePrimaryHit&quot;</span>);</div>
</div><!-- fragment --><p>The first argument of <code>BindHitGroupForInstance()</code> method is the TLAS object that contains the instance. The second argument is the instance name for which the hit group will be bound. These names must match the names we gave to the instances when created the TLAS. The third argument is the ray offset in the shader binding table. The hit groups above are defined for the primary ray. The last argument is the hit group name that was defined in <code>TriangleHitShaders</code> array during the pipeline initialization.</p>
<p>For shadow rays we disable all hit shader invocation by using empty shader name or <code>nullptr</code>. We use <code>BindHitGroupForTLAS</code> method to bind empty shader for all instances for shadow ray type at once:</p>
<div class="fragment"><div class="line">m_pSBT-&gt;BindHitGroupForTLAS(m_pTLAS, SHADOW_RAY_INDEX, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>Procedural sphere, though, requires some special care: we need to provide the intersection shader so that the GPU knows how to intersect the rays with our procedural object. Closest hit shader is not needed, so we will use the <code>"SphereShadowHit"</code> hit group that only contains the intersection shader:</p>
<div class="fragment"><div class="line">m_pSBT-&gt;BindHitGroupForInstance(m_pTLAS, <span class="stringliteral">&quot;Sphere Instance&quot;</span>,  SHADOW_RAY_INDEX,  <span class="stringliteral">&quot;SphereShadowHit&quot;</span>);</div>
</div><!-- fragment --><p>After all hit groups are bound, we need to update the internal SBT buffer:</p>
<div class="fragment"><div class="line">m_pImmediateContext-&gt;UpdateSBT(m_pSBT);</div>
</div><!-- fragment --><p>Note that a TLAS can be created with <code>BindingMode = HIT_GROUP_BINDING_MODE_PER_GEOMETRY</code> flag, in which case hit groups can be individually specified for each geometry in every instance, for example:</p>
<div class="fragment"><div class="line">m_pSBT-&gt;BindHitGroupForGeometry(m_pTLAS, <span class="stringliteral">&quot;Cube Instance 1&quot;</span>, <span class="stringliteral">&quot;Cube&quot;</span>, PRIMARY_RAY_INDEX, <span class="stringliteral">&quot;CubePrimaryHit&quot;</span>  );</div>
</div><!-- fragment --><p>The resulting SBT will contain the following data:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Location   </th><th class="markdownTableHeadNone">Instance   </th><th class="markdownTableHeadNone">Geometry   </th><th class="markdownTableHeadNone">Ray type   </th><th class="markdownTableHeadNone">Shader group   </th><th class="markdownTableHeadNone">Shader constants    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Cube Instance 1   </td><td class="markdownTableBodyNone">Cube   </td><td class="markdownTableBodyNone">primary   </td><td class="markdownTableBodyNone">CubePrimaryHit   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">shadow   </td><td class="markdownTableBodyNone">empty   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Cube Instance 2   </td><td class="markdownTableBodyNone">Cube   </td><td class="markdownTableBodyNone">primary   </td><td class="markdownTableBodyNone">CubePrimaryHit   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">shadow   </td><td class="markdownTableBodyNone">empty   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Cube Instance 3   </td><td class="markdownTableBodyNone">Cube   </td><td class="markdownTableBodyNone">primary   </td><td class="markdownTableBodyNone">CubePrimaryHit   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">shadow   </td><td class="markdownTableBodyNone">empty   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">Cube Instance 4   </td><td class="markdownTableBodyNone">Cube   </td><td class="markdownTableBodyNone">primary   </td><td class="markdownTableBodyNone">CubePrimaryHit   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">shadow   </td><td class="markdownTableBodyNone">empty   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">Ground Instance   </td><td class="markdownTableBodyNone">Cube   </td><td class="markdownTableBodyNone">primary   </td><td class="markdownTableBodyNone">GroundHit   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">shadow   </td><td class="markdownTableBodyNone">empty   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">Glass Instance   </td><td class="markdownTableBodyNone">Cube   </td><td class="markdownTableBodyNone">primary   </td><td class="markdownTableBodyNone">GlassPrimaryHit   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">shadow   </td><td class="markdownTableBodyNone">empty   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">12   </td><td class="markdownTableBodyNone">Sphere Instance   </td><td class="markdownTableBodyNone">Box   </td><td class="markdownTableBodyNone">primary   </td><td class="markdownTableBodyNone">SpherePrimaryHit   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">13   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">shadow   </td><td class="markdownTableBodyNone">SphereShadowHit   </td><td class="markdownTableBodyNone">-   </td></tr>
</table>
<p>'Shader group' and 'Shader constants' is what is actually stored in the SBT, other fields in the table are used to calculate the data location.</p>
<p>As an alternative, you can use <code>IShaderBindingTable::BindHitGroupByIndex()</code> to bind hit group directly to any location in the range from <code>TLASBuildInfo::FirstContributionToHitGroupIndex</code> to <code>TLASBuildInfo::LastContributionToHitGroupIndex</code>, call <code>ITopLevelAS::GetBuildInfo()</code> to get the build info.</p>
<h2><a class="anchor" id="autotoc_md409"></a>
Resource Binding</h2>
<p>Unlike others pipelines, in the ray tracing pipeline we use multiple shaders with the same type. Resources with the same name in shaders with the same type are considered the same resource. They must be defined identically, e.g.:</p>
<div class="fragment"><div class="line">// in closest_hit_shader1:</div>
<div class="line">ConstantBuffer&lt;CubeAttribs&gt;  g_CubeAttribsCB : register(b0); // OK - shader register is ignored and will be remapped</div>
<div class="line"> </div>
<div class="line">// in closest_hit_shader2:</div>
<div class="line">ConstantBuffer&lt;CubeAttribs&gt;  g_CubeAttribsCB : register(b1); // OK - shader register is ignored and will be remapped</div>
</div><!-- fragment --><p>Note that shader registers assigned by the compiler or shader developer are ignored and will be remapped by the engine.</p>
<p>It is an error to have different resource types with the same name in different shaders in the <em>same shader stage</em>, e.g.:</p>
<div class="fragment"><div class="line">// in closest_hit_shader1:</div>
<div class="line">ConstantBuffer&lt;CubeAttribs&gt;    g_CubeAttribs;</div>
<div class="line"> </div>
<div class="line">// in closest_hit_shader2:</div>
<div class="line">StructuredBuffer&lt;CubeAttribs&gt;  g_CubeAttribs; // ERROR - g_CubeAttribs is already defined as constant buffer </div>
<div class="line">                                              //         in another closest hit shader</div>
</div><!-- fragment --><p>To fix the error above, rename one of the shader variables to have a distinct name.</p>
<p>It is OK to have different resource types with the same name in <em>different shader stages</em>:</p>
<div class="fragment"><div class="line">// in closest_hit_shader:</div>
<div class="line">ConstantBuffer&lt;CubeAttribs&gt;    g_CubeAttribs;</div>
<div class="line"> </div>
<div class="line">// in any_hit_shader:</div>
<div class="line">StructuredBuffer&lt;CubeAttribs&gt;  g_CubeAttribs; // OK - namespaces for different shader types</div>
<div class="line">                                              //      do not overlap</div>
</div><!-- fragment --><p>Other than the specifics above, creating an SRB and binding shader resources is done similar to other pipeline types:</p>
<div class="fragment"><div class="line">m_pRayTracingPSO-&gt;CreateShaderResourceBinding(&amp;m_pRayTracingSRB, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">m_pRayTracingSRB-&gt;GetVariableByName(SHADER_TYPE_RAY_GEN, <span class="stringliteral">&quot;g_ConstantsCB&quot;</span>)-&gt;Set(m_ConstantsCB);</div>
<div class="line">m_pRayTracingSRB-&gt;GetVariableByName(SHADER_TYPE_RAY_CLOSEST_HIT, <span class="stringliteral">&quot;g_ConstantsCB&quot;</span>)-&gt;Set(m_ConstantsCB);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md410"></a>
Tracing the Rays</h2>
<p>Before starting the ray tracing, we animate instances by updating their transformations in the TLAS. Updating acceleration structures is much faster and takes less memory than building them from scratch.</p>
<div class="fragment"><div class="line">UpdateTLAS();</div>
</div><!-- fragment --><p>Ray tracing is started by <code>TraceRays</code> device context method. The method takes the ray grid dimensions and the SBT as parameters:</p>
<div class="fragment"><div class="line">TraceRaysAttribs Attribs;</div>
<div class="line">Attribs.<a class="code hl_variable" href="../../d9/dac/structDiligent_1_1TraceRaysAttribs.html#ab19760c23d88f23e6c107b9de4fc7b80">DimensionX</a>        = m_pColorRT-&gt;GetDesc().Width;</div>
<div class="line">Attribs.DimensionY        = m_pColorRT-&gt;GetDesc().Height;</div>
<div class="line">Attribs.pSBT              = m_pSBT;</div>
<div class="line">Attribs.SBTTransitionMode = RESOURCE_STATE_TRANSITION_MODE_TRANSITION;</div>
<div class="line">m_pImmediateContext-&gt;TraceRays(Attribs);</div>
<div class="ttc" id="astructDiligent_1_1TraceRaysAttribs_html_ab19760c23d88f23e6c107b9de4fc7b80"><div class="ttname"><a href="../../d9/dac/structDiligent_1_1TraceRaysAttribs.html#ab19760c23d88f23e6c107b9de4fc7b80">Diligent::TraceRaysAttribs::DimensionX</a></div><div class="ttdeci">Uint32 DimensionX</div><div class="ttdoc">The number of rays dispatched in X direction.</div><div class="ttdef"><b>Definition</b> DeviceContext.h:1892</div></div>
</div><!-- fragment --><p>In this tutorial we generate one ray per screen pixel, so <code>DimensionX</code> and <code>DimensionY</code> are the render target dimensions.</p>
<p>Then the result of ray tracing is copied to the swapchain image using a simple graphics pipeline. In a more complex renderer this pass will be replaced by tone mapping or other post processing effects.</p>
<h3><a class="anchor" id="autotoc_md411"></a>
Ray Generation Shader</h3>
<p>Ray generation shader is the entry point of the ray tracing pipeline. Its purpose is to generate the primary rays. In the ray generation shader, we calculate the normalized texture coordinates <code>uv</code> and use them to calculate the ray direction from the inverse view-projection matrix:</p>
<div class="fragment"><div class="line">struct Constants</div>
<div class="line">{</div>
<div class="line">    float4   CameraPos;</div>
<div class="line">    float4x4 InvViewProj;</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line">ConstantBuffer&lt;Constants&gt; g_ConstantsCB;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">float2 uv       = (float2(DispatchRaysIndex().xy) + float2(0.5, 0.5)) / float2(DispatchRaysDimensions().xy);</div>
<div class="line">float4 worldPos = mul(float4(uv * 2.0 - 1.0, 1.0, 1.0), g_ConstantsCB.InvViewProj);</div>
<div class="line">float3 rayDir   = normalize(worldPos.xyz/worldPos.w - g_ConstantsCB.CameraPos.xyz);</div>
</div><!-- fragment --><p>Next, we prepare the RayDesc struct and call <code>CastPrimaryRay</code> helper function:</p>
<div class="fragment"><div class="line">RayDesc ray;</div>
<div class="line">ray.Origin    = g_ConstantsCB.CameraPos.xyz;</div>
<div class="line">ray.Direction = rayDir;</div>
<div class="line">ray.TMin      = g_ConstantsCB.ClipPlanes.x;</div>
<div class="line">ray.TMax      = g_ConstantsCB.ClipPlanes.y;</div>
<div class="line"> </div>
<div class="line">PrimaryRayPayload payload = CastPrimaryRay(ray, /*recursion number*/0);</div>
</div><!-- fragment --><p><code>CastPrimaryRay()</code> ray function calculates the final color of a pixel on the screen and generates secondary rays for reflection and refraction. It wraps the <code>TraceRay()</code> HLSL intrinsic function for reusability. <code>CastPrimaryRay()</code> is defined as follows:</p>
<div class="fragment"><div class="line">RaytracingAccelerationStructure g_TLAS;</div>
<div class="line"> </div>
<div class="line">PrimaryRayPayload CastPrimaryRay(RayDesc ray, uint Recursion)</div>
<div class="line">{</div>
<div class="line">    PrimaryRayPayload payload = {float3(0, 0, 0), 0.0, Recursion};</div>
<div class="line"> </div>
<div class="line">    if (Recursion &gt;= g_ConstantsCB.MaxRecursion)</div>
<div class="line">    {</div>
<div class="line">        // set pink color for debugging</div>
<div class="line">        payload.Color = float3(0.95, 0.18, 0.95);</div>
<div class="line">        return payload;</div>
<div class="line">    }</div>
<div class="line">    TraceRay(g_TLAS,            // Acceleration structure</div>
<div class="line">             RAY_FLAG_NONE,</div>
<div class="line">             ~0,                // Instance inclusion mask - all instances are visible</div>
<div class="line">             PRIMARY_RAY_INDEX, // Ray contribution to hit group index (aka ray type)</div>
<div class="line">             HIT_GROUP_STRIDE,  // Multiplier for geometry contribution to hit </div>
<div class="line">                                // group index (aka the number of ray types)</div>
<div class="line">             PRIMARY_RAY_INDEX, // Miss shader index</div>
<div class="line">             ray,</div>
<div class="line">             payload);</div>
<div class="line">    return payload;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that we check the ray recursion depth and terminate it if current depth exceeds the maximum depth. It is essential to do this because GPU device does not automatically stop ray tracing when the maximum recursion depth is reached and will crash if we exceed the limit specified during the PSO initialization.</p>
<p>At the end of the ray generation shader, we write the payload color to the output UAV texture:</p>
<div class="fragment"><div class="line">g_ColorBuffer[DispatchRaysIndex().xy] = float4(payload.Color, 1.0);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md412"></a>
Closest Hit Shader</h3>
<p>The closest hit shader is executed when a ray hits a triangle geometry or when a custom intersection shader reports the hit (see Intersection Shader).</p>
<p>The following image shows the workflow for the primary ray closest hit shader:</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial21_RayTracing/rt_callstack_1.png" alt="image" class="inline"/></p>
<p>The closest hit shader takes geometry intersection information and editable ray payload as inputs:</p>
<div class="fragment"><div class="line">[shader(&quot;closesthit&quot;)]</div>
<div class="line">void main(inout PrimaryRayPayload payload, in BuiltInTriangleIntersectionAttributes attr)</div>
</div><!-- fragment --><p>To compute the attributes of the hit point, we will use the 3-component barycentric coordinates:</p>
<div class="fragment"><div class="line">float3 barycentrics = float3(1.0 - attr.barycentrics.x - attr.barycentrics.y, attr.barycentrics.x, attr.barycentrics.y);</div>
</div><!-- fragment --><p>The built-in <code>PrimitiveIndex()</code> function gives us the index of the current primitive. Using this index, we can read the 3 vertex indices from the cube constant data buffer:</p>
<div class="fragment"><div class="line">uint3  primitive = g_CubeAttribsCB.Primitives[PrimitiveIndex()].xyz;</div>
</div><!-- fragment --><p>We then use the barycentric coordinates to calculate the texture coordinates at the intersection point:</p>
<div class="fragment"><div class="line">float2 uv = g_CubeAttribsCB.UVs[primitive.x].xy * barycentrics.x +</div>
<div class="line">            g_CubeAttribsCB.UVs[primitive.y].xy * barycentrics.y +</div>
<div class="line">            g_CubeAttribsCB.UVs[primitive.z].xy * barycentrics.z;</div>
</div><!-- fragment --><p>Similarly, we get the triangle normal. Note though that we need to apply the object-to-world transformation that is given by <code>ObjectToWorld3x4()</code> intrinsic function:</p>
<div class="fragment"><div class="line">float3 normal = g_CubeAttribsCB.Normals[primitive.x].xyz * barycentrics.x +</div>
<div class="line">                g_CubeAttribsCB.Normals[primitive.y].xyz * barycentrics.y +</div>
<div class="line">                g_CubeAttribsCB.Normals[primitive.z].xyz * barycentrics.z;</div>
<div class="line">normal        = normalize(mul((float3x3) ObjectToWorld3x4(), normal));</div>
</div><!-- fragment --><p>In ray tracing, <code>Texture2D::Sample()</code> method is not supported because the GPU can not implicitly calculate derivatives, so we have to calculate the texture mipmap level manually or provide explicit gradients for anisotropic filtering. In this tutorial we don't do that and just sample the finest mip level for simplicity:</p>
<div class="fragment"><div class="line">payload.Color = g_Texture[InstanceID()].SampleLevel(g_SamLinearWrap, uv, 0).rgb;</div>
</div><!-- fragment --><p>The last step is lighting calculation. We use built-in functions to get the ray parameters and calculate the intersection point.</p>
<div class="fragment"><div class="line">float3 pos = WorldRayOrigin() + WorldRayDirection() * RayTCurrent();</div>
<div class="line">LightingPass(payload.Color, pos, normal, payload.Recursion + 1);</div>
</div><!-- fragment --><p>We then cast a ray to test if the light is occluded or not and apply a simple diffuse lighting:</p>
<div class="fragment"><div class="line">void LightingPass(inout float3 Color, float3 Pos, float3 Norm, uint Recursion)</div>
<div class="line">{</div>
<div class="line">    float3  col = float3(0.0, 0.0, 0.0);</div>
<div class="line">    for (int i = 0; i &lt; NUM_LIGHTS; ++i)</div>
<div class="line">    {</div>
<div class="line">        float  NdotL = max(0.0, dot(Norm, rayDir));</div>
<div class="line">        </div>
<div class="line">        // Optimization - don&#39;t trace rays if NdotL is zero</div>
<div class="line">        if (NdotL &gt; 0.0)</div>
<div class="line">        {</div>
<div class="line">            RayDesc ray;</div>
<div class="line"> </div>
<div class="line">            // Add a small offset to avoid self-intersections.</div>
<div class="line">            ray.Origin    = Pos + Norm * 0.001;</div>
<div class="line">            ray.Direction = normalize(g_ConstantsCB.LightPos[i].xyz - Pos);</div>
<div class="line"> </div>
<div class="line">            // Limit max ray length by distance to light source.</div>
<div class="line">            ray.TMax      = distance(g_ConstantsCB.LightPos[i].xyz, Pos);</div>
<div class="line">            ray.TMin      = 0.0;</div>
<div class="line"> </div>
<div class="line">            col += CastShadow(ray, Recursion).Shading * NdotL * Color * g_ConstantsCB.LightColor[i].rgb;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    Color = col / float(NUM_LIGHTS) + g_ConstantsCB.AmbientColor.rgb;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For shadow rays we use a new payload type, <code>ShadowRayPayload</code> that only contains two components to minimize the memory usage.</p>
<p>To improve ray tracing performance we use the following flags:</p>
<ul>
<li><code>RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH</code> - stop ray processing immediately if any geometry hit is encountered.</li>
<li><code>RAY_FLAG_FORCE_OPAQUE</code> - skip any-hit shader invocation.</li>
</ul>
<p>In SBT, we bind null hit group for shadow ray for triangle geometry. For procedural geometry we use the intersection shader only, so we don't have any closest hit shaders anyway, and <code>RAY_FLAG_SKIP_CLOSEST_HIT_SHADER</code> flag may have no effect in our particular case. However, if we used the same hit groups for shadow rays as for the primary rays, we might have seen a significant performance improvement.</p>
<p>Note that for some shading techniques this optimization may be inapplicable. For example: for ambient occlusion you may need to know the precise distance to the nearest occluder instead of the binary information about the presence or absence of the intersection, so you will have to use the closest hit shader to write the distance from <code>RayTCurrent()</code>.</p>
<p>We use an instance mask <code>OPAQUE_GEOM_MASK</code> to skip transparent cube with refractions. Light calculation for objects with refractions is much more complex and is ignored for shadows.</p>
<p>The initial <code>Shading</code> value is set to 0 meaning that the object is completely shadowed. It will be preserved if any intersection is found, but will be overwritten by 1 in the miss shader, indicating no occlusion.</p>
<p>The <code>CastShadow()</code> function is defined as follows:</p>
<div class="fragment"><div class="line">ShadowRayPayload CastShadow(RayDesc ray, uint Recursion)</div>
<div class="line">{</div>
<div class="line">    ShadowRayPayload payload = {0.0, Recursion};</div>
<div class="line">    if (Recursion &gt;= g_ConstantsCB.MaxRecursion)</div>
<div class="line">    {</div>
<div class="line">        payload.Shading = 1.0;</div>
<div class="line">        return payload;</div>
<div class="line">    }</div>
<div class="line">    TraceRay(g_TLAS,            // Acceleration structure</div>
<div class="line">             RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER | RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,</div>
<div class="line">             OPAQUE_GEOM_MASK,  // Instance inclusion mask - only opaque instances are visible</div>
<div class="line">             SHADOW_RAY_INDEX,  // Ray contribution to hit group index (aka ray type)</div>
<div class="line">             HIT_GROUP_STRIDE,  // Multiplier for geometry contribution to hit</div>
<div class="line">                                // group index (aka the number of ray types)</div>
<div class="line">             SHADOW_RAY_INDEX,  // Miss shader index</div>
<div class="line">             ray,</div>
<div class="line">             payload);</div>
<div class="line">    return payload;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following diagram shows the workflow for shadow rays:</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial21_RayTracing/rt_callstack_2.png" alt="image" class="inline"/></p>
<p>Note that some hardware does not support ray recursion, but you can use a loop in the ray generation shader instead.</p>
<h3><a class="anchor" id="autotoc_md413"></a>
Miss Shader</h3>
<p>Miss shader is executed if no intersections were found.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial21_RayTracing/rt_callstack_3.png" alt="image" class="inline"/></p>
<p>As an input, the miss shader takes only editable ray payload:</p>
<div class="fragment"><div class="line">[shader(&quot;miss&quot;)]</div>
<div class="line">void main(inout PrimaryRayPayload payload)</div>
</div><!-- fragment --><p>Miss shader for primary ray generates the sky color. Miss shader for shadow ray just writes 1.0 into the payload to indicate no occlusion.</p>
<h3><a class="anchor" id="autotoc_md414"></a>
Intersection Shader</h3>
<p>An intersection shader can be used with procedural geometry only. For a triangle geometry, built-in hardware accelerated intersection test is used. Intersection shader is executed for each ray that intersects with the AABB. Note that depending on the implementation, the intersection shader may be executed even if the AABB is occluded by another geometry, so the intersection test should be as fast as possible. You also need to be very careful if an intersection shader has any side effects such as writing data to an UAV.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial21_RayTracing/rt_callstack_4.png" alt="image" class="inline"/></p>
<p>Intersection shader does not have any inputs or outputs.</p>
<div class="fragment"><div class="line">[shader(<span class="stringliteral">&quot;intersection&quot;</span>)]</div>
<div class="line"><span class="keywordtype">void</span> main()</div>
</div><!-- fragment --><p>We don't have any information about the intersection, so we need to use the same AABB which was specified when building the BLAS and calculate the intersection point in the shader. If there is an intersection, we report the hit to the system using the <code>ReportHit()</code> intrinsic function:</p>
<div class="fragment"><div class="line">ProceduralGeomIntersectionAttribs attr;</div>
<div class="line">...</div>
<div class="line">ReportHit(hitT, RAY_KIND_PROCEDURAL_FRONT_FACE, attr);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md415"></a>
Performance</h2>
<p>With default settings, the execution time of the shaders for all rays is approximately the same.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial21_RayTracing/rt_performance_1.jpg" alt="image" class="inline"/></p>
<p>When we increase the number of rays per pixel, the performance for some pixels increases dramatically. You should minimize multiple rays per pixel and use temporal techniques like a TAA or denoising.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial21_RayTracing/rt_performance_2.jpg" alt="image" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md416"></a>
Further Reading</h2>
<p><a href="https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html">DirectX spec</a> <a href="https://github.com/KhronosGroup/GLSL/raw/master/extensions/ext/GLSL_EXT_ray_tracing.txt">GLSL spec</a> <a href="https://developer.nvidia.com/blog/rtx-best-practices/">Tips and Tricks: Ray Tracing Best Practices</a> <a href="https://developer.nvidia.com/blog/best-practices-using-nvidia-rtx-ray-tracing/">Best Practices: Using NVIDIA RTX Ray Tracing</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
