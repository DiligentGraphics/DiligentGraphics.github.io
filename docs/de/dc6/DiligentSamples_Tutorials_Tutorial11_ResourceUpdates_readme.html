<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial11 - Resource Updates</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/dc6/DiligentSamples_Tutorials_Tutorial11_ResourceUpdates_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial11 - Resource Updates</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates different ways to update buffers and textures in <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine and explains important internal details and performance implications related to each method.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial11_ResourceUpdates/Animation_Large.gif" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial11_ResourceUpdates/Tutorial11_ResourceUpdates.html">â–¶ Run in the browser</a></p>
<h2><a class="anchor" id="autotoc_md327"></a>
Buffers</h2>
<h3><a class="anchor" id="autotoc_md328"></a>
Buffer Initialization</h3>
<p>The most basic way to supply data into a buffer is to provide it at initialization time, for example:</p>
<div class="fragment"><div class="line"><span class="comment">// Create index buffer</span></div>
<div class="line">BufferDesc IndBuffDesc;</div>
<div class="line">IndBuffDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>      = <span class="stringliteral">&quot;Cube index buffer&quot;</span>;</div>
<div class="line">IndBuffDesc.Usage     = USAGE_IMMUTABLE;</div>
<div class="line">IndBuffDesc.BindFlags = BIND_INDEX_BUFFER;</div>
<div class="line">IndBuffDesc.Size      = <span class="keyword">sizeof</span>(Indices);</div>
<div class="line">BufferData IBData;</div>
<div class="line">IBData.<a class="code hl_variable" href="../../d2/d3c/structDiligent_1_1BufferData.html#a26cc7ca53f891a63ed1846e27b8e50d8">pData</a>    = Indices;</div>
<div class="line">IBData.DataSize = <span class="keyword">sizeof</span>(Indices);</div>
<div class="line">pDevice-&gt;CreateBuffer(IndBuffDesc, &amp;IBData, &amp;m_CubeIndexBuffer);</div>
<div class="ttc" id="astructDiligent_1_1BufferData_html_a26cc7ca53f891a63ed1846e27b8e50d8"><div class="ttname"><a href="../../d2/d3c/structDiligent_1_1BufferData.html#a26cc7ca53f891a63ed1846e27b8e50d8">Diligent::BufferData::pData</a></div><div class="ttdeci">const void * pData</div><div class="ttdoc">Pointer to the data.</div><div class="ttdef"><b>Definition</b> Buffer.h:188</div></div>
<div class="ttc" id="astructDiligent_1_1DeviceObjectAttribs_html_a14a31dc6ad69e0b79514e5349e9b4fc0"><div class="ttname"><a href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Diligent::DeviceObjectAttribs::Name</a></div><div class="ttdeci">const Char * Name</div><div class="ttdoc">Object name.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1319</div></div>
</div><!-- fragment --><p>Note that the contents of <code>USAGE_IMMUTABLE</code> buffers cannot be changed and initial data must be given at initialization. Initial data can also be provided for <code>USAGE_DEFAULT</code> buffers, but not for <code>USAGE_DYNAMIC</code> buffers that are updated through mapping. Use <code>USAGE_IMMUTABLE</code> buffer for data that never changes (such as cube index buffer in this tutorial).</p>
<h3><a class="anchor" id="autotoc_md329"></a>
Updating buffers with IBuffer::UpdateData()</h3>
<p>The first way to update a buffer contents at run time is to use <code>IBuffer::UpdateData()</code> method. Only buffers created with <code>USAGE_DEFAULT</code> flag can use this way. This method writes new data to a given buffer subregion, as in the example below:</p>
<div class="fragment"><div class="line">m_CubeVertexBuffer[BufferIndex]-&gt;UpdateData(</div>
<div class="line">    m_pImmediateContext,                <span class="comment">// Device context to use for the operation</span></div>
<div class="line">    FirstVertToUpdate * <span class="keyword">sizeof</span>(Vertex), <span class="comment">// Start offset in bytes</span></div>
<div class="line">    NumVertsToUpdate  * <span class="keyword">sizeof</span>(Vertex), <span class="comment">// Data size in bytes</span></div>
<div class="line">    Vertices                            <span class="comment">// Data pointer</span></div>
<div class="line">);</div>
</div><!-- fragment --><p>Under the hood, <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine translates this call into the following operations:</p>
<h4><a class="anchor" id="autotoc_md330"></a>
OpenGL/GLES backend</h4>
<p>The operation directly translates to <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml">glBufferSubData</a>.</p>
<h4><a class="anchor" id="autotoc_md331"></a>
Direct3D11 backend</h4>
<p>The operation directly translates to <a href="https://docs.microsoft.com/en-us/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-updatesubresource">ID3D11DeviceContext::UpdateSubresource</a>.</p>
<h4><a class="anchor" id="autotoc_md332"></a>
Direct3D12/Vulkan backend</h4>
<p>Default buffers are allocated in GPU-only accessible memory, so the data cannot be written directly. To perform the operation, the engine first allocates a temporary storage in a CPU-visible memory, copies the data to this temporary storage and then issues GPU command to copy the data from the storage to the final destination. It also performs necessary resource state transitions (such as shader resource -&gt; copy destination).</p>
<h4><a class="anchor" id="autotoc_md333"></a>
Performance</h4>
<p><code>IBuffer::UpdateData()</code> is currently the only way to update data in a default (GPU-only) buffer. The operation involves two copy operations. However the main and not so obvious performance issue with this method is state transitions. Every time when a buffer is used in a copy operation, it needs to be transitioned to copy destination state. Every time it is used in a shader, it needs to be transitioned to shader resource state. Transitioning back and forth stalls the GPU pipeline and degrades performance dramatically.</p>
<p>This method should be used when a buffer content stays constant most of the time and only needs to be updated occasionally, usually no more often than once in a frame, for example, when reusing existing buffer to write new mesh data (vertices/indices). This method should not be used for high frequency updates such as animation or constant buffer updates.</p>
<p>To illustrate this method, the tutorial updates positions of cube vertices every 0.1 seconds (see <code>Tutorial11_ResourceUpdates::UpdateBuffer()</code>).</p>
<h4><a class="anchor" id="autotoc_md334"></a>
Limitations</h4>
<p>Inefficient for frequent updates.</p>
<h3><a class="anchor" id="autotoc_md335"></a>
Updating Dynamic Buffers via Mapping</h3>
<p>When buffer contents needs to be updated frequently (once or more times per frame), the buffer should be created with <code>USAGE_DYNAMIC</code> flag. Dynamic buffers cannot be updated with <code>IBuffer::UpdateData()</code>. Instead, they need to be mapped to obtain a pointer that can be used to write data directly to the buffer, as in the example below:</p>
<div class="fragment"><div class="line">Vertex* Vertices = <span class="keyword">nullptr</span>;</div>
<div class="line">VertexBuffer-&gt;Map(m_pImmediateContext, MAP_WRITE, MAP_FLAG_DISCARD, <span class="keyword">reinterpret_cast&lt;</span>PVoid&amp;<span class="keyword">&gt;</span>(Vertices));</div>
<div class="line"><span class="keywordflow">for</span>(Uint32 v=0; v &lt; _countof(CubeVerts); ++v)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> Vertex&amp; SrcVert = CubeVerts[v];</div>
<div class="line">    Vertices[v].uv  = SrcVert.uv;</div>
<div class="line">    Vertices[v].pos = SrcVert.pos * <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(1 + 0.2*sin(m_CurrTime * (1.0 + v * 0.2)));</div>
<div class="line">}</div>
<div class="line">VertexBuffer-&gt;Unmap(m_pImmediateContext, MAP_WRITE, MAP_FLAG_DISCARD);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md336"></a>
OpenGL/GLES backend</h4>
<p>The operation translates to <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml">glMapBufferRange</a> with <code>GL_MAP_WRITE_BIT</code> and <code>GL_MAP_INVALIDATE_BUFFER_BIT</code> flags set.</p>
<h4><a class="anchor" id="autotoc_md337"></a>
Direct3D11 backend</h4>
<p>In Direct3D11 backend, this call directly translates to <a href="https://docs.microsoft.com/en-us/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map">ID3D11DeviceContext::Map</a> with <code>D3D11_MAP_WRITE_DISCARD</code> flag.</p>
<h4><a class="anchor" id="autotoc_md338"></a>
Direct3D12/Vulkan backend</h4>
<p>When dynamic buffer is created in Direct3D12 or Vulkan backend, no memory is allocated. Instead, both backends have special dynamic storage which is a buffer created in CPU-accessible memory that is persistently mapped. When dynamic buffer is mapped, a region is reserved in this buffer. This operation boils down to simply moving current offset and is very cheap. A pointer is then returned that references this memory and the application can write data directly, avoiding all copies. When a dynamic buffer is used for rendering, internal dynamic buffer is bound instead and the proper offset is applied. Internal dynamic buffer is pre-transitioned to read-only state and no transitions are ever performed at run time. The engine takes care of synchronization making sure that a region in the buffer is never given to the application while being used by the GPU.</p>
<h4><a class="anchor" id="autotoc_md339"></a>
Performance</h4>
<p>In Direct3D12/Vulkan backends mapping dynamic buffers with <code>MAP_FLAG_DISCARD</code> flag is very cheap as it only involves updating current offset. It is hard to say what exactly Direct3D11 and OpenGL do under the hood, but most likely something similar. There is one significant difference however: Direct3D11 and OpenGL preserve contents of dynamic buffers between frames while Direct3D12 and Vulkan backends do not. As a result, mapping is many times more efficient in next-gen backends.</p>
<p>Dynamic buffers should be used for content that changes often, typically multiple times per frame. The most common example is a constant buffer that is updated with different transformation matrices before every draw call. Dynamic buffers should not be used for constant data that never changes.</p>
<p>To illustrate this method, the tutorial animates cube vertices by mapping the buffer in every frame (see <code>Tutorial11_ResourceUpdates::MapDynamicBuffer()</code>).</p>
<h4><a class="anchor" id="autotoc_md340"></a>
Limitations</h4>
<p>Only the entire buffer can currently be mapped with <code>MAP_FLAG_DISCARD</code> flag.</p>
<p>In Direct3D12 and Vulkan backends, the contents of all dynamic resources are lost at the end of every frame. A dynamic buffer must be mapped in every frame before its first use.</p>
<p>The total amount of CPU-accessible memory can be limited. Besides, access from the GPU may be slower compared to GPU-only memory, so dynamic buffers should not be used to store resources that are constant or change infrequently.</p>
<h2><a class="anchor" id="autotoc_md341"></a>
Textures</h2>
<p>While buffers are simply linear regions of memory, textures are optimized for efficient sampling operations and use opaque layouts that are typically not exposed to the application. As a result, only the driver knows how to write data to the texture. Linear layouts are allowed in Direct3D12 and Vulkan, but they are less efficient.</p>
<h3><a class="anchor" id="autotoc_md342"></a>
Texture initialization</h3>
<p>Similar to buffers, initial data can be supplied to textures at creation time. For <code>USAGE_IMMUTABLE</code> textures this is the only way.</p>
<div class="fragment"><div class="line">TexDesc TexDesc;</div>
<div class="line">TexDesc.Type      = RESOURCE_DIM_TEX_2D;</div>
<div class="line">TexDesc.Format    = TEX_FORMAT_RGBA8_UNORM_SRGB;</div>
<div class="line">TexDesc.Width     = 1024;</div>
<div class="line">TexDesc.Height    = 1024;</div>
<div class="line">TexDesc.MipLevels = 1;</div>
<div class="line">TexDesc.BindFlags = BIND_SHADER_RESOURCE;</div>
<div class="line">TexDesc.Usage     = USAGE_IMMUTABLE;</div>
<div class="line"> </div>
<div class="line">TextureData InitData;</div>
<div class="line"> <span class="comment">// Pointer to subresouce data, one for every mip level</span></div>
<div class="line">InitData.<a class="code hl_variable" href="../../d8/da2/structDiligent_1_1TextureData.html#ab7bd0ded2a2f31e8f6bdb1eaec410c04">pSubResources</a>   = subresources;</div>
<div class="line">InitData.NumSubresources = _countof(subresources);</div>
<div class="line"> </div>
<div class="line">RefCntAutoPtr&lt;ITexture&gt; Texture;</div>
<div class="line">Device-&gt;CreateTexture(TexDesc, &amp;InitData, &amp;Texture);</div>
<div class="ttc" id="astructDiligent_1_1TextureData_html_ab7bd0ded2a2f31e8f6bdb1eaec410c04"><div class="ttname"><a href="../../d8/da2/structDiligent_1_1TextureData.html#ab7bd0ded2a2f31e8f6bdb1eaec410c04">Diligent::TextureData::pSubResources</a></div><div class="ttdeci">TextureSubResData * pSubResources</div><div class="ttdef"><b>Definition</b> Texture.h:334</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md343"></a>
Updating textures with ITexture::UpdateData()</h3>
<p>The first way to update textures is to use <code>ITexture::UpdateData()</code> method. The method works similar to <code>IBuffer::UpdateData()</code> and writes new data to a given texture region:</p>
<div class="fragment"><div class="line">Box UpdateBox;</div>
<div class="line">Uint32 Width  = 128;</div>
<div class="line">Uint32 Height = 64;</div>
<div class="line">UpdateBox.MinX = 16;</div>
<div class="line">UpdateBox.MinY = 32;</div>
<div class="line">UpdateBox.MaxX = UpdateBox.MinX + Width;</div>
<div class="line">UpdateBox.MaxY = UpdateBox.MinY + Height;</div>
<div class="line"> </div>
<div class="line">TextureSubResData SubresData;</div>
<div class="line">SubresData.<a class="code hl_variable" href="../../d1/d96/structDiligent_1_1TextureSubResData.html#a1ea8528aaa924c231600c7e464947939">Stride</a> = Width * 4;</div>
<div class="line">SubresData.pData  = Data.data();</div>
<div class="line">Uint32 MipLevel   = 0;</div>
<div class="line">Uint32 ArraySlice = 0;</div>
<div class="line">Texture-&gt;UpdateData(m_pImmediateContext, MipLevel, ArraySlice, UpdateBox, SubresData);</div>
<div class="ttc" id="astructDiligent_1_1TextureSubResData_html_a1ea8528aaa924c231600c7e464947939"><div class="ttname"><a href="../../d1/d96/structDiligent_1_1TextureSubResData.html#a1ea8528aaa924c231600c7e464947939">Diligent::TextureSubResData::Stride</a></div><div class="ttdeci">Uint64 Stride</div><div class="ttdoc">For 2D and 3D textures, row stride in bytes.</div><div class="ttdef"><b>Definition</b> Texture.h:288</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md344"></a>
OpenGL/GLES backend</h4>
<p>The operation directly translates to <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml">glTexSubImage**</a> family of functions.</p>
<h4><a class="anchor" id="autotoc_md345"></a>
Direct3D11 backend</h4>
<p>As with buffer updates, in Direct3D11 backend, this call directly maps to <a href="https://docs.microsoft.com/en-us/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-updatesubresource">ID3D11DeviceContext::UpdateSubresource</a>.</p>
<h4><a class="anchor" id="autotoc_md346"></a>
Direct3D12/Vulkan backend</h4>
<p>As with buffers, to update a texture the next-gen backends first allocate region in a CPU-accessible memory and copy client data to this region. They then perform necessary state transitions and issue GPU copy command that writes pixels to the texture using GPU-specific layout.</p>
<h4><a class="anchor" id="autotoc_md347"></a>
Performance</h4>
<p>Usage scenarios are similar to buffer updates: the operation should be used for textures whose contents stay mostly constant and only occasionally requires updates.</p>
<p>This method is illustrated by <code>Tutorial11_ResourceUpdates::UpdateTexture()</code> function.</p>
<h4><a class="anchor" id="autotoc_md348"></a>
Limitations</h4>
<p>As the operation involves two copies and state transitions, it is not efficient for frequent texture updates.</p>
<h3><a class="anchor" id="autotoc_md349"></a>
Mapping textures</h3>
<p>Mapping a texture is a second way to update its contents. From the API side, mapping textures looks similar to mapping buffers:</p>
<div class="fragment"><div class="line">Uint32 MipLevel   = 0;</div>
<div class="line">Uint32 ArraySlice = 0;</div>
<div class="line">MappedTextureSubresource MappedSubres;</div>
<div class="line">Box MapRegion;</div>
<div class="line">Uint32 Width  = 128;</div>
<div class="line">Uint32 Height = 256;</div>
<div class="line">MapRegion.MinX = 32;</div>
<div class="line">MapRegion.MinY = 64;</div>
<div class="line">MapRegion.MaxX = MapRegion.MinX + Width;</div>
<div class="line">MapRegion.MaxY = MapRegion.MinY + Height;</div>
<div class="line">Texture-&gt;Map(m_pImmediateContext, MipLevel, ArraySlice, MAP_WRITE, MAP_FLAG_DISCARD, &amp;MapRegion, MappedSubres);</div>
<div class="line">WriteTextureData( (Uint8*)MappedSubres.pData, Width, Height, MappedSubres.Stride);</div>
<div class="line">Texture-&gt;Unmap(m_pImmediateContext, 0, 0);</div>
</div><!-- fragment --><p>What happens under the hood is very different compared to buffers.</p>
<h4><a class="anchor" id="autotoc_md350"></a>
OpenGL/GLES backend</h4>
<p>Mapping textures is currently not supported in OpenGL/GLES backends.</p>
<h4><a class="anchor" id="autotoc_md351"></a>
Direct3D11 backend</h4>
<p>In Direct3D11 backend, this call directly maps to <a href="https://docs.microsoft.com/en-us/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map">ID3D11DeviceContext::Map</a> with <code>D3D11_MAP_WRITE_DISCARD</code> flag.</p>
<h4><a class="anchor" id="autotoc_md352"></a>
Direct3D12/Vulkan backend</h4>
<p>There are no dynamic textures in next-gen backends in a way similar to dynamic buffers. While buffers can easily be suballocated from another buffer by binding parent buffer and applying an offset, there is no similar way for textures. So even if the required memory was suballocated from the dynamic buffer, there would be no way to treat this memory as a texture. Binding the memory to an existing texture is also not allowed.</p>
<p>As a result, mapping textures in Direct3D12/Vulkan backend does not differ significantly from updating textures with <code>ITexture::UpdateData()</code>. When mapping a texture, the engine returns the pointer to the CPU-accessible memory directly that avoids one copy. However, GPU-side copy and most importantly state transitions are still performed.</p>
<h4><a class="anchor" id="autotoc_md353"></a>
Performance</h4>
<p>It is not exactly clear what Direct3D11 does under the hood. The two most likely options are either creating linear-layout texture and suballocating it from CPU-accessible memory every time <code>Map</code> is called, or performing the same operations as <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a>'s next-gen backends.</p>
<p>Mapping dynamic textures is not as efficient as mapping dynamic buffers, and typical usage scenarios are similar to <code>ITexture::UpdateData()</code>.</p>
<p>There is no simple way to implement high-frequency texture updates across all APIs, so <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> expects that this will be implemented by the application using low-level API interoperability.</p>
<p>This method is illustrated by <code>Tutorial11_ResourceUpdates::UpdateTexture()</code> function.</p>
<h4><a class="anchor" id="autotoc_md354"></a>
Limitations</h4>
<p>Texture mapping is not currently implemented in OpenGL/GLES backend.</p>
<p>In Direct3D11, only the entire texture level can be mapped with <code>D3D11_MAP_WRITE_DISCARD</code> flag.</p>
<p>In Direct3D12/Vulkan backends, mapping dynamic textures is not as efficient as mapping dynamic buffers. In fact, it is very similar to updating textures with <code>ITexture::UpdateData()</code> and only avoids one CPU-side copy.</p>
<h1><a class="anchor" id="autotoc_md355"></a>
Summary</h1>
<p>The following table summarizes update methods for buffers:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Update scenario   </th><th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Update Method   </th><th class="markdownTableHeadNone">Comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Constant data   </td><td class="markdownTableBodyNone"><code>USAGE_IMMUTABLE</code>   </td><td class="markdownTableBodyNone">n/a   </td><td class="markdownTableBodyNone">Data can only be written during buffer initialization    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&lt; Once per frame   </td><td class="markdownTableBodyNone"><code>USAGE_DEFAULT</code>   </td><td class="markdownTableBodyNone"><code>IBuffer::UpdateData()</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&gt;= Once per frame   </td><td class="markdownTableBodyNone"><code>USAGE_DYNAMIC</code>   </td><td class="markdownTableBodyNone"><code>IBuffer::Map()</code>   </td><td class="markdownTableBodyNone">The content of dynamic buffers is invalidated at the end of every frame   </td></tr>
</table>
<p>The following table summarizes update methods for textures:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Update scenario   </th><th class="markdownTableHeadNone">Usage/Update Method   </th><th class="markdownTableHeadNone">Comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Constant data   </td><td class="markdownTableBodyNone"><code>USAGE_IMMUTABLE</code> / n/a   </td><td class="markdownTableBodyNone">Data can only be written during texture initialization    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&lt; Once per frame   </td><td class="markdownTableBodyNone"><code>USAGE_DEFAULT</code> + <code>ITexture::UpdateData()</code> or <code>USAGE_DYNAMIC</code> + <code>ITexture::Map()</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&gt;= Once per frame   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Dynamic textures cannot be implemented the same way as dynamic buffers   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
