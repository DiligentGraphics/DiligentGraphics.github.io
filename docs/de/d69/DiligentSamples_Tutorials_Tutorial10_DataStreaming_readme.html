<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial10 - Data Streaming</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/d69/DiligentSamples_Tutorials_Tutorial10_DataStreaming_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial10 - Data Streaming</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial shows dynamic buffer mapping strategy using <code>MAP_FLAG_DISCARD</code> and <code>MAP_FLAG_NO_OVERWRITE</code> flags to efficiently stream varying amounts of data to GPU.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial10_DataStreaming/Animation_Large.gif" alt="" class="inline"/></p>
<p><a href="https://diligentgraphics.github.io/wasm-modules/Tutorial10_DataStreaming/Tutorial10_DataStreaming.html">â–¶ Run in the browser</a></p>
<p>The tutorial is based on <a href="../../../Tutorial09_Quads">Tutorial09 - Quads</a>, but instead of quads it renders polygons with varying number of vertices, streaming geometry of every polygon at every draw call.</p>
<h2><a class="anchor" id="autotoc_md326"></a>
Streaming Data</h2>
<p>The main difference between this and previous tutorial is that this time the geometry of every polygon is not fixed and changes dynamically at run time. Before issuing a draw command, polygon vertices and index list are streamed to the GPU. The sample employs the following strategy to upload varying amounts of data to the GPU:</p>
<ol type="1">
<li>Create dynamic buffer large enough to encompass few polygons</li>
<li>First time, map the buffer with <code>MAP_FLAG_DISCARD</code> flag. This will discard previous buffer contents and allocate new memory.</li>
<li>Set current buffer offset to zero, write polygon data to the buffer and update offset</li>
<li>Unmap the buffer and issue draw command. Note that in Direct3D12 and Vulkan backends, unmapping the buffer is not required and can be safely skipped to improve performance</li>
<li>When mapping the buffer next time, check if the remaining space is enough to encompass the new polygon data.<ul>
<li>If there is enough space, map the buffer with <code>MAP_FLAG_NO_OVERWRITE</code> flag. This will tell the system to return previously allocated memory. It is the responsibility of the application to not overwrite the memory that is in use by the GPU. Write polygon data at current offset and update the offset.</li>
<li>If there is not enough space, reset the offset to zero and map the buffer with <code>MAP_FLAG_DISCARD</code> flag to request new chunk of memory</li>
</ul>
</li>
</ol>
<p>The strategy described above is implemented by <code>StreamingBuffer</code> class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>StreamingBuffer</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// ... </span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    RefCntAutoPtr&lt;IBuffer&gt; m_pBuffer;</div>
<div class="line">    <span class="keyword">const</span> Uint32 m_BufferSize;</div>
<div class="line">    <span class="keywordtype">bool</span> m_AllowPersistentMap = <span class="keyword">false</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>MapInfo</div>
<div class="line">    {</div>
<div class="line">        MapHelper&lt;Uint8&gt; m_MappedData;</div>
<div class="line">        Uint32 m_CurrOffset = 0;</div>
<div class="line">    };</div>
<div class="line">    <span class="comment">// We need to keep track of mapped data for every context</span></div>
<div class="line">    std::vector&lt;MapInfo&gt; m_MapInfo;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The class constructor simply initializes the dynamic buffer to hold streaming data:</p>
<div class="fragment"><div class="line">StreamingBuffer::StreamingBuffer(IRenderDevice* pDevice, BIND_FLAGS BindFlags, Uint32 Size, <span class="keywordtype">size_t</span> NumContexts) : </div>
<div class="line">    m_BufferSize            (Size),</div>
<div class="line">    m_MapInfo               (NumContexts)</div>
<div class="line">{</div>
<div class="line">    BufferDesc BuffDesc;</div>
<div class="line">    BuffDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>           = <span class="stringliteral">&quot;Data streaming buffer&quot;</span>;</div>
<div class="line">    BuffDesc.Usage          = USAGE_DYNAMIC;</div>
<div class="line">    BuffDesc.BindFlags      = BindFlags;</div>
<div class="line">    BuffDesc.CPUAccessFlags = CPU_ACCESS_WRITE;</div>
<div class="line">    BuffDesc.Size           = Size;</div>
<div class="line">    pDevice-&gt;CreateBuffer(BuffDesc, <span class="keyword">nullptr</span>, &amp;m_pBuffer);</div>
<div class="line">}</div>
<div class="ttc" id="astructDiligent_1_1DeviceObjectAttribs_html_a14a31dc6ad69e0b79514e5349e9b4fc0"><div class="ttname"><a href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Diligent::DeviceObjectAttribs::Name</a></div><div class="ttdeci">const Char * Name</div><div class="ttdoc">Object name.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1319</div></div>
</div><!-- fragment --><p>The allocation strategy described above is implemented by <code>Allocate()</code> method:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns offset of the allocated region</span></div>
<div class="line">Uint32 StreamingBuffer::Allocate(IDeviceContext* pCtx, Uint32 Size, <span class="keywordtype">size_t</span> CtxNum)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>&amp; MapInfo = m_MapInfo[CtxNum];</div>
<div class="line">    <span class="comment">// Check if there is enough space in the buffer</span></div>
<div class="line">    <span class="keywordflow">if</span> (MapInfo.m_CurrOffset + Size &gt; m_BufferSize)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Unmap the buffer</span></div>
<div class="line">        Flush(CtxNum);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (MapInfo.m_MappedData == <span class="keyword">nullptr</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// If current offset is zero, we are mapping the buffer for the first time after it has been flushed. Use MAP_FLAG_DISCARD flag.</span></div>
<div class="line">        <span class="comment">// Otherwise use MAP_FLAG_NO_OVERWRITE flag.</span></div>
<div class="line">        MapInfo.m_MappedData.Map(pCtx, m_pBuffer, MAP_WRITE, MapInfo.m_CurrOffset == 0 ? MAP_FLAG_DISCARD : MAP_FLAG_NO_OVERWRITE);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Uint32 Offset = MapInfo.m_CurrOffset;</div>
<div class="line">    <span class="comment">// Update offset</span></div>
<div class="line">    MapInfo.m_CurrOffset += Size;</div>
<div class="line">    <span class="keywordflow">return</span> Offset;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Writing data to the buffer is then straightforward:</p>
<div class="fragment"><div class="line">Uint32  VBOffset   = m_StreamingVB-&gt;Allocate(pCtx, NumVerts * <span class="keyword">sizeof</span>(float2), CtxNum);</div>
<div class="line">float2* VertexData = <span class="keyword">reinterpret_cast&lt;</span>float2*<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span>Uint8*<span class="keyword">&gt;</span>(m_StreamingVB-&gt;GetMappedCPUAddress(CtxNum)) + VBOffset);</div>
<div class="line"><span class="comment">// Write required data to VertexData</span></div>
<div class="line"><span class="comment">// ... </span></div>
<div class="line"> </div>
<div class="line">m_StreamingVB-&gt;Release(CtxNum);</div>
</div><!-- fragment --><p>After the data has been written, the last thing to do is to bind the buffers at the specified offsets:</p>
<div class="fragment"><div class="line">Uint64   offsets[] = {VBOffset};</div>
<div class="line">IBuffer* pBuffs[]  = {m_StreamingVB-&gt;GetBuffer()};</div>
<div class="line">pCtx-&gt;SetVertexBuffers(0, 1, pBuffs, offsets, RESOURCE_STATE_TRANSITION_MODE_VERIFY, SET_VERTEX_BUFFERS_FLAG_RESET);</div>
<div class="line">pCtx-&gt;SetIndexBuffer(m_StreamingIB-&gt;GetBuffer(), IBOffsets, RESOURCE_STATE_TRANSITION_MODE_VERIFY);</div>
</div><!-- fragment --><p>Shader and pipeline state initialization as well as multithreaded rendering is done similar to previous sample; refer to <a href="../../../Tutorial09_Quads">Tutorial09 - Quads</a> for details. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
