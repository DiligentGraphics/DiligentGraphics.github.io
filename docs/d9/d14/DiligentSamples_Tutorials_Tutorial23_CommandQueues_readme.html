<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine: Tutorial23 - Command Queues</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Diligent Engine
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d9/d14/DiligentSamples_Tutorials_Tutorial23_CommandQueues_readme.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial23 - Command Queues</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates how to use multiple command queues to perform rendering in parallel with copy and compute operations.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial23_CommandQueues/Animation_Large.gif" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md422"></a>
Command Queues in Desktop GPUs</h2>
<p>When CPU issues a command (render, compute, copy, etc.), it is not executed immediately by the GPU. Instead, it is recorded into a command buffer. When the buffer contains enough commands, it is submitted to the command queue (VkQueue, ID3D12CommandQueue, MTLCommandQueue), which is then passed to the driver, that schedules them to be executed on the GPU. But what is the path of GPU commands before they get executed on compute units?</p>
<p>An application can only access <em>software</em> command queues provided by the driver. Each application that uses GPU, like a game, browser, video player and even the desktop, sees their own software queues.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial23_CommandQueues/img/img1.png" alt="" class="inline"/></p>
<p>The GPU driver receives multiple command lists from multiple queues, but then all commands are processed by the single command processor that distributes workload across compute units. The command processor can execute in parallel only a small number of commands that have no dependencies between them, for example: some compute and copy commands or a single render pass with multiple draw calls. A large workload from one application will cause a slow down of other applications that are using the GPU. But the GPU driver and the hardware may divide command buffers from a single application into small chunks and alternately execute chunks from different applications. This allows applications with low workload like a browser or a video player to render at 60 FPS when a game with high workload runs at just 10 FPS. Current hardware has limitations that do not allow it to run render pass in parallel with compute, copy or another render pass on the same command processor. But a separate command processor can execute any command in parallel with the main command processor. Current hardware typically has a single graphics processor, multiple compute command processors and some transfer command processors.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial23_CommandQueues/img/img2.png" alt="" class="inline"/></p>
<p>As opposed to CPU, the GPU always uses as many compute units as possible, so when we use async compute queue, we don't unlock any secret power of GPU. Then what is the point of parallelization? In an ideal renderer each command occupies all compute units or runs in parallel with further commands and together uses GPU by 100%. But in real renderer this never happens for many reasons:</p><ul>
<li>GPU waits for new commands from CPU or waits for the fence signal and has no work to do</li>
<li>Loading from VRAM to cache, cache misses stall execution units</li>
<li>Loading from cache to VRAM, cache flushes</li>
<li>Uncached access to memory (UAV resources), atomic operations</li>
<li>Memory bandwidth</li>
<li>PCI-E bandwidth</li>
<li>Suboptimal synchronizations between commands (state transitions)</li>
<li>Decompression of the compressed render targets</li>
<li>Peak performance of the fixed pipeline (triangle culling and rasterization, tessellation, ray-triangle intersection and other)</li>
<li>Frequent state changes (see 'Understanding GPU context rolls')</li>
<li>Poorly prepared geometry (one-pixel or elongated triangles)</li>
</ul>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial23_CommandQueues/img/gpu_trace.png" alt="" class="inline"/> <em>Image from NSight GPUTrace. Light gray areas - idle cores, dark gray - unused warps (because of culled and one-pixel triangles).</em></p>
<p>Modern GPUs perform a very good workload distribution which can hide latency of some operations. Also, you can optimize your application to minimize GPU stalls, but you will not be able to get rid of GPU stalls completely, so some part of GPU power will not be used in a single queue and will be available for other queues.</p>
<h2><a class="anchor" id="autotoc_md423"></a>
Command Queues in Mobile GPUs</h2>
<p>Initially mobile devices were designed to execute render commands from a single application. Mobile devices use a tile based deferred renderer (TBDR): all geometry in a render pass is first processed and triangles are assigned to screen-space tiles (also called bins). Each tile is the processed independently and fragment shaders are only executed for triangles in the tile.</p>
<p>Modern ARM GPUs have two or three hardware queues:</p><ol type="1">
<li>Vertex shader and binning on tiles.</li>
<li>Triangle rasterization and fragment shader execution.</li>
<li>Compute shader execution. In a two-queue configuration, compute shaders are executed in the same queue as vertex shaders.</li>
</ol>
<p>Each hardware queue may run in parallel with others but they share the same compute units.</p>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial23_CommandQueues/img/img5.png" alt="" class="inline"/></p>
<p>Low-end devices have just 1-4 GPU cores with 32 threads each. Because of this, commands are most often executed sequentially and the cores are rarely idle, so there are no advantages from parallelization. High-end devices may have 8-16 GPU cores that add the ability to parallelise some workload if there is no dependency between them.</p>
<p>Graphics API (Vulkan and Metal) expose multiple software queues that allow using async compute techniques on mobile devices, but because all software queues use the same hardware queues, performance of these techniques depends on the driver efficiency.</p>
<h2><a class="anchor" id="autotoc_md424"></a>
Tutorial Overview</h2>
<p>This tutorial implements a simple asynchronous renderer that consists of 4 passes:</p>
<ol type="1">
<li><em>Terrain generation in compute shader</em>. This is a compute-heavy pass that keeps compute units busy with lots of noise generation operations. There are no texture or buffer loads, so compute units do not stall on memory access and occupation is very high. In a real application, a compute pass may perform water simulation, physics simulations, occlusion culling and other. This pass can be executed in an async compute queue.</li>
<li><em>Texture atlas uploading</em>. Textures for buildings are updated on the CPU and are uploaded to GPU. A real applications may be performing resource streaming for an open world game, virtual texture update, high mipmap streaming and other tasks. This pass can be executed in an async transfer queue and is only enabled if the transfer queue is supported by device.</li>
<li><em>Scene rendering</em>. In this pass we draw the terrain and buildings, using the resources prepared in passes 1 and 2.</li>
<li><em>Post processing</em>. In this pass we generate mipmaps from color render targets generated in pass 3 to make glow effect, apply fog and generate the final image that is presented on the screen. Resources from passes 1 and 2 are not used, so these operations can run in parallel.</li>
</ol>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial23_CommandQueues/img/img6.png" alt="" class="inline"/></p>
<p>For the runtime profiling, we use timestamp queries. Note that accuracy of timestamp queries is hardware-dependent and, more importantly, using queries may prevent commands from overlapping. For precise profiling you should use specialized tools from hardware vendors.</p>
<p>In the profiler we have two important intervals: the frame time and the time between two graphics passes.</p>
<ol type="1">
<li><em>The frame time.</em> When using multiple queues, compute and upload passes may overlap with the post process pass in the previous frame, so single frame time increases. However, since two frames are in flight, the frame rate increased too. As opposed to a single-queue renderer, we cannot use the frame time to measure performance, but the frame time shows frame latency, e.g. the time between command submission on the CPU and the time when the final image is handled by the presentantion engine. Action games and VR applications require low frame latency and overlapping with the previous frame may add extra latency, which may be undesirable.</li>
</ol>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial23_CommandQueues/img/frame_time.png" alt="" class="inline"/></p>
<ol type="1">
<li><em>The time between two graphics passes.</em> Graphics passes do not overlap, so this is the correct way to measure the frame rate on the GPU. Note that the vertical synchronization may add GPU idle time to this interval.</li>
</ol>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial23_CommandQueues/img/between_frames.png" alt="" class="inline"/></p>
<p>Sliders and flags are used to control the workload in different passes:</p>
<ul>
<li><em>Transfer rate per frame</em> - controls how many texture array slices will be updated in a single frame. This affects the upload pass time. Additionally, we calculate the transfer rate, i.e. how much data will be sent through the PCI-E bus per second.</li>
<li><em>Use async transfer</em> - controls whether to execute upload pass in the transfer queue.</li>
<li><em>Terrain dimension</em> - the size of the height and normal maps for terrain. This slider affects the compute pass time and partially the graphics pass time since the number of triangles and memory loads depend on the terrain resolution.</li>
<li><em>Use async compute</em> - controls whether to execute compute pass in a separate compute queue.</li>
<li><em>Double buffering</em> - changes the compute to graphics synchronization method. With double buffering, the compute pass overlaps with all graphics commands in the previous pass, which increases the frame latency.</li>
</ul>
<p><img src="https://github.com/DiligentGraphics/DiligentSamples/raw/master/Tutorials/Tutorial23_CommandQueues/img/img7.png" alt="" class="inline"/></p>
<ul>
<li><em>Surface scale</em> - changes the render target size. It controls how many fragment shader invocations will be in the graphics pass, but geometry processing will always be the same. This has a major effect on the performance of the post process pass - the pass time increases exponentially.</li>
<li><em>Glow</em> - whether to enable glow effect. The effect requires downsampling, a severely memory-bound process, but it allows other queues to overlap.</li>
</ul>
<p>Desktop GPUs allow better overlapping of compute and upload passes with post process pass of the previous frame. The double-buffered mode is faster, but for the price of increased frame latency. As much as 2x performance improvement may be achieved.</p>
<p>On low-end mobile GPUs with a small number of cores, using async compute gives no advantage. On high-end mobile GPUs, overlapping post-process pass with compute pass does not give any improvement, but double-buffering mode allows overlapping the scene drawing pass with the compute pass that results in up to 1.5x performance improvement. Note that in this tutorial we don't perform frustum culling and don't use LODs. This uses many compute units and simulates a complex geometry processing.</p>
<h2><a class="anchor" id="autotoc_md425"></a>
Engine Initialization</h2>
<p><a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine supports multiple command queues in DirectX 12, Vulkan and Metal backends. To enable multiple queues, we should first find the suitable adapter. After creating the engine factory, we use the <code>EnumerateAdapters()</code> method to get the list of adapters.</p>
<div class="fragment"><div class="line">std::vector&lt;GraphicsAdapterInfo&gt; Adapters;</div>
<div class="line"> </div>
<div class="line">Uint32 NumAdapters = 0;</div>
<div class="line">pEngineFactory-&gt;EnumerateAdapters(EngineCI.GraphicsAPIVersion, NumAdapters, 0);</div>
<div class="line"><span class="keywordflow">if</span> (NumAdapters &gt; 0)</div>
<div class="line">{</div>
<div class="line">    Adapters.resize(NumAdapters);</div>
<div class="line">    pEngineFactory-&gt;EnumerateAdapters(EngineCI.GraphicsAPIVersion, NumAdapters, Adapters.data());</div>
<div class="line"> </div>
<div class="line">    EngineCI.AdapterId = 0;</div>
<div class="line">    Uint32 NumQueues   = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (Uint32 AdapterId = 0; AdapterId &lt; NumAdapters; ++AdapterId)</div>
<div class="line">    {</div>
<div class="line">        GraphicsAdapterInfo&amp; Adapter = Adapters[AdapterId];</div>
<div class="line">        <span class="keywordflow">if</span> (Adapter.NumQueues &gt; NumQueues)</div>
<div class="line">        {</div>
<div class="line">            EngineCI.AdapterId = AdapterId;</div>
<div class="line">            NumQueues          = Adapter.NumQueues;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine, command queues are exposed through immediate contexts. An immediate context allows recording commands directly, or executing command lists recorded by the deferred contexts. Every immediate context encompasses a single software queue.</p>
<p>We use a helper function <code>AddContext()</code> to find the required queue and add it to the context create info.</p>
<div class="fragment"><div class="line">std::vector&lt;ImmediateContextCreateInfo&gt; ContextCI;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> AddContext = [&amp;](COMMAND_QUEUE_TYPE Type, <span class="keyword">const</span> <span class="keywordtype">char</span>* Name, Uint32 AdapterId) <span class="comment">//</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">constexpr</span> COMMAND_QUEUE_TYPE QueueMask = COMMAND_QUEUE_TYPE_PRIMARY_MASK;</div>
<div class="line"> </div>
<div class="line">    CommandQueueInfo* Queues = Adapters[AdapterId].Queues;</div>
<div class="line">    <span class="keywordflow">for</span> (Uint32 q = 0, Count = Adapters[AdapterId].NumQueues; q &lt; Count; ++q)</div>
<div class="line">    {</div>
<div class="line">        CommandQueueInfo&amp; CurQueue = Queues[q];</div>
<div class="line">        <span class="keywordflow">if</span> (CurQueue.MaxDeviceContexts == 0)</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> ((CurQueue.QueueType &amp; QueueMask) == Type)</div>
<div class="line">        {</div>
<div class="line">            CurQueue.MaxDeviceContexts -= 1;</div>
<div class="line"> </div>
<div class="line">            ImmediateContextCreateInfo Ctx{};</div>
<div class="line">            Ctx.<a class="code hl_variable" href="../../d2/d4e/structDiligent_1_1ImmediateContextCreateInfo.html#ae9b13ed101fe896f4e761be2057f1cb1">QueueId</a>  = <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>(q);</div>
<div class="line">            Ctx.Name     = Name;</div>
<div class="line">            Ctx.Priority = QUEUE_PRIORITY_MEDIUM;</div>
<div class="line">            ContextCI.push_back(Ctx);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">};</div>
<div class="line">AddContext(COMMAND_QUEUE_TYPE_GRAPHICS, <span class="stringliteral">&quot;Graphics&quot;</span>, EngineCI.AdapterId);</div>
<div class="line">AddContext(COMMAND_QUEUE_TYPE_TRANSFER, <span class="stringliteral">&quot;Transfer&quot;</span>, EngineCI.AdapterId);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// On Metal and Vulkan mobile platforms we have only graphics queues.</span></div>
<div class="line"><span class="keywordflow">if</span> (!AddContext(COMMAND_QUEUE_TYPE_COMPUTE, <span class="stringliteral">&quot;Compute&quot;</span>, EngineCI.AdapterId))</div>
<div class="line">    AddContext(COMMAND_QUEUE_TYPE_GRAPHICS, <span class="stringliteral">&quot;Graphics 2&quot;</span>, EngineCI.AdapterId);</div>
<div class="line">        </div>
<div class="line">EngineCI.pImmediateContextInfo = ContextCI.data();</div>
<div class="line">EngineCI.NumImmediateContexts  = <span class="keyword">static_cast&lt;</span>Uint32<span class="keyword">&gt;</span>(ContextCI.size());</div>
<div class="ttc" id="astructDiligent_1_1ImmediateContextCreateInfo_html_ae9b13ed101fe896f4e761be2057f1cb1"><div class="ttname"><a href="../../d2/d4e/structDiligent_1_1ImmediateContextCreateInfo.html#ae9b13ed101fe896f4e761be2057f1cb1">Diligent::ImmediateContextCreateInfo::QueueId</a></div><div class="ttdeci">Uint8 QueueId</div><div class="ttdoc">Queue index in GraphicsAdapterInfo::Queues.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:3412</div></div>
</div><!-- fragment --><p>Default queue priority is <code>MEDIUM</code>. Note that higher priorities may require additional system privileges.</p>
<p>To synchronize between queues, we need to create fences. A fence is a synchronization object that can be signaled in one queue and waited upon in another. <a class="el" href="../../d7/dca/namespaceDiligent.html" title="Graphics engine namespace.">Diligent</a> Engine supports two fence type. A basic fence only allows synchronization between CPU and GPU. <code>GENERAL</code> fence allows GPU-side synchronization between command queues.</p>
<div class="fragment"><div class="line">FenceDesc FenceCI;</div>
<div class="line">FenceCI.<a class="code hl_variable" href="../../d1/da0/structDiligent_1_1FenceDesc.html#a9cc329540bd390de37b91a54f2df2980">Type</a> = FENCE_TYPE_GENERAL;</div>
<div class="line"> </div>
<div class="line">FenceCI.Name = <span class="stringliteral">&quot;Graphics context fence&quot;</span>;</div>
<div class="line">m_pDevice-&gt;CreateFence(FenceCI, &amp;m_GraphicsCtxFence);</div>
<div class="line"> </div>
<div class="line">FenceCI.Name = <span class="stringliteral">&quot;Compute context fence&quot;</span>;</div>
<div class="line">m_pDevice-&gt;CreateFence(FenceCI, &amp;m_ComputeCtxFence);</div>
<div class="ttc" id="astructDiligent_1_1FenceDesc_html_a9cc329540bd390de37b91a54f2df2980"><div class="ttname"><a href="../../d1/da0/structDiligent_1_1FenceDesc.html#a9cc329540bd390de37b91a54f2df2980">Diligent::FenceDesc::Type</a></div><div class="ttdeci">FENCE_TYPE Type</div><div class="ttdoc">Fence type, see Diligent::FENCE_TYPE.</div><div class="ttdef"><b>Definition</b> Fence.h:70</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md426"></a>
Using the Async Compute Queue</h2>
<p>In the async compute queue, we execute the terrain height and normal map generation shader.</p>
<p>Creating the height and normal map textures is done similar to other tutorials with one difference: we need to set up <code>ImmediateContextMask</code>. This member indicates in which immediate contexts we can use the resource. We will use the textures in the graphics and compute contexts.</p>
<div class="fragment"><div class="line">TextureDesc TexDesc;</div>
<div class="line">TexDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>                 = <span class="stringliteral">&quot;Terrain height map&quot;</span>;</div>
<div class="line">...</div>
<div class="line">TexDesc.ImmediateContextMask =</div>
<div class="line">    (Uint64{1} &lt;&lt; m_pImmediateContext-&gt;GetDesc().ContextId) |</div>
<div class="line">    (Uint64{1} &lt;&lt; m_ComputeCtx-&gt;GetDesc().ContextId);</div>
<div class="line">m_Device-&gt;CreateTexture(TexDesc, <span class="keyword">nullptr</span>, &amp;m_HeightMap);</div>
<div class="line"> </div>
<div class="line">TexDesc.Name = <span class="stringliteral">&quot;Terrain normal map&quot;</span>;</div>
<div class="line">m_Device-&gt;CreateTexture(TexDesc, <span class="keyword">nullptr</span>, &amp;m_NormalMap);</div>
<div class="ttc" id="astructDiligent_1_1DeviceObjectAttribs_html_a14a31dc6ad69e0b79514e5349e9b4fc0"><div class="ttname"><a href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Diligent::DeviceObjectAttribs::Name</a></div><div class="ttdeci">const Char * Name</div><div class="ttdoc">Object name.</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:1319</div></div>
</div><!-- fragment --><p>For multiple queues, automatic state transition is not supported, so we manually transition the texture state to UAV and disable automatic transitions by setting the texture state to UNKNOWN:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> StateTransitionDesc Barriers[] = {</div>
<div class="line">    {m_HeightMap, RESOURCE_STATE_UNKNOWN, RESOURCE_STATE_UNORDERED_ACCESS},</div>
<div class="line">    {m_NormalMap, RESOURCE_STATE_UNKNOWN, RESOURCE_STATE_UNORDERED_ACCESS}</div>
<div class="line">};</div>
<div class="line">pContext-&gt;TransitionResourceStates(_countof(Barriers), Barriers);</div>
<div class="line"> </div>
<div class="line">m_HeightMap-&gt;SetState(RESOURCE_STATE_UNKNOWN);</div>
<div class="line">m_NormalMap-&gt;SetState(RESOURCE_STATE_UNKNOWN);</div>
</div><!-- fragment --><p>Compute pass will use resources in the UAV state, but for rendering we need to transit the texture state into SRV. If we make it in the compute context, then graphics stages will be unaffected which may cause undefined behaviour.</p>
<details >
<summary >
Detailed explanation</summary>
<p></p>
<p>In Vulkan, a UAV to SRV barrier in the compute queue looks like this:</p>
<div class="fragment"><div class="line">VkImageMemoryBarrier Barrier;</div>
<div class="line">Barrier.oldLayout     = VK_IMAGE_LAYOUT_GENERAL;</div>
<div class="line">Barrier.newLayout     = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;</div>
<div class="line">Barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;</div>
<div class="line">Barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;</div>
<div class="line">vkCmdPipelineBarrier(..., VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, ..., &amp;Barrier, ...);</div>
</div><!-- fragment --><p>However, correct barrier must include graphics stages (<code>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code>), which is only allowed in graphics queue.</p>
<p>In DirectX 12, a UAV to SRV barrier in the compute queue looks like this:</p>
<div class="fragment"><div class="line">D3D12_RESOURCE_BARRIER Barrier;</div>
<div class="line">Barrier.Type                   = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;</div>
<div class="line">Barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;</div>
<div class="line">Barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;</div>
</div><!-- fragment --><p>However, correct state must include <code>D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE</code>, which is only allowed in graphics queue.</p>
<p></p>
</details>
<p>State transition inside the render pass splits the pass into two passes, which is suboptimal on mobile devices. To avoid this, we make all transitions before and after the scene rendering:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Terrain::BeforeDraw(IDeviceContext* pContext)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> StateTransitionDesc Barriers[] = {</div>
<div class="line">        {m_HeightMap, RESOURCE_STATE_UNORDERED_ACCESS, RESOURCE_STATE_SHADER_RESOURCE},</div>
<div class="line">        {m_NormalMap, RESOURCE_STATE_UNORDERED_ACCESS, RESOURCE_STATE_SHADER_RESOURCE}</div>
<div class="line">    };</div>
<div class="line">    pContext-&gt;TransitionResourceStates(_countof(Barriers), Barriers);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Terrain::AfterDraw(IDeviceContext* pContext)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> StateTransitionDesc Barriers[] = {</div>
<div class="line">        {m_HeightMap, RESOURCE_STATE_SHADER_RESOURCE, RESOURCE_STATE_UNORDERED_ACCESS},</div>
<div class="line">        {m_NormalMap, <a class="code hl_enumvalue" href="../../d7/dca/namespaceDiligent.html#a85d1543061f540a6539307191fbefaa6ac705b1e5e29c2c3b42f6ec5a0732ddfe">RESOURCE_STATE_SHADER_RESOURCE</a>, <a class="code hl_enumvalue" href="../../d7/dca/namespaceDiligent.html#a85d1543061f540a6539307191fbefaa6aceca69505f4659daade858d1c05c2896">RESOURCE_STATE_UNORDERED_ACCESS</a>}</div>
<div class="line">    };</div>
<div class="line">    pContext-&gt;TransitionResourceStates(_countof(Barriers), Barriers);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceDiligent_html_a85d1543061f540a6539307191fbefaa6ac705b1e5e29c2c3b42f6ec5a0732ddfe"><div class="ttname"><a href="../../d7/dca/namespaceDiligent.html#a85d1543061f540a6539307191fbefaa6ac705b1e5e29c2c3b42f6ec5a0732ddfe">Diligent::RESOURCE_STATE_SHADER_RESOURCE</a></div><div class="ttdeci">@ RESOURCE_STATE_SHADER_RESOURCE</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:4817</div></div>
<div class="ttc" id="anamespaceDiligent_html_a85d1543061f540a6539307191fbefaa6aceca69505f4659daade858d1c05c2896"><div class="ttname"><a href="../../d7/dca/namespaceDiligent.html#a85d1543061f540a6539307191fbefaa6aceca69505f4659daade858d1c05c2896">Diligent::RESOURCE_STATE_UNORDERED_ACCESS</a></div><div class="ttdeci">@ RESOURCE_STATE_UNORDERED_ACCESS</div><div class="ttdef"><b>Definition</b> GraphicsTypes.h:4805</div></div>
</div><!-- fragment --><p>Read and write access to the textures must be explicitly synchronized via fences.</p>
<div class="fragment"><div class="line"><span class="comment">// Make compute context wait for the previous graphics pass</span></div>
<div class="line">m_ComputeCtx-&gt;DeviceWaitForFence(m_GraphicsCtxFence, m_GraphicsCtxFenceValue);</div>
<div class="line"> </div>
<div class="line">m_Terrain.Update(m_ComputeCtx);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Notify that compute pass is complete</span></div>
<div class="line">m_ComputeCtx-&gt;EnqueueSignal(m_ComputeCtxFence, ++m_ComputeCtxFenceValue);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit commands to the GPU</span></div>
<div class="line">m_ComputeCtx-&gt;Flush();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make graphics pass wait for the compute pass to complete</span></div>
<div class="line">m_pImmediateContext-&gt;DeviceWaitForFence(m_ComputeCtxFence, m_ComputeCtxFenceValue);</div>
</div><!-- fragment --><p>When creating a pipeline state, similar to resource initialization, we need to indicate which contexts it may be used in. Our compute PSO may be used in graphics and compute contexts depending on whether the async compute is active. <code>ImmediateContextMask</code> must be initialized to be compatible with the graphics and compute contexts:</p>
<div class="fragment"><div class="line">ComputePipelineStateCreateInfo PSOCreateInfo;</div>
<div class="line">PSOCreateInfo.<a class="code hl_variable" href="../../da/d41/structDiligent_1_1PipelineStateCreateInfo.html#a7c216c149f216b75c424c9190cd160ec">PSODesc</a>.<a class="code hl_variable" href="../../d1/da6/structDiligent_1_1PipelineStateDesc.html#af4ef61efb2eb301b01971cefc385ada0">ImmediateContextMask</a> =</div>
<div class="line">    (Uint64{1} &lt;&lt; m_pImmediateContext-&gt;GetDesc().ContextId) | </div>
<div class="line">    (Uint64{1} &lt;&lt; m_ComputeCtx-&gt;GetDesc().ContextId);</div>
<div class="line">m_Device-&gt;CreateComputePipelineState(PSOCreateInfo, &amp;m_GenPSO);</div>
<div class="ttc" id="astructDiligent_1_1PipelineStateCreateInfo_html_a7c216c149f216b75c424c9190cd160ec"><div class="ttname"><a href="../../da/d41/structDiligent_1_1PipelineStateCreateInfo.html#a7c216c149f216b75c424c9190cd160ec">Diligent::PipelineStateCreateInfo::PSODesc</a></div><div class="ttdeci">PipelineStateDesc PSODesc</div><div class="ttdoc">Pipeline state description.</div><div class="ttdef"><b>Definition</b> PipelineState.h:702</div></div>
<div class="ttc" id="astructDiligent_1_1PipelineStateDesc_html_af4ef61efb2eb301b01971cefc385ada0"><div class="ttname"><a href="../../d1/da6/structDiligent_1_1PipelineStateDesc.html#af4ef61efb2eb301b01971cefc385ada0">Diligent::PipelineStateDesc::ImmediateContextMask</a></div><div class="ttdeci">Uint64 ImmediateContextMask</div><div class="ttdoc">Defines which immediate contexts are allowed to execute commands that use this pipeline state.</div><div class="ttdef"><b>Definition</b> PipelineState.h:611</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md427"></a>
Using Async Transfer Queue</h2>
<p>In the async transfer queue, we update the texture atlas for buildings. The texture initialization is the same as for terrain textures, we only need to set up the the <code>ImmediateContextMask</code> for graphics and transfer immediate contexts:</p>
<div class="fragment"><div class="line">TextureDesc TexDesc;</div>
<div class="line">TexDesc.<a class="code hl_variable" href="../../d3/df9/structDiligent_1_1DeviceObjectAttribs.html#a14a31dc6ad69e0b79514e5349e9b4fc0">Name</a>                 = <span class="stringliteral">&quot;Buildings texture atlas&quot;</span>;</div>
<div class="line">TexDesc.ImmediateContextMask =</div>
<div class="line">    (Uint64{1} &lt;&lt; m_pImmediateContext-&gt;GetDesc().ContextId) | </div>
<div class="line">    (Uint64{1} &lt;&lt; m_TransferCtx-&gt;GetDesc().ContextId);</div>
<div class="line">m_Device-&gt;CreateTexture(TexDesc, <span class="keyword">nullptr</span>, &amp;m_OpaqueTexAtlas);</div>
</div><!-- fragment --><p>Note that the state transition requirements vary between Vulkan and DirectX 12 .</p>
<p>In Vulkan, the initial resource state in the graphics queue is <code>COPY_DEST</code>. We thansition it to <code>SHADER_RESOURCE</code>, and then back to <code>COPY_DEST</code> at the end of rendering, so in the transfer queue the resource is always in <code>COPY_DEST</code> state.</p>
<p>In DirectX 12, when a resource is transferred from graphics or compute queue to the transfer queue, it must be in the <code>COMMON</code> state. So we have to perform a bit more complex transitions: in the transfer queue, the initial state is <code>COMMON</code>, then we transition it to <code>COPY_DEST</code> and back to <code>COMMON</code> at the end of the upload pass. In the graphics queue, the initial state is <code>COMMON</code> as well, so we transition it to <code>SHADER_RESOURCE</code> and then back to <code>COMMON</code>.</p>
<div class="fragment"><div class="line">m_OpaqueTexAtlasDefaultState = RESOURCE_STATE_COPY_DEST;</div>
<div class="line">        </div>
<div class="line"><span class="keywordflow">if</span> (m_Device-&gt;GetDeviceInfo().Type == RENDER_DEVICE_TYPE_D3D12)</div>
<div class="line">    m_OpaqueTexAtlasDefaultState = RESOURCE_STATE_COMMON;</div>
<div class="line">            </div>
<div class="line"><span class="keyword">const</span> StateTransitionDesc Barrier = {m_OpaqueTexAtlas, RESOURCE_STATE_UNKNOWN, m_OpaqueTexAtlasDefaultState};</div>
<div class="line">pContext-&gt;TransitionResourceStates(1, &amp;Barrier);</div>
<div class="line">        </div>
<div class="line">m_OpaqueTexAtlas-&gt;SetState(RESOURCE_STATE_UNKNOWN);</div>
</div><!-- fragment --><p>Same as with the compute queue, we must transit to <code>SHADER_RESOURCE</code> in the graphics queue to avoid undefined behaviour.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Buildings::BeforeDraw(IDeviceContext* pContext)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> StateTransitionDesc Barrier{m_OpaqueTexAtlas, m_OpaqueTexAtlasDefaultState, RESOURCE_STATE_SHADER_RESOURCE};</div>
<div class="line">    pContext-&gt;TransitionResourceStates(1, &amp;Barrier);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Buildings::AfterDraw(IDeviceContext* pContext)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> StateTransitionDesc Barrier{m_OpaqueTexAtlas, RESOURCE_STATE_SHADER_RESOURCE, m_OpaqueTexAtlasDefaultState};</div>
<div class="line">    pContext-&gt;TransitionResourceStates(1, &amp;Barrier);</div>
<div class="line">}</div>
</div><!-- fragment --><p>For the DirectX 12 backend, we need to add transitions from <code>COMMON</code> state.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Buildings::UpdateAtlas(IDeviceContext* pContext)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (m_OpaqueTexAtlasDefaultState != RESOURCE_STATE_COPY_DEST)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> StateTransitionDesc Barrier{m_OpaqueTexAtlas, m_OpaqueTexAtlasDefaultState, RESOURCE_STATE_COPY_DEST};</div>
<div class="line">        pContext-&gt;TransitionResourceStates(1, &amp;Barrier);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    pContext-&gt;CopyTexture(...);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (m_OpaqueTexAtlasDefaultState != RESOURCE_STATE_COPY_DEST)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> StateTransitionDesc Barrier{m_OpaqueTexAtlas, RESOURCE_STATE_COPY_DEST, m_OpaqueTexAtlasDefaultState};</div>
<div class="line">        pContext-&gt;TransitionResourceStates(1, &amp;Barrier);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Read and write access to the texture must be synchronized via the fence.</p>
<div class="fragment"><div class="line"><span class="comment">// Make transfer context wait for the previous graphics pass</span></div>
<div class="line">m_TransferCtx-&gt;DeviceWaitForFence(m_GraphicsCtxFence, m_GraphicsCtxFenceValue);</div>
<div class="line"> </div>
<div class="line">m_Buildings.UpdateAtlas(m_TransferCtx, ...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Notify that upload pass is complete</span></div>
<div class="line">m_TransferCtx-&gt;EnqueueSignal(m_TransferCtxFence, ++m_TransferCtxFenceValue);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit commands to the GPU</span></div>
<div class="line">m_TransferCtx-&gt;Flush();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make graphics pass wait for the upload pass</span></div>
<div class="line">m_pImmediateContext-&gt;DeviceWaitForFence(m_TransferCtxFence, m_TransferCtxFenceValue);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md428"></a>
Graphics Queue</h2>
<p>For the graphics context, we add the commands to synchronize with other queues.</p>
<div class="fragment"><div class="line"><span class="comment">// Make graphics pass wait for the upload pass</span></div>
<div class="line">m_pImmediateContext-&gt;DeviceWaitForFence(m_TransferCtxFence, m_TransferCtxFenceValue);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make graphics pass wait for the compute pass</span></div>
<div class="line">m_pImmediateContext-&gt;DeviceWaitForFence(m_ComputeCtxFence, m_ComputeCtxFenceValue);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Graphics pass</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Signal that the graphics pass is complete</span></div>
<div class="line">m_pImmediateContext-&gt;EnqueueSignal(m_GraphicsCtxFence, ++m_GraphicsCtxFenceValue);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md429"></a>
Further Reading</h2>
<p><a href="https://therealmjp.github.io/posts/breaking-down-barriers-part-3-multiple-command-processors/">Breaking Down Barriers - Part 3: Multiple Command Processors</a><br  />
 <a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/using-compute-post-processing-in-vulkan-on-mali">Using Compute Post-Processing in Vulkan on Mali</a><br  />
 <a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/using-asynchronous-compute-on-arm-mali-gpus">Using asynchronous compute on Arm Mali GPUs</a><br  />
 <a href="https://developer.apple.com/videos/play/wwdc2020/10632/?time=258">Pass overlapping in Metal</a> - video (4:19 - 9:00) <br  />
 <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/user-mode-heap-synchronization">Multi-engine synchronization</a><br  />
 <a href="https://gpuopen.com/learn/understanding-gpu-context-rolls/">Understanding GPU context rolls</a><br  />
 <a href="https://devblogs.microsoft.com/directx/hardware-accelerated-gpu-scheduling/">Hardware Accelerated GPU Scheduling</a><br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <a href="https://diligentgraphics.com">
        <img class="footer" src="https://github.com/DiligentGraphics/DiligentCore/raw/master/media/diligentgraphics-logo.png" width="99" height="32" alt="Diligent Graphics" />
      </a>
    </li>
  </ul>
</div>
</body>
</html>
