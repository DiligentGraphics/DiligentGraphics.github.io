#ifndef _PBR_COMMON_FXH_
#define _PBR_COMMON_FXH_

#ifndef PI
#    define PI 3.141592653589793
#endif

float dot_sat(float3 a, float3 b)
{
    return saturate(dot(a, b));
}

float pow5(float x)
{
    float x2 = x * x;
    return x2 * x2 * x;
}

float3 pow5(float3 x)
{
    float3 x2 = x * x;
    return x2 * x2 * x;
}

// Returns a random cosine-weighted direction on the hemisphere around z = 1.
void SampleDirectionCosineHemisphere(in  float2 UV,  // Normal random variables
                                     out float3 Dir, // Direction
                                     out float  Prob // Probability of the generated direction
                                     )
{
    Dir.x = cos(2.0 * PI * UV.x) * sqrt(1.0 - UV.y);
    Dir.y = sin(2.0 * PI * UV.x) * sqrt(1.0 - UV.y);
    Dir.z = sqrt(UV.y);

    // Avoid zero probability
    Prob = max(Dir.z, 1e-6) / PI;
}

// Returns a random cosine-weighted direction on the hemisphere around N.
void SampleDirectionCosineHemisphere(in  float3 N,   // Normal
                                     in  float2 UV,  // Normal random variables
                                     out float3 Dir, // Direction
                                     out float  Prob // Probability of the generated direction
                                     )
{
    float3 T = normalize(cross(N, abs(N.y) > 0.5 ? float3(1.0, 0.0, 0.0) : float3(0.0, 1.0, 0.0)));
    float3 B = cross(T, N);
    SampleDirectionCosineHemisphere(UV, Dir, Prob);
    Dir = normalize(Dir.x * T + Dir.y * B + Dir.z * N);
}

// Lambertian diffuse
// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
float3 LambertianDiffuse(float3 DiffuseColor)
{
    return DiffuseColor / PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel term from "An Inexpensive BRDF Model for Physically based Rendering" by Christophe Schlick
// https://en.wikipedia.org/wiki/Schlick%27s_approximation
//
//      Rf(Theta) = Rf(0) + (1 - Rf(0)) * (1 - cos(Theta))^5
//
//
//           '.       |       .'
//             '.     |Theta.'
//               '.   |   .'
//                 '. | .'
//        ___________'.'___________
//                   '|
//                  ' |
//                 '  |
//                '   |
//               ' Phi|
//
// Note that precise relfectance term is given by the following expression:
//
//      Rf(Theta) = 0.5 * (sin^2(Theta - Phi) / sin^2(Theta + Phi) + tan^2(Theta - Phi) / tan^2(Theta + Phi))
//
#define SCHLICK_REFLECTION(VdotH, Reflectance0, Reflectance90) ((Reflectance0) + ((Reflectance90) - (Reflectance0)) * pow5(clamp(1.0 - (VdotH), 0.0, 1.0)))
float SchlickReflection(float VdotH, float Reflectance0, float Reflectance90)
{
    return SCHLICK_REFLECTION(VdotH, Reflectance0, Reflectance90);
}
float3 SchlickReflection(float VdotH, float3 Reflectance0, float3 Reflectance90)
{
    return SCHLICK_REFLECTION(VdotH, Reflectance0, Reflectance90);
}

float SchlickToF0(float VdotH, float f, float f90)
{
    float x  = clamp(1.0 - VdotH, 0.0, 1.0);
    float x5 = clamp(pow5(x), 0.0, 0.9999);
    return (f - f90 * x5) / (1.0 - x5);
}

float3 SchlickToF0(float VdotH, float3 f, float3 f90)
{
    float x  = clamp(1.0 - VdotH, 0.0, 1.0);
    float x5 = clamp(pow5(x), 0.0, 0.9999);
    return (f - f90 * x5) / (1.0 - x5);
}

// Visibility = G2(v,l,a) / (4 * (n,v) * (n,l))
// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf
float SmithGGXVisibilityCorrelated(float NdotL, float NdotV, float AlphaRoughness)
{
    // G1 (masking) is % microfacets visible in 1 direction
    // G2 (shadow-masking) is % microfacets visible in 2 directions
    // If uncorrelated:
    //    G2(NdotL, NdotV) = G1(NdotL) * G1(NdotV)
    //    Less realistic as higher points are more likely visible to both L and V
    //
    // https://ubm-twvideo01.s3.amazonaws.com/o1/vault/gdc2017/Presentations/Hammon_Earl_PBR_Diffuse_Lighting.pdf

    float a2 = AlphaRoughness * AlphaRoughness;

    float GGXV = NdotL * sqrt(max(NdotV * NdotV * (1.0 - a2) + a2, 1e-7));
    float GGXL = NdotV * sqrt(max(NdotL * NdotL * (1.0 - a2) + a2, 1e-7));

    return 0.5 / (GGXV + GGXL);
}

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel
float SmithGGXVisibilityCorrelated_Anisotropic(float NdotL,
                                               float NdotV,
                                               float TdotL,
                                               float TdotV,
                                               float BdotL,
                                               float BdotV,
                                               float AlphaRoughnessT,
                                               float AlphaRoughnessB)
{
    float LambdaV = NdotL * max(length(float3(AlphaRoughnessT * TdotV, AlphaRoughnessB * BdotV, NdotV)), 1e-3);
    float LambdaL = NdotV * max(length(float3(AlphaRoughnessT * TdotL, AlphaRoughnessB * BdotL, NdotL)), 1e-3);
    return 0.5 / (LambdaV + LambdaL);
}

// Smith GGX shadow-masking function G2(v,l,a)
float SmithGGXShadowMasking(float NdotL, float NdotV, float AlphaRoughness)
{
    return 4.0 * NdotL * NdotV * SmithGGXVisibilityCorrelated(NdotL, NdotV, AlphaRoughness);
}

// Smith GGX masking function G1
// [1] "Sampling the GGX Distribution of Visible Normals" (2018) by Eric Heitz - eq. (2)
// https://jcgt.org/published/0007/04/01/
float SmithGGXMasking(float NdotV, float AlphaRoughness)
{
    float a2 = AlphaRoughness * AlphaRoughness;

    // In [1], eq. (2) is defined for the tangent-space view direction V:
    //
    //                                        1
    //      G1(V) = -----------------------------------------------------------
    //                                    {      (ax*V.x)^2 + (ay*V.y)^2)  }
    //               1 + 0.5 * ( -1 + sqrt{ 1 + -------------------------- } )
    //                                    {              V.z^2             }
    //
    // Note that [1] uses notation N for the micronormal, but in our case N is the macronormal,
    // while micronormal is H (aka the halfway vector).
    //
    // After multiplying both nominator and denominator by 2*V.z and given that in our
    // case ax = ay = a, we get:
    //
    //                                2 * V.z                                        2 * V.z
    //      G1(V) = ------------------------------------------- =  ----------------------------------------
    //               V.z + sqrt{ V.z^2 + a2 * (V.x^2 + V.y^2) }     V.z + sqrt{ V.z^2 + a2 * (1 - V.z^2) }
    //
    // Since V.z = NdotV, we finally get:

    float Denom = NdotV + sqrt(a2 + (1.0 - a2) * NdotV * NdotV);
    return 2.0 * max(NdotV, 0.0) / max(Denom, 1e-6);
}


// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games, Equation 3.
float NormalDistribution_GGX(float NdotH, float AlphaRoughness)
{
    // "Sampling the GGX Distribution of Visible Normals" (2018) by Eric Heitz - eq. (1)
    // https://jcgt.org/published/0007/04/01/

    // Make sure we reasonably handle AlphaRoughness == 0
    // (which corresponds to delta function)
    AlphaRoughness = max(AlphaRoughness, 1e-3);

    float a2  = AlphaRoughness * AlphaRoughness;
    float nh2 = NdotH * NdotH;
    float f   = nh2 * a2 + (1.0 - nh2);
    return a2 / max(PI * f * f, 1e-9);
}

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel
float NormalDistribution_GGX_Anisotropic(float  NdotH,
                                         float  TdotH,
                                         float  BdotH,
                                         float  AlphaRoughnessT,
                                         float  AlphaRoughnessB)
{
    float  a2 = AlphaRoughnessT * AlphaRoughnessB;
    float3 v  = float3(AlphaRoughnessB * TdotH, AlphaRoughnessT * BdotH, a2 * NdotH);
    float  v2 = dot(v, v);
    float  w2 = a2 / max(v2, 1e-6);
    return a2 * w2 * w2 * (1.0 / PI);
}


// Samples a normal from Visible Normal Distribution as described in
// [1] "A Simpler and Exact Sampling Routine for the GGX Distribution of Visible Normals" (2017) by Eric Heitz
//     https://hal.archives-ouvertes.fr/hal-01509746/document
// [2] "Sampling the GGX Distribution of Visible Normals" (2018) by Eric Heitz
//     https://jcgt.org/published/0007/04/01/
//
// Notes:
//      - View direction must be pointing away from the surface.
//      - Returned normal is in tangent space with Z up.
//      - Returned normal should be used to reflect the view direction and obtain
//        the sampling direction.
float3 SmithGGXSampleVisibleNormal(float3 View, // View direction in tangent space
                                   float  ax,   // X roughness
                                   float  ay,   // Y roughness
                                   float  u1,   // Uniform random variable in [0, 1]
                                   float  u2    // Uniform random variable in [0, 1]
)
{
    // Stretch the view vector so we are sampling as if roughness==1
    float3 V = normalize(View * float3(ax, ay, 1.0));

#if 1
    // Technique from [1]
    // Note: while [2] claims to provide a better parameterization, it produces
    //       subjectively noisier images, so we will stick with method from [1].

    // Build an orthonormal basis with V, T1, and T2
    float3 T1 = (V.z < 0.999) ? normalize(cross(V, float3(0.0, 0.0, 1.0))) : float3(1.0, 0.0, 0.0);
    float3 T2 = cross(T1, V);

    // Choose a point on a disk with each half of the disk weighted
    // proportionally to its projection onto direction V
    float a = 1.0 / (1.0 + V.z);
    float r = sqrt(u1);
    float phi = (u2 < a) ? (u2 / a) * PI : PI + (u2 - a) / (1.0 - a) * PI;
    float p1 = r * cos(phi);
    float p2 = r * sin(phi) * ((u2 < a) ? 1.0 : V.z);
#else
    // Technique from [2]
    // Note: [1] uses earlier parameterization that cannot be used with view directions located in the lower
    //       hemisphere (View.z < 0). Though this is not a problem for classic microfacet BSDF models,
    //       [2] provides a better approximation that is not subject to this limitation.

    // Build orthonormal basis (with special case if cross product is zero) (Section 4.1)
    float lensq = dot(V.xy, V.xy);
    float3 T1 = lensq > 0.0 ? float3(-V.y, V.x, 0.0) / sqrt(lensq) : float3(1.0, 0.0, 0.0);
    float3 T2 = cross(V, T1);

    // Sample the projected area (Section 4.2)
    float r   = sqrt(u1);
    float phi = 2.0 * PI * u2;
    float p1 = r * cos(phi);
    float p2 = r * sin(phi);
    float s  = 0.5 * (1.0 + V.z);
    p2 = (1.0 - s) * sqrt(1.0 - p1 * p1) + s * p2;
#endif

    // Calculate the normal in the stretched tangent space
    float3 N = p1 * T1 + p2 * T2 + sqrt(max(0.0, 1.0 - p1 * p1 - p2 * p2)) * V;

    // Transform the normal back to the ellipsoid configuration
    return normalize(float3(ax * N.x, ay * N.y, max(0.0, N.z)));
}

// Samples a normal from Visible Normal Distribution as described in
// [1] "Sampling Visible GGX Normals with Spherical Caps" (2023) by Jonathan Dupuy, Anis Benyoub
//     https://arxiv.org/pdf/2306.05044.pdf
float3 SmithGGXSampleVisibleNormalSC(float3 View, // View direction in tangent space
                                     float  ax,   // X roughness
                                     float  ay,   // Y roughness
                                     float  u1,   // Uniform random variable in [0, 1]
                                     float  u2    // Uniform random variable in [0, 1]
)
{
    // Stretch the view vector so we are sampling as if roughness==1
    float3 V = normalize(View * float3(ax, ay, 1.0));

    float Phi = 2.0 * PI * u1;
    float Z = (1.0 - u2) * (1.0 + V.z) - V.z;
    float SinTheta = sqrt(clamp(1.0 - Z * Z, 0.0, 1.0));
    float3 H = float3(SinTheta * cos(Phi), SinTheta * sin(Phi), Z) + V;

    // Transform the normal back to the ellipsoid configuration
    return normalize(float3(ax * H.x, ay * H.y, H.z));
}

// Returns the probability of sampling direction L for the view direction V and normal N
// using the visible normals distribution.
// [1] "Sampling the GGX Distribution of Visible Normals" (2018) by Eric Heitz
// https://jcgt.org/published/0007/04/01/
float SmithGGXSampleDirectionPDF(float3 V, float3 N, float3 L, float AlphaRoughness)
{
    // Micronormal is the halfway vector
    float3 H = normalize(V + L);

    float NdotH = dot(H, N);
    float NdotV = dot(N, V);
    float NdotL = dot(N, L);
    //float VdotH = dot(V, H);
    if (NdotH > 0.0 && NdotV > 0.0 && NdotL > 0.0)
    {
        // Note that [1] uses notation N for the micronormal, but in our case N is the macronormal,
        // while micronormal is H (aka the halfway vector).
        float NDF = NormalDistribution_GGX(NdotH, AlphaRoughness); // (1) - D(N)
        float G1  = SmithGGXMasking(NdotV, AlphaRoughness);        // (2) - G1(V)

        float VNDF = G1 /* * VdotH */ * NDF / NdotV; // (3) - Dv(N)
        return  VNDF / (4.0 /* * VdotH */); // (17) - VdotH cancels out
    }
    else
    {
        return 0.0;
    }
}

struct AngularInfo
{
    float3 N;
    float3 V;
    float3 L;
    float3 H;
    
    float NdotL; // cos angle between normal and light direction
    float NdotV; // cos angle between normal and view direction
    float NdotH; // cos angle between normal and half vector
    float LdotH; // cos angle between light direction and half vector
    float VdotH; // cos angle between view direction and half vector
};

AngularInfo GetAngularInfo(float3 PointToLight, float3 Normal, float3 View)
{
    float3 n = normalize(Normal);       // Outward direction of surface point
    float3 v = normalize(View);         // Direction from surface point to camera
    float3 l = normalize(PointToLight); // Direction from surface point to light
    float3 h = normalize(l + v);        // Direction of the vector between l and v

    AngularInfo info;
    info.N = n;
    info.V = v;
    info.L = l;
    info.H = h;

    info.NdotL = dot_sat(n, l);
    info.NdotV = dot_sat(n, v);
    info.NdotH = dot_sat(n, h);
    info.LdotH = dot_sat(l, h);
    info.VdotH = dot_sat(v, h);

    return info;
}

struct SurfaceReflectanceInfo
{
    float  PerceptualRoughness;
    float3 Reflectance0;
    float3 Reflectance90;
    float3 DiffuseColor;
};

// BRDF with Lambertian diffuse term and Smith-GGX specular term.
void SmithGGX_BRDF(in float3                 PointToLight,
                   in float3                 Normal,
                   in float3                 View,
                   in SurfaceReflectanceInfo SrfInfo,
                   out float3                DiffuseContrib,
                   out float3                SpecContrib,
                   out float                 NdotL)
{
    AngularInfo angularInfo = GetAngularInfo(PointToLight, Normal, View);

    DiffuseContrib = float3(0.0, 0.0, 0.0);
    SpecContrib    = float3(0.0, 0.0, 0.0);
    NdotL          = angularInfo.NdotL;
    // If one of the dot products is larger than zero, no division by zero can happen. Avoids black borders.
    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)
    {
        //           D(h,a) * G2(v,l,a) * F(v,h,f0)
        // f(v,l) = -------------------------------- = D(h,a) * Vis(v,l,a) * F(v,h,f0)
        //               4 * (n,v) * (n,l)
        // where
        //
        // Vis(v,l,a) = G2(v,l,a) / (4 * (n,v) * (n,l))

        // It is not a mistake that AlphaRoughness = PerceptualRoughness ^ 2 and that
        // SmithGGXVisibilityCorrelated and NormalDistribution_GGX then use a2 = AlphaRoughness ^ 2.
        // See eq. 3 in https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
        float  AlphaRoughness = SrfInfo.PerceptualRoughness * SrfInfo.PerceptualRoughness;
        float  D   = NormalDistribution_GGX(angularInfo.NdotH, AlphaRoughness);
        float  Vis = SmithGGXVisibilityCorrelated(angularInfo.NdotL, angularInfo.NdotV, AlphaRoughness);
        float3 F   = SchlickReflection(angularInfo.VdotH, SrfInfo.Reflectance0, SrfInfo.Reflectance90);

        DiffuseContrib = (1.0 - F) * LambertianDiffuse(SrfInfo.DiffuseColor);
        SpecContrib    = F * Vis * D;
    }
}

void SmithGGX_BRDF_Anisotropic(in float3                 PointToLight,
                               in float3                 Normal,
                               in float3                 View,
                               in float3                 Tangent,
                               in float3                 Bitangent,
                               in SurfaceReflectanceInfo SrfInfo,
                               in float                  AlphaRoughnessT,
                               in float                  AlphaRoughnessB,
                               out float3                DiffuseContrib,
                               out float3                SpecContrib,
                               out float                 NdotL)
{
    AngularInfo angularInfo = GetAngularInfo(PointToLight, Normal, View);

    DiffuseContrib = float3(0.0, 0.0, 0.0);
    SpecContrib    = float3(0.0, 0.0, 0.0);
    NdotL          = angularInfo.NdotL;
    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)
    {
        float TdotH = dot(Tangent, angularInfo.H);
        float BdotH = dot(Bitangent, angularInfo.H);
        float TdotL = dot(Tangent, angularInfo.L);
        float TdotV = dot(Tangent, angularInfo.V);
        float BdotL = dot(Bitangent, angularInfo.L);
        float BdotV = dot(Bitangent, angularInfo.V);
        
        float D = NormalDistribution_GGX_Anisotropic(
            angularInfo.NdotH,
            TdotH,
            BdotH,
            AlphaRoughnessT,
            AlphaRoughnessB);

        float Vis = SmithGGXVisibilityCorrelated_Anisotropic(
            angularInfo.NdotL,
            angularInfo.NdotV,
            TdotL,
            TdotV,
            BdotL,
            BdotV,
            AlphaRoughnessT,
            AlphaRoughnessB);
        
        float3 F = SchlickReflection(angularInfo.VdotH, SrfInfo.Reflectance0, SrfInfo.Reflectance90);

        DiffuseContrib = (1.0 - F) * LambertianDiffuse(SrfInfo.DiffuseColor);
        SpecContrib    = F * Vis * D;
    }
}


// Sheen ("Production Friendly Microfacet Sheen BRDF", Estevez and Kulla 2017)

float NormalDistribution_Charlie(float NdotH, float SheenRoughness)
{
    SheenRoughness = max(SheenRoughness, 1e-6); //clamp (0,1]
    float Alpha = SheenRoughness * SheenRoughness;
    float InvA  = 1.0 / Alpha;
    float Cos2h = NdotH * NdotH;
    float Sin2h = max(1.0 - Cos2h, 0.0078125); // 2^(-14/2), so Sin2h^2 > 0 in fp16
    return (2.0 + InvA) * pow(Sin2h, InvA * 0.5) / (2.0 * PI);
}

float LambdaSheenNumericHelper(float x, float AlphaG)
{
    float OneMinusAlphaSq = (1.0 - AlphaG) * (1.0 - AlphaG);
    float a = lerp( 21.5473, 25.32450, OneMinusAlphaSq);
    float b = lerp( 3.82987,  3.32435, OneMinusAlphaSq);
    float c = lerp( 0.19823,  0.16801, OneMinusAlphaSq);
    float d = lerp(-1.97760, -1.27393, OneMinusAlphaSq);
    float e = lerp(-4.32054, -4.85967, OneMinusAlphaSq);
    return a / (1.0 + b * pow(x, c)) + d * x + e;
}

float LambdaSheen(float CosTheta, float AlphaG)
{
    if (abs(CosTheta) < 0.5)
    {
        return exp(LambdaSheenNumericHelper(CosTheta, AlphaG));
    }
    else
    {
        return exp(2.0 * LambdaSheenNumericHelper(0.5, AlphaG) - LambdaSheenNumericHelper(1.0 - CosTheta, AlphaG));
    }
}

float SheenVisibility(float NdotL, float NdotV, float SheenRoughness)
{
    SheenRoughness = max(SheenRoughness, 1e-6); //clamp (0,1]
    float AlphaG = SheenRoughness * SheenRoughness;
    // NOTE: this value is tweaked to work well for grazing angles.
    //       Larger values (e.g. 1e-7) produce dark spots, while
    //       smaller values (e.g. 1e-8) result in bright spots.
    float Epsilon = 5e-8;
    return saturate(1.0 / ((1.0 + LambdaSheen(NdotV, AlphaG) + LambdaSheen(NdotL, AlphaG)) * max(4.0 * NdotV * NdotL, Epsilon)));
}

float3 SheenSpecularBRDF(float3 SheenColor, float SheenRoughness, float NdotL, float NdotV, float NdotH)
{
    float D   = NormalDistribution_Charlie(NdotH, SheenRoughness);
    float Vis = SheenVisibility(NdotL, NdotV, SheenRoughness);
    return SheenColor * D * Vis;
}

#endif // _PBR_COMMON_FXH_
{
    "Defaults": {
        "Shader": {
            "SourceLanguage": "HLSL",
            "Desc": {
                "UseCombinedTextureSamplers": true
            }
        },
        "Pipeline": {
            "PSODesc": {
                "ResourceLayout": {
                    "DefaultVariableType": "MUTABLE"
                }
            }
        }
    },

    "Pipelines": [
        {
            "PSODesc": {
                "Name": "G-Buffer PSO",
                "ResourceLayout": {
                    "Variables": [
                        {
                            "Name": "cbConstants",
                            "ShaderStages": "PIXEL",
                            "Type": "STATIC"
                        }
                    ]
                }
            },
            "GraphicsPipeline": {
                "PrimitiveTopology": "TRIANGLE_LIST",
                "RasterizerDesc": {
                    "CullMode": "NONE"
                },
                "DepthStencilDesc": {
                    "DepthEnable": false
                }
            },
            "pVS": {
                "Desc": {
                    "Name": "Screen Triangle VS"
                },
                "FilePath": "screen_tri.vsh",
                "EntryPoint": "main"
            },
            "pPS": {
                "Desc": {
                    "Name": "G-Buffer PS"
                },
                "FilePath": "g_buffer.psh",
                "EntryPoint": "main"
            }
        },

        {
            "PSODesc": {
                "Name": "Path Trace PSO",
                "ResourceLayout": {
                    "Variables": [
                        {
                            "Name": "cbConstants",
                            "ShaderStages": "PIXEL",
                            "Type": "STATIC"
                        }
                    ]
                }
            },
            "GraphicsPipeline": {
                "PrimitiveTopology": "TRIANGLE_LIST",
                "RasterizerDesc": {
                    "CullMode": "NONE"
                },
                "DepthStencilDesc": {
                    "DepthEnable": false
                }
            },
            "pVS": {
                "Desc": {
                    "Name": "Screen Triangle VS"
                },
                "FilePath": "screen_tri.vsh",
                "EntryPoint": "main"
            },
            "pPS": {
                "Desc": {
                    "Name": "Path Trace PS"
                },
                "FilePath": "path_trace.psh",
                "EntryPoint": "main"
            }
        },

        {
            "PSODesc": {
                "Name": "Resolve PSO",
                "ResourceLayout": {
                    "Variables": [
                        {
                            "Name": "cbConstants",
                            "ShaderStages": "PIXEL",
                            "Type": "STATIC"
                        }
                    ]
                }
            },
            "GraphicsPipeline": {
                "PrimitiveTopology": "TRIANGLE_LIST",
                "RasterizerDesc": {
                    "CullMode": "NONE"
                },
                "DepthStencilDesc": {
                    "DepthEnable": false
                }
            },
            "pVS": {
                "Desc": {
                    "Name": "Screen Triangle VS"
                },
                "FilePath": "screen_tri.vsh",
                "EntryPoint": "main"
            },
            "pPS": {
                "Desc": {
                    "Name": "Resolve PS"
                },
                "FilePath": "resolve.psh",
                "EntryPoint": "main"
            }
        }
    ]
}
#pragma pack_matrix(row_major)

#include "structures.fxh"
#include "scene.fxh"

cbuffer cbConstants
{
    ShaderConstants g_Constants;
}

struct PSInput
{
    float4 Pos    : SV_POSITION;
    float2 ClipXY : ClipPos;
};

struct PSOutput
{
    float4 BaseColor : SV_TARGET0;
    float4 Normal    : SV_TARGET1;
    float4 Emittance : SV_TARGET2;
    float2 PhysDesc  : SV_TARGET3;
    float  Depth     : SV_TARGET4;
};

void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{
    // Trace the ray from the near to the far clip plane
    float3 f3RayStart = ScreenToWorld(PSIn.Pos.xy, 0.0, g_Constants.f2ScreenSize, g_Constants.ViewProjInvMat);
    float3 f3RayEnd   = ScreenToWorld(PSIn.Pos.xy, 1.0, g_Constants.f2ScreenSize, g_Constants.ViewProjInvMat);

    RayInfo Ray;
    Ray.Origin = f3RayStart; 
    Ray.Dir    = normalize(f3RayEnd - f3RayStart);

    // Trace the scene
    HitInfo Hit = IntersectScene(Ray, g_Constants.Scene);

    PSOut.BaseColor = float4(Hit.Mat.BaseColor.rgb, float(Hit.Mat.Type) / 255.0);
    PSOut.Emittance = float4(Hit.Mat.Emittance.rgb, 0.0);
    PSOut.PhysDesc  = float2(Hit.Mat.Metallic, Hit.Mat.Roughness);

    // [-1, +1] -> [0, 1]
    PSOut.Normal = float4(saturate(Hit.Normal * 0.5 + 0.5), Hit.Mat.IOR / IOR_GBUFFER_SCALE);

    if (Hit.Distance < INF)
    {
        // Compute depth of the hit point
        float3 HitWorldPos = Ray.Origin + Ray.Dir * Hit.Distance;
        float4 HitClipPos  = mul(float4(HitWorldPos, 1.0), g_Constants.ViewProjMat);
        PSOut.Depth        = min(HitClipPos.z / HitClipPos.w, 1.0);
    }
    else
    {
        // No hit - background
        PSOut.Depth = 1.0;
    }
}
#ifndef _RANDOM_FXH_
#define _RANDOM_FXH_

// https://www.shadertoy.com/view/Xt3cDn
//Quality hashes collection
//by nimitz 2018 (twitter: @stormoid)

//The MIT License
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/*
	This is a collection of useful "high-quality" hash functions for WebGL 2 (or anything supporting uints
	and bitwise ops) returning values in the 0..1 range as 32bit floats

	I am using either the a XXhash32 (https://github.com/Cyan4973/xxHash) modified function (for low input
	count). This is a relatively fast and very high quality hash function that can be used as a basis for
	comparison.	My modified version was tested to make sure it still has quality comparable with the
	reference implementation.

	The second option is a modified version of iq's "Integer Hash III" (https://www.shadertoy.com/view/4tXyWN)
	Which I tested using ENT (http://www.fourmilab.ch/random/) and turned out to have serious quality issues.	
	I added the same XORShift finisher as XXHash to improve the characteristics and this turned out	to work
	much better than I hoped, every test I have ran suggest that the quality of the modified version is very
	high. I also implemented 1D and 3D input versions of this hash and tested to make sure the quality
	remained high.

	I did some prelinimary testing and it seems that the bit rotation line(s) of the XXHash implementations can
	be omitted without much consequence in terms of quality (for very low input count as used here).
	This would make the xxhash based method as fast as the other and the quality would likely be higher,
	further testing would be required to confirm.


	For the generation of multiple outputs dimensions (if needed) from the base hash I am using MINSTD
	with the generator parameters from: http://random.mat.sbg.ac.at/results/karl/server/node4.html
	I also tested the hash quality after the MINSTD step and there seems to be little to no loss in quality from
	that final step. One thing I did not test for is the potential correlation between the MINSTD generators,
	but I doubt	this would be an issue, let me know if turns out to be the case.

	I included the 1D and 3D input versions in the common tab as to not clutter this tab too much.


	Please report any issues, statistical or otherwise either here in the comments section
	or on twitter.


	See the bottom of this page for an example of usage with arbitrary float input.
*/


uint baseHash(uint2 p)
{
    p = 1103515245U*((p >> 1U)^(p.yx));
    uint h32 = 1103515245U*((p.x)^(p.y>>3U));
    return h32^(h32 >> 16);
}

float hash12(uint2 x)
{
    uint n = baseHash(x);
    return float(n)*(1.0/float(0xffffffffU));
}

float2 hash22(uint2 x)
{
    uint n = baseHash(x);
    uint2 rz = uint2(n, n*48271U);
    return float2((rz.xy >> 1) & uint2(0x7fffffffU, 0x7fffffffU))/float(0x7fffffff);
}

float3 hash32(uint2 x)
{
    uint n = baseHash(x);
    uint3 rz = uint3(n, n*16807U, n*48271U);
    return float3((rz >> 1) & uint3(0x7fffffffU, 0x7fffffffU, 0x7fffffffU))/float(0x7fffffff);
}

float4 hash42(uint2 x)
{
    uint n = baseHash(x);
    uint4 rz = uint4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html
    return float4((rz >> 1) & uint4(0x7fffffffU, 0x7fffffffU, 0x7fffffffU, 0x7fffffffU))/float(0x7fffffff);
}

#endif // _RANDOM_FXH_
#pragma pack_matrix(row_major)

#include "structures.fxh"
#include "scene.fxh"
#include "hash.fxh"
#include "PBR_Common.fxh"

struct PSInput
{
    float4 Pos : SV_POSITION;
    float2 ClipXY : ClipPos;
};

Texture2D g_BaseColor;
Texture2D g_Normal;
Texture2D g_Emittance;
Texture2D g_PhysDesc;
Texture2D g_Depth;

Texture2D<float4> g_Radiance;

cbuffer cbConstants
{
    ShaderConstants g_Constants;
}

#ifndef THREAD_GROUP_SIZE
#   define THREAD_GROUP_SIZE 8
#endif

// Gets the surface reflectance info from the material attributes
SurfaceReflectanceInfo GetReflectanceInfo(Material Mat)
{
    float3 f0 = float3(0.04, 0.04, 0.04);

    SurfaceReflectanceInfo SrfInfo;
    SrfInfo.PerceptualRoughness = Mat.Roughness;
    SrfInfo.DiffuseColor        = Mat.BaseColor.rgb * (float3(1.0, 1.0, 1.0) - f0) * (1.0 - Mat.Metallic);
    SrfInfo.Reflectance0        = lerp(f0, Mat.BaseColor.rgb, Mat.Metallic);

    float reflectance = max(max(SrfInfo.Reflectance0.r, SrfInfo.Reflectance0.g), SrfInfo.Reflectance0.b);
    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to "Real-Time-Rendering" 4th editon on page 325.
    SrfInfo.Reflectance90 = clamp(reflectance * 50.0, 0.0, 1.0) * float3(1.0, 1.0, 1.0);

    return SrfInfo;
}

float3 BRDF(HitInfo Hit, float3 OutDir, float3 InDir)
{
    SurfaceReflectanceInfo SrfInfo = GetReflectanceInfo(Hit.Mat);

    float3 DiffuseContrib;
    float3 SpecContrib;
    float  NdotL;
    SmithGGX_BRDF(InDir, // To light
                  Hit.Normal,
                  OutDir,
                  SrfInfo,
                  DiffuseContrib,
                  SpecContrib,
                  NdotL
    );

    return DiffuseContrib + SpecContrib;
}

// Probability of selecting specular lobe vs diffuse lobe
#define SMITH_GGX_SPECULAR_PROB 0.5

// Importance-sample Lambertian + Smith-GGX BRDF
//
//     L(x->v)      L(x<-l)
//          '.   .'
//        v   '.'   l
//             x
// 
//  L(x->v) = L(x->l) * BRDF(x, v, l) * (n, l) / p(l)
//
struct BRDFSamplingAttribs
{
    float3 Dir;         // l
    float3 Reflectance; // BRDF(x, v, l) * (n, l) / p(l)
    float  Prob;        // p(l)
};
BRDFSamplingAttribs ImportanceSampleSmithGGX(HitInfo Hit, float3 View, float3 rnd3)
{
    SurfaceReflectanceInfo SrfInfo = GetReflectanceInfo(Hit.Mat);

    BRDFSamplingAttribs Sample;
    Sample.Dir         = float3(0.0, 0.0, 0.0);
    Sample.Reflectance = float3(0.0, 0.0, 0.0);
    Sample.Prob        = 0.0;

    float DiffuseProb = 1.0 - SMITH_GGX_SPECULAR_PROB;
    // Choose diffuse (Lambertian) vs specular (Smith-GGX) path
    if (rnd3.z < DiffuseProb)
    {
        // Importance-sampling of the Lambertian BRDF is the cosine-weighted distribution
        SampleDirectionCosineHemisphere(Hit.Normal, rnd3.xy, Sample.Dir, Sample.Prob);
        Sample.Prob *= DiffuseProb;

        float3 H     = normalize(View + Sample.Dir);
        float  HdotV = dot(H, View);
        float3 F     = SchlickReflection(HdotV, SrfInfo.Reflectance0, SrfInfo.Reflectance90);

        // BRDF        = DiffuseColor / PI
        // DirProb     = CosTheta / PI
        // Reflectance = (1.0 - F) * BRDF * CosTheta / (DirProb * DiffuseProb)
#if OPTIMIZED_BRDF_REFLECTANCE
        Sample.Reflectance = (1.0 - F) * SrfInfo.DiffuseColor / DiffuseProb;
#else
        float CosTheta = dot(Hit.Normal, Sample.Dir);
        Sample.Reflectance = (1.0 - F) * LambertianDiffuse(SrfInfo.DiffuseColor) * CosTheta / Sample.Prob;
#endif
    }
    else
    {
        // Importance-sample Smith-GGX using Visible Normal Distribution.
        // [1] "A Simpler and Exact Sampling Routine for the GGX Distribution of Visible Normals" (2017) by Eric Heitz
        //     https://hal.archives-ouvertes.fr/hal-01509746/document
        // [2] "Sampling the GGX Distribution of Visible Normals" (2018) by Eric Heitz
        //     https://jcgt.org/published/0007/04/01/
        // [3] "Importance Sampling techniques for GGX with Smith Masking-Shadowing" by Joe Schutte
        //     https://schuttejoe.github.io/post/ggximportancesamplingpart2/

        // Construct tangent-space basis
        float3 N = Hit.Normal;
        float3 T = normalize(cross(N, abs(N.y) > 0.5 ? float3(1.0, 0.0, 0.0) : float3(0.0, 1.0, 0.0)));
        float3 B = cross(T, N);
        float3x3 TangentToWorld = MatrixFromRows(T, B, N);

        float AlphaRoughness = SrfInfo.PerceptualRoughness * SrfInfo.PerceptualRoughness;

        // Transform view direction from world to tangent space
        float3 ViewDirTS     = normalize(mul(View, transpose(TangentToWorld)));
        // Get the tangent-space micronormal from the GGX Visible Normal Distribution
        float3 MicroNormalTS = SmithGGXSampleVisibleNormal(ViewDirTS, AlphaRoughness, AlphaRoughness, rnd3.x, rnd3.y);
        // Reflect view direction off the micronormal to get the sampling direction
        float3 SampleDirTS   = reflect(-ViewDirTS, MicroNormalTS);
        float3 NormalTS      = float3(0.0, 0.0, 1.0);

        // Transform tangent-space normal to world space
        Sample.Dir = normalize(mul(SampleDirTS, TangentToWorld));
        // Get probability of sampling direction
        Sample.Prob = SmithGGXSampleDirectionPDF(ViewDirTS, NormalTS, SampleDirTS, AlphaRoughness) * SMITH_GGX_SPECULAR_PROB;

        // Micro normal is the halfway vector
        float HdotV = dot(MicroNormalTS, ViewDirTS);
        // Tangent-space normal is (0, 0, 1)
        float NdotL = SampleDirTS.z;
        float NdotV = ViewDirTS.z;
        if (NdotL > 0 && NdotV > 0)
        {
            float3 F = SchlickReflection(HdotV, SrfInfo.Reflectance0, SrfInfo.Reflectance90);
            float G1 = SmithGGXMasking(NdotV, AlphaRoughness);
            float G2 = SmithGGXShadowMasking(NdotL, NdotV, AlphaRoughness);
            // Note: G1 is % microfacets visible in 1 direction
            //       G2 is % microfacets visible in 2 directions
#if OPTIMIZED_BRDF_REFLECTANCE
            // Eq. (19) from [2]
            Sample.Reflectance = F * (G2 / G1) / SMITH_GGX_SPECULAR_PROB;
#else
            // Optimized reflectance formulation above is equivalent to the following
            // standard Monte-Carlo estimator:
            float3 DiffuseContrib, SpecContrib;
            SmithGGX_BRDF(Sample.Dir, // To light
                          Hit.Normal,
                          View,
                          SrfInfo,
                          DiffuseContrib,
                          SpecContrib,
                          NdotL
            );
            Sample.Reflectance = SpecContrib * NdotL / Sample.Prob;
#endif
        }
    }

    return Sample;
}

BRDFSamplingAttribs SampleBRDFDirection(HitInfo Hit, float3 View, float3 rnd3)
{
#if BRDF_SAMPLING_MODE == BRDF_SAMPLING_MODE_COS_WEIGHTED
    {
        BRDFSamplingAttribs Sample;
        SampleDirectionCosineHemisphere(Hit.Normal, rnd3.xy, Sample.Dir, Sample.Prob);
        // Reflectance = BRDF * CosTheta / Prob
        // Prob = CosTheta / PI
        // Thus:
        Sample.Reflectance = BRDF(Hit, View, Sample.Dir) * PI;
        return Sample;
    }
#elif BRDF_SAMPLING_MODE == BRDF_SAMPLING_MODE_IMPORTANCE_SAMPLING
    {
        return ImportanceSampleSmithGGX(Hit, View, rnd3);
    }
#endif
}

// Gets the probability of the direction in Lambertian + Smith-GGX BRDF
float BRDFSampleDirection_PDF(HitInfo Hit, float3 V, float3 L)
{
    float3 N = Hit.Normal;

    float NdotV = dot(V, N);
    float NdotL = dot(L, N);
    if (NdotL <= 0.0 || NdotV <= 0.0)
        return 0.0;

    // Diffuse path
    float Prob = NdotL / PI * (1.0 - SMITH_GGX_SPECULAR_PROB);

    // Specular path
    float AlphaRoughness = Hit.Mat.Roughness * Hit.Mat.Roughness;
    float VNDF = SmithGGXSampleDirectionPDF(V, N, L, AlphaRoughness);
    Prob += VNDF * SMITH_GGX_SPECULAR_PROB;

    return Prob;
}


// Reconstructs primary ray from the G-buffer
void GetPrimaryRay(in  uint2   ScreenXY,
                   out HitInfo Hit,
                   out RayInfo Ray)
{
    float  fDepth         = g_Depth.Load(int3(ScreenXY, 0)).r;
    float4 f4BaseCol_Type = g_BaseColor.Load(int3(ScreenXY, 0));
    float4 f4Emittance    = g_Emittance.Load(int3(ScreenXY, 0));
    float4 f4Normal_IOR   = g_Normal.Load(int3(ScreenXY, 0));
    float2 f2PhysDesc     = g_PhysDesc.Load(int3(ScreenXY, 0)).rg;


    float3 HitPos = ScreenToWorld(float2(ScreenXY) + float2(0.5, 0.5),
                                  fDepth, 
                                  g_Constants.f2ScreenSize,
                                  g_Constants.ViewProjInvMat);

    Ray.Origin = g_Constants.CameraPos.xyz;
    float3 RayDir = HitPos - Ray.Origin;
    float  RayLen = length(RayDir);
    Ray.Dir = RayDir / RayLen;

    Hit.Mat.BaseColor = float4(f4BaseCol_Type.rgb, 0.0);
    Hit.Mat.Emittance = f4Emittance;
    Hit.Mat.Metallic  = f2PhysDesc.x;
    Hit.Mat.Roughness = f2PhysDesc.y;
    Hit.Mat.Type      = int(f4BaseCol_Type.a * 255.0);
    Hit.Mat.IOR       = max(f4Normal_IOR.w * IOR_GBUFFER_SCALE, 1.0);

    Hit.Normal   = normalize(f4Normal_IOR.xyz * 2.0 - 1.0);
    Hit.Distance = RayLen;
}

// Returns the light source projected area
float GetLightProjectedArea(LightAttribs Light, float3 Dir, float DistSqr)
{
    //        ______
    //       /    .'
    //      /   .'
    //     /  .'
    //    / .'
    //   /.'
    float  fLightArea    = (Light.f2SizeXZ.x * 2.0) * (Light.f2SizeXZ.y * 2.0);
    float3 f3LightNormal = Light.f4Normal.xyz;
    return fLightArea * max(dot(-Dir, f3LightNormal), 0.0) / DistSqr;
}

// Sample a random point on the light source surface and evaluate terms
// required for the next event estimation.
//
//     L(x->v)      L(x<-l)
//          '.   .'
//        v   '.'   l
//             x
// 
//  L(x->v) = L(x->l) * V(x, l) * BRDF(x, v, l) * (n, l) / p(l)
//
struct LightSampleAttribs
{
    float3 f3Emittance;  // L(x->l)
    float3 f3Dir;        // l
    float  fVisibility;  // V(l)
    float  Prob;         // p(l)
};
LightSampleAttribs SampleLightSource(in  LightAttribs Light, 
                                     in  float2       rnd2,
                                     in  float3       f3SrfPos // x
                                     )
{
    LightSampleAttribs Sample;

    Sample.f3Emittance = Light.f4Intensity.rgb * Light.f4Intensity.a;

    float3 f3SamplePos = GetLightSamplePos(Light, rnd2);
    Sample.f3Dir       = f3SamplePos - f3SrfPos;
    float fDistToLightSqr = dot(Sample.f3Dir, Sample.f3Dir);
    Sample.f3Dir /= sqrt(fDistToLightSqr);

    // Trace shadow ray towards the light
    RayInfo ShadowRay;
    ShadowRay.Origin   = f3SrfPos;
    ShadowRay.Dir      = Sample.f3Dir;
    Sample.fVisibility = TestShadow(g_Constants.Scene, ShadowRay);

    // We need to compute p(l) which is the probability density of the direction l
    // and is equal to 1 over the solid angle spanned by the light source:
    float fSolidAngle = GetLightProjectedArea(Light, Sample.f3Dir, fDistToLightSqr);
    Sample.Prob = fSolidAngle > 0.0 ? 1.0 / fSolidAngle : 0.0;

    return Sample;
}

// Get the probability density of sampling light source with the given direction
float LightDirPDF(LightAttribs Light, float3 f3HitPos, float3 f3DirToLight)
{
    HitInfo Hit = NullHit();
    RayInfo Ray;
    Ray.Origin = f3HitPos;
    Ray.Dir    = f3DirToLight;
    IntersectLight(Ray, Light, Hit);
    if (Hit.Mat.Type != MAT_TYPE_DIFFUSE_LIGHT)
    {
        // Ray does not hit the light box
        return 0.0;
    }

    if (max(Hit.Mat.Emittance.x, max(Hit.Mat.Emittance.y, Hit.Mat.Emittance.z)) == 0.0)
    {
        // Ray hits the light box in the non-emissive surface
        return 0.0;
    }

    // Probability density of the direction l is equal to 1 over the solid angle
    // spanned by the light source.
    float fDistToLightSqr = Hit.Distance * Hit.Distance;
    float fSolidAngle     = GetLightProjectedArea(Light, f3DirToLight, fDistToLightSqr);
    return fSolidAngle > 0 ? 1.0 / fSolidAngle : 0.0;
}


void Reflect(HitInfo Hit, float3 f3HitPos, inout RayInfo Ray, inout float3 f3Througput)
{
    Ray.Origin = f3HitPos;
    Ray.Dir    = reflect(Ray.Dir, Hit.Normal);
    f3Througput *= Hit.Mat.BaseColor.rgb;
}


// Fresnel term
// https://en.wikipedia.org/wiki/Fresnel_equations
//
//             cosThetaI
//           |      .'
//           |    .'
//           |  .'      Ri
//   ________|.'__________    eta = Ri/Rt
//          /|
//         / |          Rt
//        /  |
//       /   |
//  cosThetaT
//
float Fresnel(float eta, float cosThetaI)
{
    cosThetaI = clamp(cosThetaI, -1.0, 1.0);
    if (cosThetaI < 0.0)
    {
        eta = 1.0 / eta;
        cosThetaI = -cosThetaI;
    }

    // Snell's law:
    // Ri * sin(ThetaI) = Rt * sin(ThetaT)
    float sinThetaTSq = eta * eta * (1.0 - cosThetaI * cosThetaI);
    if (sinThetaTSq >= 1.0)
    {
        // Total internal reflection
        return 1.0;
    }

    float cosThetaT = sqrt(1.0 - sinThetaTSq);

    float Rs = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);
    float Rp = (eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI);

    return 0.5 * (Rs * Rs + Rp * Rp);
}

void Refract(HitInfo Hit, float3 f3HitPos, inout RayInfo Ray, inout float3 f3Througput, float rnd)
{
    // Compute fresnel term
    float AirIOR    = 1.0;
    float GlassIOR  = Hit.Mat.IOR;
    float relIOR    = AirIOR / GlassIOR;
    float cosThetaI = dot(-Ray.Dir, Hit.Normal);
    if (cosThetaI < 0.0)
    {
        Hit.Normal *= -1.0;
        cosThetaI  *= -1.0;
        relIOR = 1.0 / relIOR;
    }
    float F = Fresnel(relIOR, cosThetaI);

    // Choose between refraction path and reflection path
    if (rnd <= F)
    {
        // Note that technically we need to multiply throughput by F,
        // but also by 1/P, but since P==F they cancel out.
        Reflect(Hit, f3HitPos, Ray, f3Througput);
    }
    else
    {
        Ray.Origin = f3HitPos;
        Ray.Dir    = refract(Ray.Dir, Hit.Normal, relIOR);

        // Note that this is not very accurate as we need to
        // compute optical depth of the light path through glass.
        // This is good enough for this example.
        f3Througput *= Hit.Mat.BaseColor.rgb;

        // Note that refraction also changes the differential solid angle of the flux
        f3Througput /= relIOR * relIOR;
    }
}

// Computes the multiple-importance sampling weight using the
// balance heuristics.
float GetMISWeight(float Prob1, float Prob2)
{
    float W1 = pow(Prob1, g_Constants.fBalanceHeuristicsPower);
    float W2 = pow(Prob2, g_Constants.fBalanceHeuristicsPower);
    float W  = W1 + W2;
    return W > 0 ? W1 / W : 0.0;
}

float4 main(in PSInput PSIn) : SV_TARGET0
{
    HitInfo Hit0;
    RayInfo Ray0;
    GetPrimaryRay(uint2(PSIn.Pos.xy), Hit0, Ray0);

    if (Hit0.Mat.Type == MAT_TYPE_NONE)
    {
        // Background
        return float4(0.0, 0.0, 0.0, 0.0);
    }

    float3 f3Radiance = float3(0.0, 0.0, 0.0);

    // Rendering equation
    //
    //   L(x->v)         L(x<-w)
    //      '.           .'
    //        '.       .'
    //        v '.   .' w
    //            '.'
    //             x
    //
    //      L(x->v) = E(x) + Integral{ BRDF(x, v, w) * L(x<-w) * (n, w) * dw }      (1)
    //
    // Monte-Carlo integration:
    //
    //   L(x1->v)         x2
    //       .           .'.
    //        '.       .'   '.
    //        v '.   .' w1    '.w2
    //            '.'           '. 
    //             x1             x3
    //
    //      L(x1->v) = 1/N * Sum{ E(x1) + BRDF(x1, v1, w1) * [E(x2) + BRDF(x2, -w1, w2) * (...) * (n2, w2) * 1/p(w2)]  * (n1, w1) * 1/p(w1) }   (2)
    //
    //  This can be rewritten as
    //
    //      L(x1->v) = 1/N * { T0 * E(x1) + T1 * E(x2) + T2 * E(x3) + ... }     (3)
    //
    //  where Ti is the throughput after i bounces:
    //
    //      T0 = 1                                              (4)
    //      Ti = Ti-1 * BRDF(xi, vi, wi) * (ni, wi) / p(wi)     (5)

    // Make sure the seed is unique for each sample
    uint2 Seed = uint2(PSIn.Pos.xy) * uint2(11417, 7801) + uint2(g_Constants.uFrameSeed1, g_Constants.uFrameSeed2);
    for (int i = 0; i < g_Constants.iNumSamplesPerFrame; ++i)
    {
        // Each path starts with the primary camera ray
        HitInfo Hit = Hit0;
        RayInfo Ray = Ray0;

        // Total contribution of this path
        float3 f3PathContrib = float3(0.0, 0.0, 0.0);
        if (g_Constants.iUseNEE != 0)
        {
            // We need to add emittance from the first hit, which is like performing
            // light source sampling for the primary ray origin (aka "0-th" hit).
            f3PathContrib += Hit0.Mat.Emittance.rgb;
        }

        // Path throughput, or the maximum possible remaining contribution after all bounces so far.
        float3 f3Throughput = float3(1.0, 1.0, 1.0); // T0

        // Note that when using next event estimation, we sample light source at each bounce.
        // To compensate for that, we add extra bounce when not using NEE.
        for (int j = 0; j < g_Constants.iNumBounces + (1 - g_Constants.iUseNEE); ++j)
        {
            if (g_Constants.iShowOnlyLastBounce != 0)
                f3PathContrib = float3(0.0, 0.0, 0.0);

            if (Hit.Mat.Type == MAT_TYPE_NONE)
                break;

            if (max(f3Throughput.x, max(f3Throughput.y, f3Throughput.z)) == 0.0)
                break;

            float3 f3HitPos = Ray.Origin + Ray.Dir * Hit.Distance;

            // Get uniform random variables
            float3 rnd3 = hash32(Seed);
            Seed += uint2(129, 1725);

            if (Hit.Mat.Type == MAT_TYPE_MIRROR)
            {
                Reflect(Hit, f3HitPos, Ray, f3Throughput);
                // Note: if NEE is enabled, we need to perform light sampling here.
                //       However, since we need to sample the light in the same reflected direction,
                //       we will add its contribution later when we find the next hit point.
            }
            else if (Hit.Mat.Type == MAT_TYPE_GLASS)
            {
                Refract(Hit, f3HitPos, Ray, f3Throughput, rnd3.x);
                // As with mirror, we will perform light sampling later
            }
            else
            {
                if (g_Constants.iUseNEE != 0)
                {
                    // Sample light source
                    #if NEE_MODE == NEE_MODE_LIGHT || NEE_MODE == NEE_MODE_MIS || NEE_MODE == NEE_MODE_MIS_LIGHT
                    {
                        // Trace a ray towards the light source to estimate E(xi) instead of using E(xi) from the hit:
                        // 
                        //      E(xi) = BRDF(xi, vi, li) * (ni, li) * L(xi, li) * V(xi, li) / p(li)
                        //
                        // Notice how this way we start with E(x2) and skip E(x1) in (2), which is why we needed to add
                        // the primary ray hit emittance above.

                        LightSampleAttribs LightSample = SampleLightSource(g_Constants.Scene.Light, rnd3.xy, f3HitPos);
                        if (LightSample.Prob > 0)
                        {
                            float MISWeight = 1.0;
                            #if NEE_MODE == NEE_MODE_MIS || NEE_MODE == NEE_MODE_MIS_LIGHT
                            {
                                // Get probability of this direction in BRDF distribution
                                float BRDFProb = BRDFSampleDirection_PDF(Hit, -Ray.Dir, LightSample.f3Dir);
                                // Compute the MIS weight
                                MISWeight = GetMISWeight(LightSample.Prob, BRDFProb);
                                // Note that when the balance heuristics power is 1.0,
                                // MISWeight / LightSample.Prob == 1 / (LightSample.Prob + BRDFProb)
                            }
                            #endif
                            float NdotL = max(dot(LightSample.f3Dir, Hit.Normal), 0.0);
                            f3PathContrib +=
                                f3Throughput                             // Ti-1
                                * MISWeight                              // MIS weight
                                * BRDF(Hit, -Ray.Dir, LightSample.f3Dir) // BRDF(xi, vi, li)
                                * NdotL                                  // (ni, li)
                                * LightSample.f3Emittance                // L(xi, li)
                                * LightSample.fVisibility                // V(xi, li)
                                / LightSample.Prob;                      // p(li)

                            // Note that L in the rendering equation is radiance, however
                            // L * dl ~ Irradiance aka Emittance
                        }
                    }
                    #endif

                    // Sample BRDF
                    #if NEE_MODE == NEE_MODE_BRDF || NEE_MODE == NEE_MODE_MIS || NEE_MODE == NEE_MODE_MIS_BRDF
                    {
                        // Sample the BRDF
                        BRDFSamplingAttribs BRDFSample = SampleBRDFDirection(Hit, -Ray.Dir, rnd3.zxy);
                        // Check if the ray hits the light
                        HitInfo LightHit = NullHit();
                        RayInfo LightRay;
                        LightRay.Origin = f3HitPos;
                        LightRay.Dir    = BRDFSample.Dir;
                        IntersectLight(LightRay, g_Constants.Scene.Light, LightHit);
                        if (LightHit.Mat.Type == MAT_TYPE_DIFFUSE_LIGHT &&
                            max(LightHit.Mat.Emittance.r, max(LightHit.Mat.Emittance.g, LightHit.Mat.Emittance.b)) > 0.0)
                        {
                            // Get light visibility
                            float fLightVisibility = TestShadow(g_Constants.Scene, LightRay);
                            if (fLightVisibility > 0)
                            {
                                float NdotL = dot(BRDFSample.Dir, Hit.Normal);
                                if (NdotL > 0)
                                {
                                    float MISWeight = 1.0;
                                    #if NEE_MODE == NEE_MODE_MIS || NEE_MODE == NEE_MODE_MIS_BRDF
                                    {
                                        // Get the probability of this direction in light sampling distribution
                                        float LightProb = LightDirPDF(g_Constants.Scene.Light, f3HitPos, BRDFSample.Dir);
                                        // Compute the MIS weight
                                        MISWeight = GetMISWeight(BRDFSample.Prob, LightProb);
                                    }
                                    #endif
                                    f3PathContrib +=
                                        f3Throughput                 // Ti-1
                                        * MISWeight                  // MIS Weight
                                        * BRDFSample.Reflectance     // BRDF(xi, vi, li) * (ni, li) / p(li)
                                        * LightHit.Mat.Emittance.rgb // L(xi, li)
                                        * fLightVisibility;          // V(xi, li)
                                }
                            }
                        }
                    }
                    #endif
                }
                else
                {
                    f3PathContrib += 
                        f3Throughput *         // Ti-1
                        Hit.Mat.Emittance.rgb; // E(xi)
                }

                // NEE effectively performs one additional bounce
                if (j == g_Constants.iNumBounces - g_Constants.iUseNEE)
                {
                    // Last bounce - complete the loop
                    break; 
                }

                // Sample the BRDF
                BRDFSamplingAttribs BRDFSample = SampleBRDFDirection(Hit, -Ray.Dir, rnd3);
                // Ti = Ti-1 * BRDF(xi, vi, wi) * (ni, wi) / p(wi)
                //             |-----------Reflectance-----------|
                f3Throughput *= BRDFSample.Reflectance;

                Ray.Origin = f3HitPos;
                Ray.Dir    = BRDFSample.Dir;
            }

            // We did not perform next event estimation for the mirror surface and
            // we need to add emittance of the next hit point.
            bool AddEmittance = (g_Constants.iUseNEE != 0) && (Hit.Mat.Type == MAT_TYPE_MIRROR || Hit.Mat.Type == MAT_TYPE_GLASS);

            // Trace the scene in the selected direction
            Hit = IntersectScene(Ray, g_Constants.Scene);

            if (AddEmittance)
                f3PathContrib += f3Throughput * Hit.Mat.Emittance.rgb;
        }

        // Combine contributions
        f3Radiance += f3PathContrib;
    }

    // Add the total radiance to the accumulation buffer
    if (g_Constants.fLastSampleCount > 0)
        f3Radiance += g_Radiance.Load(int3(PSIn.Pos.xy, 0)).rgb;
    return float4(f3Radiance, 0.0);
}
#pragma pack_matrix(row_major)

#include "structures.fxh"

Texture2D g_Radiance;

cbuffer cbConstants
{
    ShaderConstants g_Constants;
}

struct PSInput 
{ 
    float4 Pos    : SV_POSITION; 
    float2 ClipXY : ClipPos; 
};

struct PSOutput
{
    float4 Color : SV_TARGET0;
};

void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{
    PSOut.Color = g_Radiance.Load(int3(PSIn.Pos.xy, 0)) / g_Constants.fCurrSampleCount;
}
#ifndef _SCENE_FXH_
#define _SCENE_FXH_

#include "structures.fxh"

#define PI      3.1415927
#define INF     1e+30
#define EPSILON 1e-2

float3 ClipToWorld(float4 ClipPos, float4x4 ViewProjInvMat)
{
#if defined(DESKTOP_GL) || defined(GL_ES)
    ClipPos.y *= -1.0;
#endif
    // Reconstruct world position by applying inverse view-projection matrix
    float4 WorldPos = mul(ClipPos, ViewProjInvMat);
    return WorldPos.xyz / WorldPos.w;
}

float3 ScreenToWorld(float2 PixelXY, float Depth, float2 ScreenSize, float4x4 ViewProjInvMat)
{
    // Get clip-space position
    float4 ClipPos;
    ClipPos.xy = PixelXY / ScreenSize * float2(2.0, -2.0) + float2(-1.0, 1.0);
    ClipPos.z  = Depth;
    ClipPos.w  = 1.0;
    return ClipToWorld(ClipPos, ViewProjInvMat);
}


float3 RotateY(float3 V, float a) {
    float s, c;
    sincos(a, s, c);
    float2x2 mat;
    mat[0] = float2( c, s);
    mat[1] = float2(-s, c);
    float2 xz = mul(V.xz, mat);
    return float3(xz.x, V.y, xz.y);
}

struct RayInfo
{
    float3 Origin;
    float3 Dir;
};

RayInfo RotateRayY(RayInfo Ray, float a)
{
    RayInfo RotatedRay;
    RotatedRay.Origin = RotateY(Ray.Origin, a);
    RotatedRay.Dir    = RotateY(Ray.Dir,    a);
    return RotatedRay;
}

struct HitInfo
{
    Material Mat;
    float3   Normal;
    float    Distance;
};


Material NullMaterial()
{
    Material Mat;
    Mat.BaseColor = float4(0.0, 0.0, 0.0, 0.0);
    Mat.Emittance = float4(0.0, 0.0, 0.0, 0.0);
    Mat.Type      = MAT_TYPE_NONE;
    Mat.Metallic  = 0.0;
    Mat.Roughness = 0.0;
    Mat.IOR       = 0.0;
    return Mat;
}

HitInfo NullHit()
{
    HitInfo Hit;
    Hit.Mat      = NullMaterial();
    Hit.Normal   = float3(0.0, 0.0, 0.0);
    Hit.Distance = INF;
    return Hit;
}

bool IntersectAABB(in    RayInfo Ray,
                   in    BoxInfo Box,
                   inout HitInfo Hit)
{
    float3 t1     = (Box.Center - Box.Size - Ray.Origin) / Ray.Dir;
    float3 t2     = (Box.Center + Box.Size - Ray.Origin) / Ray.Dir;
    float3 t_min  = min(t1, t2);
    float3 t_max  = max(t1, t2);
    float  t_near = max(max(t_min.x, t_min.y), t_min.z);
    float  t_far  = min(min(t_max.x, t_max.y), t_max.z);
    if (t_near >= t_far)
        return false;

    // Use far intersection if t_near > EPSILON.
    // This is important to avoid light leaks.
    float t = t_near > EPSILON ? t_near : t_far;
    if (t < EPSILON || t_near > Hit.Distance)
        return false;

    Hit.Mat = Box.Mat;
    // Compute normal for the entry point. We only use internal intersection for shadows.
    Hit.Normal   = -sign(Ray.Dir) * step(t_min.yzx, t_min.xyz) * step(t_min.zxy, t_min.xyz);
    Hit.Distance = t;

    return true;
}

bool IntersectRotatedAABB(in    RayInfo Ray,
                          in    BoxInfo Box,
                          in    float   RotationY,
                          inout HitInfo Hit)
{
    RayInfo RotRay = RotateRayY(Ray, -RotationY);
    if (IntersectAABB(RotRay, Box, Hit))
    {
        Hit.Normal = RotateY(Hit.Normal, RotationY);
        return true;
    }

    return false;
}

bool IntersectSphere(in    RayInfo    Ray,
                     in    SphereInfo Sphere,
                     inout HitInfo    Hit)
{
    // http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection
    float3 Orig = Ray.Origin - Sphere.Center;
    float A = dot(Ray.Dir, Ray.Dir);
    float B = 2.0 * dot(Orig, Ray.Dir);
    float C = dot(Orig, Orig) - Sphere.Radius * Sphere.Radius;
    float D = B * B - 4.0 * A * C;
    // If discriminant is negative, there are no real roots hence the ray misses the
    // sphere
    if (D < 0.0)
        return false;

    D = sqrt(D);
    float t_near = (-B - D) / (2.0 * A);
    float t_far  = (-B + D) / (2.0 * A);
    
    float t = t_near > EPSILON ? t_near : t_far;
    if (t < EPSILON || t > Hit.Distance)
        return false;

    float3 HitPos = Ray.Origin + t * Ray.Dir;

    Hit.Mat      = Sphere.Mat;
    Hit.Normal   = normalize(HitPos - Sphere.Center);
    Hit.Distance = t;

    return true;
}

void IntersectWalls(RayInfo Ray, inout HitInfo Hit)
{
    float RoomSize  = 10.0;
    float WallThick = 0.05;

    BoxInfo Box;
    Box.Mat.Type      = MAT_TYPE_SMITH_GGX;
    Box.Mat.Emittance = float4(0.0, 0.0, 0.0, 0.0);
    Box.Mat.Metallic  = 0.0;
    Box.Mat.Roughness = 1.0;
    Box.Mat.IOR       = 1.0;

    float4 Green = float4(0.1, 0.6, 0.1, 0.0);
    float4 Red   = float4(0.6, 0.1, 0.1, 0.0);
    float4 Grey  = float4(0.5, 0.5, 0.5, 0.0);

    // Right wall
    Box.Center        = float3(RoomSize * 0.5 + WallThick * 0.5, 0.0, 0.0);
    Box.Size          = float3(WallThick, RoomSize * 0.5, RoomSize * 0.5);
    Box.Mat.BaseColor = Green;
    IntersectAABB(Ray, Box, Hit);

    // Left wall
    Box.Center        = float3(-RoomSize * 0.5 - WallThick * 0.5, 0.0, 0.0);
    Box.Size          = float3(WallThick, RoomSize * 0.5, RoomSize * 0.5);
    Box.Mat.BaseColor = Red;
    IntersectAABB(Ray, Box, Hit);

    // Ceiling
    Box.Center        = float3(0.0, +RoomSize * 0.5 + WallThick * 0.5, 0.0);
    Box.Size          = float3(RoomSize * 0.5, WallThick, RoomSize * 0.5);
    Box.Mat.BaseColor = Grey;
    IntersectAABB(Ray, Box, Hit);

    // Floor
    Box.Center        = float3(0.0, -RoomSize * 0.5 + WallThick * 0.5, 0.0);
    Box.Size          = float3(RoomSize * 0.5, WallThick, RoomSize * 0.5);
    Box.Mat.BaseColor = Grey;
    IntersectAABB(Ray, Box, Hit);

    // Back wall
    Box.Center        = float3(0.0, 0.0, +RoomSize * 0.5 + WallThick * 0.5);
    Box.Size          = float3(RoomSize * 0.5, RoomSize * 0.5, WallThick);
    Box.Mat.BaseColor = Grey;
    IntersectAABB(Ray, Box, Hit);
}

void IntersectSceneInterior(SceneAttribs Scene, RayInfo Ray, inout HitInfo Hit)
{
    IntersectSphere(Ray, Scene.Balls[0], Hit);
    IntersectSphere(Ray, Scene.Balls[1], Hit);
    IntersectSphere(Ray, Scene.Balls[2], Hit);
    IntersectSphere(Ray, Scene.Balls[3], Hit);
    IntersectSphere(Ray, Scene.Balls[4], Hit);
    IntersectSphere(Ray, Scene.Balls[5], Hit);
}

BoxInfo GetLight(LightAttribs Light)
{
    BoxInfo Box;
    Box.Center = float3(Light.f2PosXZ.x,  4.90, Light.f2PosXZ.y);
    Box.Size   = float3(Light.f2SizeXZ.x, 0.02, Light.f2SizeXZ.y);

    Box.Mat.Type      = MAT_TYPE_DIFFUSE_LIGHT;
    Box.Mat.BaseColor = float4(0.75, 0.75, 0.75, 0.0);
    Box.Mat.Emittance = float4(Light.f4Intensity.rgb * Light.f4Intensity.a, 0.0);
    Box.Mat.Metallic  = 0.0;
    Box.Mat.Roughness = 1.0;
    Box.Mat.IOR       = 1.5;
    return Box;
}

void IntersectLight(RayInfo Ray, LightAttribs Light, inout HitInfo Hit)
{
    BoxInfo Box = GetLight(Light);
    if (IntersectAABB(Ray, Box, Hit))
    {
        // Check that the ray hit the light from the emissive side
        if (dot(Hit.Normal, Light.f4Normal.xyz) < 0.99)
        {
            Hit.Mat.Emittance = float4(0.0, 0.0, 0.0, 0.0);
        }
    }
}

HitInfo IntersectScene(RayInfo Ray, SceneAttribs Scene)
{
    HitInfo Hit = NullHit();

    IntersectSceneInterior(Scene, Ray, Hit);
    IntersectWalls(Ray, Hit);
    IntersectLight(Ray, Scene.Light, Hit);

    return Hit;
}

float TestShadow(SceneAttribs Scene, RayInfo Ray)
{
    if (Ray.Dir.y <= 0.0)
        return 0.0;

    HitInfo Hit = NullHit();

    IntersectSceneInterior(Scene, Ray, Hit);

    return Hit.Distance < INF ? 0.0 : 1.0;
}

float3 GetLightSamplePos(LightAttribs Light, float2 uv)
{
    BoxInfo Box = GetLight(Light);
    float3 Corner0 = Box.Center - Box.Size;
    float3 Corner1 = Box.Center + Box.Size;
    float3 Sample;
    Sample.xz = lerp(Corner0.xz, Corner1.xz, uv);
    Sample.y  = Corner0.y;
    return Sample;
}

#endif // _SCENE_FXH_
#pragma pack_matrix(row_major)

struct PSInput 
{ 
    float4 Pos    : SV_POSITION;
    float2 ClipXY : ClipPos;
};

// Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex
// shader output variable name must match exactly the name of the pixel shader input variable.
// If the variable has structure type (like in this example), the structure declarations must also be identical.
void main(in  uint    VertID : SV_VertexID,
          out PSInput PSIn) 
{
    float2 ClipXY[3];
    ClipXY[0] = float2(-1.0, -1.0);
    ClipXY[1] = float2(-1.0,  3.0);
    ClipXY[2] = float2( 3.0, -1.0);

    PSIn.Pos    = float4(ClipXY[VertID], 0.0, 1.0);
    PSIn.ClipXY = ClipXY[VertID];
}
#ifndef _STRUCTURES_FXH_
#define _STRUCTURES_FXH_

#define MAT_TYPE_NONE          0
#define MAT_TYPE_SMITH_GGX     1
#define MAT_TYPE_GLASS         2
#define MAT_TYPE_MIRROR        3
#define MAT_TYPE_DIFFUSE_LIGHT 4

#define NUM_BALLS 6

#define IOR_GBUFFER_SCALE 5.0

struct Material
{
    float4 BaseColor;
    float4 Emittance;

    int   Type;
    float Metallic;
    float Roughness;
    float IOR;
};

struct BoxInfo
{
    float3 Center;
    float3 Size;

    Material Mat;
};

struct SphereInfo
{
    float3 Center;
    float  Radius;

    Material Mat;
};

struct LightAttribs
{
	float2 f2PosXZ;
	float2 f2SizeXZ;
	float4 f4Intensity;
	float4 f4Normal;
};

struct SceneAttribs
{
	LightAttribs Light;
	SphereInfo   Balls[NUM_BALLS];
};

struct ShaderConstants
{
	uint2  u2ScreenSize;
	float2 f2ScreenSize;

	float fLastSampleCount;
	float fCurrSampleCount;
	int   iNumBounces;
	int   iNumSamplesPerFrame;

	uint uFrameSeed1;
	uint uFrameSeed2;
	int  iShowOnlyLastBounce;
	int  iUseNEE;

	float fBalanceHeuristicsPower;
	float fPadding0;
	float fPadding1;
	float fPadding2;

	float4x4 ViewProjMat;
	float4x4 ViewProjInvMat;
	float4   CameraPos;

	SceneAttribs Scene;
};

#endif // _STRUCTURES_FXH_
